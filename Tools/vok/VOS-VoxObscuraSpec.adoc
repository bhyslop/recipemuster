= Vox Obscura Specification
:doctype: book

// tag::mapping-section[]
//
// Category declarations:
// vost_:  Types (scalar identifiers with validation rules)
// vose_:  Entities (objects with structure and behavior)
// vosem_: Entity members (fields within entities)
// vosp_:  Places (repository and location concepts)
// vosa_:  Assets (distributable or indexed artifacts)
// voso:   Operations (non-terminal, has children: vosoi_, vosok_, vosou_, vosor_)
// vosk_:  Key premises (design constraints)
// vosc_:  Control terms (voices axc_* in bash scripted context)
// voss_:  Section headers (voices axs_*)
//
// vosl:   Liturgy (non-terminal, naming system umbrella)
// voslc_: Liturgy Cipher (project root prefix)
// vosls_: Liturgy Signet (complete prefix before separator)
// vosle_: Liturgy Epithet (descriptive word after separator)
// vosli_: Liturgy Inscription (full artifact name)
// voslv_: Liturgy Vesture (domain construction rules)
// vosln_: Liturgy Ensign (signet extension that classifies category)
// voslm_: Liturgy Monogram (signet extension that binds to epithet initial)
// vosld:  Liturgy Domain (non-terminal, domain-specific vestures)
// vosldr_: Liturgy Domain Rust (Rust source vesture)
// vosldb_: Liturgy Domain Bash (Bash source vesture)
// voslda_: Liturgy Domain AsciiDoc (AsciiDoc attribute vesture)
// vosldp_: Liturgy Domain Publication (spec/publication vesture)
// vosldg_: Liturgy Domain Git (git ref vesture)
// voslds_: Liturgy Domain Slash (slash command vesture)
// vosldt_: Liturgy Domain Tabtarget (tabtarget vesture)
//
// vosd:   Dispatch (non-terminal, tabtarget system umbrella)
// vosdc_: Dispatch Colophon (routing identifier)
// vosdf_: Dispatch Frontispiece (human-readable description)
// vosdi_: Dispatch Imprint (embedded parameter/target specifier)
// vosdm_: Dispatch Formulary (routing component)
// vosdl_: Dispatch Launcher (bootstrap script)
//
// Variant patterns:
//   _s: plural form
//   _p: possessive form
//

// Liturgy (naming system)
:voslc_cipher:          <<voslc_cipher,Cipher>>
:voslc_cipher_s:        <<voslc_cipher,Ciphers>>
:voslc_cipher_p:        <<voslc_cipher,Cipher's>>
:vosls_signet:          <<vosls_signet,Signet>>
:vosls_signet_s:        <<vosls_signet,Signets>>
:vosle_epithet:         <<vosle_epithet,Epithet>>
:vosle_epithet_s:       <<vosle_epithet,Epithets>>
:vosli_inscription:     <<vosli_inscription,Inscription>>
:vosli_inscription_s:   <<vosli_inscription,Inscriptions>>
:voslv_vesture:         <<voslv_vesture,Vesture>>
:voslv_vesture_s:       <<voslv_vesture,Vestures>>
:vosln_ensign:          <<vosln_ensign,Ensign>>
:vosln_ensign_s:        <<vosln_ensign,Ensigns>>
:voslm_monogram:        <<voslm_monogram,Monogram>>
:voslm_monogram_s:      <<voslm_monogram,Monograms>>

// Liturgy Domains (vesture specializations)
:vosldr_rust:           <<vosldr_rust,Rust Vesture>>
:vosldb_bash:           <<vosldb_bash,Bash Vesture>>
:voslda_asciidoc:       <<voslda_asciidoc,AsciiDoc Vesture>>
:vosldp_publication:    <<vosldp_publication,Publication Vesture>>
:vosldg_git:            <<vosldg_git,Git Vesture>>
:voslds_slash:          <<voslds_slash,Slash Command Vesture>>
:vosldt_tabtarget:      <<vosldt_tabtarget,Tabtarget Vesture>>

// Dispatch (tabtarget system)
:vosdc_colophon:        <<vosdc_colophon,Colophon>>
:vosdc_colophon_s:      <<vosdc_colophon,Colophons>>
:vosdf_frontispiece:    <<vosdf_frontispiece,Frontispiece>>
:vosdf_frontispiece_s:  <<vosdf_frontispiece,Frontispieces>>
:vosdi_imprint:         <<vosdi_imprint,Imprint>>
:vosdi_imprint_s:       <<vosdi_imprint,Imprints>>
:vosdm_formulary:       <<vosdm_formulary,Formulary>>
:vosdm_formulary_s:     <<vosdm_formulary,Formularies>>
:vosdl_launcher:        <<vosdl_launcher,Launcher>>
:vosdl_launcher_s:      <<vosdl_launcher,Launchers>>

// Types (aliases for backward compatibility)
:vost_cipher:           <<voslc_cipher,Cipher>>
:vost_cipher_s:         <<voslc_cipher,Ciphers>>
:vost_cipher_p:         <<voslc_cipher,Cipher's>>
:vost_sigil:            <<vost_sigil,Sigil>>
:vost_sigil_s:          <<vost_sigil,Sigils>>

// Entities
:vose_parcel:           <<vose_parcel,Parcel>>
:vose_parcel_s:         <<vose_parcel,Parcels>>
:vose_parcel_p:         <<vose_parcel,Parcel's>>
:vose_whisper:          <<vose_whisper,Whisper>>
:vose_whisper_s:        <<vose_whisper,Whispers>>
:vose_whisper_p:        <<vose_whisper,Whisper's>>
:vose_conclave:         <<vose_conclave,Conclave>>
:vose_conclave_p:       <<vose_conclave,Conclave's>>
:vose_kit:              <<vose_kit,Kit>>
:vose_kit_s:            <<vose_kit,Kits>>
:vose_kit_p:            <<vose_kit,Kit's>>
:vose_managed_section:  <<vose_managed_section,Managed Section>>
:vose_managed_section_s: <<vose_managed_section,Managed Sections>>
:vose_marker:           <<vose_marker,Marker>>
:vose_marker_s:         <<vose_marker,Markers>>

// Entity members
:vosem_kit_id:          <<vosem_kit_id,kit_id>>
:vosem_display_name:    <<vosem_display_name,display_name>>
:vosem_file:            <<vosem_file,file>>
:vosem_tag:             <<vosem_tag,tag>>

// Places
:vosp_kit_forge:        <<vosp_kit_forge,Kit Forge>>
:vosp_target_repo:      <<vosp_target_repo,Target Repo>>
:vosp_veiled:           <<vosp_veiled,Veiled>>

// Assets
:vosa_command:          <<vosa_command,Command>>
:vosa_command_s:        <<vosa_command,Commands>>
:vosa_hook:             <<vosa_hook,Hook>>
:vosa_hook_s:           <<vosa_hook,Hooks>>
:vosa_skill:            <<vosa_skill,Skill>>
:vosa_skill_s:          <<vosa_skill,Skills>>
:vosa_subagent:         <<vosa_subagent,Subagent>>
:vosa_subagent_s:       <<vosa_subagent,Subagents>>
:vosa_concept_model:    <<vosa_concept_model,Concept Model>>
:vosa_concept_model_s:  <<vosa_concept_model,Concept Models>>

// Operations (voso has children)
:vosor_release:         <<vosor_release,Release>>
:vosoi_install:         <<vosoi_install,Install>>
:vosok_kit:             <<vosok_kit,Kit Install>>
:vosou_uninstall:       <<vosou_uninstall,Uninstall>>

// Control terms (voice axc_* in bash scripted context)
:vosc_require:          <<vosc_require,REQUIRE>>
:vosc_fatal:            <<vosc_fatal,FATAL>>
:vosc_store:            <<vosc_store,STORE>>
:vosc_call:             <<vosc_call,CALL>>
:vosc_show:             <<vosc_show,SHOW>>
:vosc_step:             <<vosc_step,STEP>>

// Section headers (voice axs_*)
:voss_inputs:           <<voss_inputs,Inputs:>>
:voss_behavior:         <<voss_behavior,Behavior:>>
:voss_outputs:          <<voss_outputs,Outputs:>>
:voss_completion:       <<voss_completion,Completion:>>

// Key premises
:vosk_prefix_validation: <<vosk_prefix_validation,Prefix Validation>>
:vosk_all_or_none:       <<vosk_all_or_none,All Or None>>
:vosk_parcel_self_contained: <<vosk_parcel_self_contained,Parcel Self-Contained>>
:vosk_burc_prerequisite: <<vosk_burc_prerequisite,BURC Prerequisite>>
:vosk_default_routing:   <<vosk_default_routing,Default Routing>>

// end::mapping-section[]

== Overview

The Vox Obscura Specification defines the release and installation infrastructure for Claude Code
{vose_kit_s}.
{vose_kit_s}
are developed in a
{vosp_kit_forge}
and distributed via
{vose_parcel_s}
to
{vosp_target_repo}
consumers.

Each
{vose_kit}
declares itself to the
{vose_conclave}
through a
{vose_whisper}
- a builder-pattern API that registers the
{vose_kit_p}
identity,
{vose_managed_section_s},
and
{vosa_concept_model_s}.

The
{vosor_release}
operation creates a
{vose_parcel}
containing all
{vose_kit}
assets.
The
{vosoi_install}
operation deploys a
{vose_parcel}
to a
{vosp_target_repo}.
The
{vosou_uninstall}
operation cleanly removes a
{vose_kit}
using
{vosls_signet}
-based prefix matching.

== Key Premises

[[vosk_prefix_validation]]
// ⟦axl_voices axk_premise⟧
{vosk_prefix_validation}::
All
{vosa_command_s},
{vosa_hook_s},
{vosa_skill_s},
and
{vosa_subagent_s}
must have
{vosls_signet_s}
derived from their
{vose_kit_p}
{voslc_cipher}.
{vosor_release}
fails if any asset's
{vosli_inscription}
violates the
{voslc_cipher}
derivation rules.
This constraint enables deterministic
{vosou_uninstall}
by
{vosls_signet}
matching.
+
Validation applies to artifact *file names* only.
Internal content (function names, variable names within scripts) is not validated during
{vosor_release}.

[[vosk_all_or_none]]
// ⟦axl_voices axk_premise⟧
{vosk_all_or_none}::
{vosoi_install}
is atomic.
A
{vose_parcel}
represents a tested, coherent release.
No selective installation of individual
{vose_kit_s}
or assets.

[[vosk_parcel_self_contained]]
// ⟦axl_voices axk_premise⟧
{vosk_parcel_self_contained}::
A
{vose_parcel}
contains everything needed for installation.
No dependency resolution or external fetches during
{vosoi_install}.
The
{vose_parcel}
can function from its extracted directory.

[[vosk_burc_prerequisite]]
// ⟦axl_voices axk_premise⟧
{vosk_burc_prerequisite}::
{vosoi_install}
requires BURC (BUK Regime Configuration) in the
{vosp_target_repo}.
The install script reads `.buk/burc.env` to locate `BURC_TOOLS_DIR`.
Install fails immediately if BURC is missing — no bootstrap, no prompts.

[[vosk_default_routing]]
// ⟦axl_voices axk_premise⟧
{vosk_default_routing}::
Assets without special routing rules copy in place, preserving directory structure relative to
{vose_kit}
root.
Only
{vosa_command_s}
and
{vosa_hook_s}
have special routing (to `.claude/commands/` and `.claude/hooks/` respectively).
All other files install to `${BURC_TOOLS_DIR}/{kit}/` maintaining their source-relative paths.

== Control Terms

VOS control terms voice `axc_*` motifs for bash scripted execution context.
These terms appear inline within procedure steps to classify actions.

[[vosc_require]]
// ⟦axl_voices axc_require⟧
{vosc_require}::
Validation check that confirms an expected condition.
Script exits with error if condition not met.

[[vosc_fatal]]
// ⟦axl_voices axc_fatal⟧
{vosc_fatal}::
Immediate termination with error status.
Displays error message and exits non-zero.

[[vosc_store]]
// ⟦axl_voices axc_store⟧
{vosc_store}::
Capture a value into a shell variable for later use.

[[vosc_call]]
// ⟦axl_voices axc_call⟧
{vosc_call}::
Invoke an external command or function.
Captures exit status for processing.

[[vosc_show]]
// ⟦axl_voices axc_show⟧
{vosc_show}::
Display information to stdout.
Progress messages or results.

[[vosc_step]]
// ⟦axl_voices axc_step⟧
{vosc_step}::
Progress message indicating completion of a processing stage.

== Section Headers

VOS section headers voice `axs_*` motifs for procedure documentation structure.

[[voss_inputs]]
// ⟦axl_voices axs_inputs⟧
{voss_inputs}::
Section header for operation input parameters.

[[voss_behavior]]
// ⟦axl_voices axs_behavior⟧
{voss_behavior}::
Section header for operation behavior steps.

[[voss_outputs]]
// ⟦axl_voices axs_outputs⟧
{voss_outputs}::
Section header for operation outputs and artifacts.

[[voss_completion]]
// ⟦axl_voices axs_completion⟧
{voss_completion}::
Section header for operation completion criteria.

== Liturgy

The liturgy vocabulary defines the naming system for VOS artifacts.
A
{voslc_cipher}
seeds the namespace;
{vosls_signet_s}
build on it;
{vosle_epithet_s}
provide human-readable descriptions;
{vosli_inscription_s}
are complete names;
{voslv_vesture_s}
define domain-specific construction rules.

=== Core Liturgy Terms

[[voslc_cipher]]
// ⟦axl_voices axt_string⟧
{voslc_cipher}::
A 2-5 character project root that seeds the namespace.
The
{voslc_cipher}
is globally unique across all projects and serves as the foundation for all derived
{vosls_signet_s}.
Lowercase letters only; no
{voslc_cipher}
may be a prefix of another (terminal exclusivity).
+
Declared as const in `Tools/voi/src/voic_registry.rs` — the single source of truth for all project prefixes.
+
Declaration pattern:
+
[source,rust]
----
// Tools/voi/src/voic_registry.rs - Cipher registry (const declarations)
pub const JJ: voic_Cipher = voic_Cipher::new("jj", "Job Jockey");
pub const BU: voic_Cipher = voic_Cipher::new("bu", "Bash Utilities");
pub const CM: voic_Cipher = voic_Cipher::new("cm", "Concept Model");
pub const VV: voic_Cipher = voic_Cipher::new("vv", "Voce Viva");
----

[[vosls_signet]]
// ⟦axl_voices axt_string⟧
{vosls_signet}::
The complete prefix before the separator in an
{vosli_inscription}.
A
{vosls_signet}
is derived from a
{voslc_cipher}
by extending with additional characters that respect terminal exclusivity.
The
{vosls_signet}
is the identity stamp that binds an artifact to its owning project.
+
Examples: `jjk` (kit), `jjc` (command prefix), `voslc` (this term's signet).
+
A
{vosls_signet}
is extended from its
{voslc_cipher}
using either an
{vosln_ensign}
(classification marker) or a
{voslm_monogram}
(epithet-initial binding).

[[vosln_ensign]]
// ⟦axl_voices axt_string⟧
{vosln_ensign}::
A
{vosls_signet}
extension that classifies artifact category.
The terminal character(s) mark a type or role, independent of the
{vosle_epithet}.
+
Examples:
+
* `axt_string` — `t` = type classification, `string` = epithet
* `burc_regime` — `rc` = regime-config classification, `regime` = epithet
* `axtu_path` — `tu` = type-universal sub-classification, `path` = epithet
+
{vosln_ensign_s}
enable hierarchical categorization within a
{voslc_cipher}
namespace.

[[voslm_monogram]]
// ⟦axl_voices axt_string⟧
{voslm_monogram}::
A
{vosls_signet}
extension where the terminal character binds to the
{vosle_epithet}
initial.
Creates a mnemonic connection between
{vosls_signet}
and
{vosle_epithet}.
+
Examples:
+
* `buc_command` — `c` = first letter of `command`
* `jjw_workbench` — `w` = first letter of `workbench`
* `voslc_cipher` — `c` = first letter of `cipher`
+
{voslm_monogram_s}
create tight signet-epithet binding but limit each terminal letter to one artifact.

[[vosle_epithet]]
// ⟦axl_voices axt_string⟧
{vosle_epithet}::
The descriptive word after the separator in an
{vosli_inscription}.
Provides human-readable meaning while the
{vosls_signet}
provides machine-parseable identity.
+
Examples: `cipher` in `voslc_cipher`, `heat` in `jjc-heat-mount`.

[[vosli_inscription]]
// ⟦axl_voices axt_string⟧
{vosli_inscription}::
The full artifact name combining
{vosls_signet},
separator, and
{vosle_epithet}.
An
{vosli_inscription}
is the complete, unambiguous identifier for any named artifact.
+
Structure: `{signet}{separator}{epithet}`
+
Examples: `voslc_cipher` (underscore separator), `jjc-heat-mount` (hyphen separator).
Domain
{voslv_vesture_s}
may specify additional completion rules (see individual domain definitions).

[[voslv_vesture]]
// ⟦axl_voices axo_entity⟧
{voslv_vesture}::
Domain-specific construction rules for
{vosli_inscription_s}.
Each
{voslv_vesture}
defines signet_case, separator, epithet_case, and envelope for its domain.
Different domains (Rust, Bash, AsciiDoc, etc.) have different naming conventions.
+
A
{voslv_vesture}
is like clothing for a domain — it dresses the abstract naming concepts in domain-appropriate form.

=== Liturgy Domains

[[vosldr_rust]]
// ⟦axl_voices axo_entity⟧
{vosldr_rust}::
{voslv_vesture}
for Rust source identifiers.
+
* signet_case: snake_case
* separator: `_`
* epithet_case: PascalCase for types, snake_case for functions
* envelope: none

[[vosldb_bash]]
// ⟦axl_voices axo_entity⟧
{vosldb_bash}::
{voslv_vesture}
for Bash source identifiers.
+
* signet_case: lowercase
* separator: `_`
* epithet_case: snake_case
* envelope: `.sh` for files

[[voslda_asciidoc]]
// ⟦axl_voices axo_entity⟧
{voslda_asciidoc}::
{voslv_vesture}
for AsciiDoc attribute identifiers.
+
* signet_case: lowercase
* separator: `_`
* epithet_case: snake_case
* envelope: none (attributes), `[[` `]]` for anchors

[[vosldp_publication]]
// ⟦axl_voices axo_entity⟧
{vosldp_publication}::
{voslv_vesture}
for publication and specification files.
+
* signet_case: UPPERCASE
* separator: `-`
* epithet_case: PascalCase
* envelope: `.adoc`, `.md`

[[vosldg_git]]
// ⟦axl_voices axo_entity⟧
{vosldg_git}::
{voslv_vesture}
for git refs.
+
* signet_case: lowercase
* separator: `/`
* epithet_case: kebab-case
* envelope: none

[[voslds_slash]]
// ⟦axl_voices axo_entity⟧
{voslds_slash}::
{voslv_vesture}
for slash command identifiers.
+
* signet_case: lowercase
* separator: `-`
* epithet_case: kebab-case
* envelope: `.md` for files

[[vosldt_tabtarget]]
// ⟦axl_voices axo_entity⟧
{vosldt_tabtarget}::
{voslv_vesture}
for tabtarget launcher identifiers.
+
* signet_case: lowercase with hyphen (colophon)
* separator: `.`
* epithet_case: PascalCase (frontispiece)
* envelope: `.sh`

== Dispatch

The dispatch vocabulary defines the tabtarget launcher system.
A
{vosdl_launcher}
validates arguments and delegates to a
{vosdm_formulary}.
The
{vosdc_colophon}
identifies the routing path;
the
{vosdf_frontispiece}
provides human-readable description;
the
{vosdi_imprint}
embeds target parameters.

[[vosdc_colophon]]
// ⟦axl_voices axt_string⟧
{vosdc_colophon}::
The routing identifier in a tabtarget
{vosli_inscription}.
A
{vosdc_colophon}
determines which
{vosdm_formulary}
handles the dispatch.
Includes the hyphen as part of its identity (e.g., `rbw-`, `buw-tt-`).
+
The
{vosdc_colophon}
is the first component of the tabtarget pattern, before the first dot separator.
+
Examples: `rbw-` routes to RBW workbench, `jjw-` routes to JJK workbench.

[[vosdf_frontispiece]]
// ⟦axl_voices axt_string⟧
{vosdf_frontispiece}::
The human-readable description in a tabtarget
{vosli_inscription}.
A
{vosdf_frontispiece}
uses PascalCase and describes the operation.
+
Appears after the
{vosdc_colophon}
and dot separator.
+
Examples: `Build`, `ConnectBottle`, `RunVVX`.

[[vosdi_imprint]]
// ⟦axl_voices axt_string⟧
{vosdi_imprint}::
An optional embedded parameter in a tabtarget
{vosli_inscription}.
An
{vosdi_imprint}
specifies a target, instance, or configuration variant.
+
Appears after a second dot separator following the
{vosdf_frontispiece}.
+
Examples: `nsproto` in `rbw-B.ConnectBottle.nsproto.sh`.

[[vosdm_formulary]]
// ⟦axl_voices axo_entity⟧
{vosdm_formulary}::
A component that routes
{vosdc_colophon_s}
to implementations.
Each
{vosdm_formulary}
registers handlers for a set of
{vosdc_colophon_s}
and dispatches to the appropriate function.
+
Types:
+
* **Workbench** (`{prefix}w_workbench.sh`): Routes commands for a kit
* **Testbench** (`{prefix}t_testbench.sh`): Routes tests for a kit

[[vosdl_launcher]]
// ⟦axl_voices axo_entity⟧
{vosdl_launcher}::
A bootstrap script in the `tt/` directory that validates arguments and delegates to a
{vosdm_formulary}.
A
{vosdl_launcher}
is the entry point for tabtarget invocation.
+
Naming follows
{vosldt_tabtarget}
vesture: `{colophon}.{frontispiece}[.{imprint}].sh`
+
Responsibilities:
+
* Parse
{vosdc_colophon}
from own filename
* Validate required arguments
* Source the target
{vosdm_formulary}
* Invoke the dispatched function

== Types

[[vost_sigil]]
// ⟦axl_voices axt_string⟧
{vost_sigil}::
A version identifier in YYMMDD-HHMM format.
Generated at
{vosor_release}
time.
Appears in
{vose_parcel}
filenames and manifests.
+
Example: `260115-1430` for January 15, 2026 at 14:30.

== Entities

[[vose_parcel]]
// ⟦axl_voices axo_entity⟧
{vose_parcel}::
The distribution archive for
{vose_kit_s}.
Named `vvk-parcel-{sigil}.tar.gz`.
Contains platform binaries and plain-text
{vose_kit}
assets.
+
Structure:
+
----
vvk-parcel-260115-1430/
  vvi_install.sh          # Install script (BCG-style, not installed)
  kits/
    buk/
      buc_command.sh
      ...
    jjk/
      jju_utility.sh
      commands/
        jjc-heat-mount.md
      ...
    vvk/
      bin/
        vvx-darwin-arm64
        vvx-darwin-x86_64
        vvx-linux-x86_64
      vvu_uninstall.sh
----
+
The `kits/` directory mirrors the target `Tools/` structure.
VVK is a
{vose_kit}
like any other — it just happens to contain binaries.
The
{vose_parcel}
layout matches the installed layout: `kits/*` becomes `Tools/*`.
+
**Scripts:**
+
* `vvi_install.sh` — Bootstrap script at archive root. Reads target's BURC to locate `BURC_TOOLS_DIR`. Not installed to target.
* `vvu_uninstall.sh` — Lives in `kits/vvk/`, installs to `${BURC_TOOLS_DIR}/vvk/`.

[[vose_whisper]]
// ⟦axl_voices axo_entity⟧
{vose_whisper}::
A
{vose_kit_p}
declaration to the
{vose_conclave}.
Implemented as a Rust builder API in the
{vose_kit_p}
{vosp_veiled}
directory.
+
Builder API:
+
[source,rust]
----
use voci_ciphers::JJ;

Whisper::for_kit("jjk")
    .cipher(JJ)                 // symbolic reference to const
    .display_name("Job Jockey")
    .managed_section("vojjmc_core.md", "JJK")
    .managed_section("vojjmc_gallops.md", "JJK_GALLOPS")
    .concept_model("JJD-GallopsData.adoc")
    .register(&mut conclave)
----
+
File location: `Tools/{kit}/vov_veiled/vo{cipher}w_whisper.rs`

[[vose_conclave]]
// ⟦axl_voices axo_entity⟧
{vose_conclave}::
The central API that
{vose_kit_s}
use to describe themselves.
Lives in VOK as `vocv_conclave.rs`.
Collects
{vose_whisper_s}
and validates
{vosk_prefix_validation}
during
{vosor_release}.
+
Responsibilities:
+
* Collect
{vose_whisper_s}
from all participating
{vose_kit_s}
* Enforce
{vosk_prefix_validation}
during
{vosor_release}
* Provide asset enumeration for
{vosoi_install}
and
{vosou_uninstall}

[[vose_kit]]
// ⟦axl_voices axo_entity⟧
{vose_kit}::
A distributable Claude Code extension.
Lives in `Tools/{kit}/` in the
{vosp_kit_forge}.
+
Structure:
+
----
Tools/{kit}/
  {kit}a_arcanum.sh      # Public - install script
  {kit}u_utility.sh      # Public - utilities
  README.md              # Public - documentation
  commands/              # Public - slash commands
    {cipher}c-*.md
  vov_veiled/            # Private - never distributed
    vo{cipher}w_whisper.rs
    vo{cipher}mc_*.md    # CLAUDE.md templates
    {ACRONYM}-*.adoc     # Concept models
----
+
**VVK Special Status:**
VVK (Voce Viva Kit) is a
{vose_kit}
with unique characteristics:
+
* Has a
{vose_whisper}
like other kits (for CLAUDE.md knowledge)
* Contents are primarily binaries (`vvx-{platform}`) and the uninstall script
* Installed like any other kit — `kits/vvk/` in
{vose_parcel}
becomes `Tools/vvk/` in target
* Present in every
{vosp_target_repo}
— the universal kit
* Uses cipher `vv` (Voce Viva)

[[vose_managed_section]]
// ⟦axl_voices axo_entity⟧
{vose_managed_section}::
A block of content in the target CLAUDE.md file bounded by
{vose_marker_s}.
Each
{vose_kit}
may contribute multiple
{vose_managed_section_s}
for distinct feature groups.
+
Members:

[[vosem_file]]
// ⟦axl_voices axr_member axd_required⟧
* {vosem_file} - Template file path relative to
{vosp_veiled}
(e.g., `vojjmc_core.md`)

[[vosem_tag]]
// ⟦axl_voices axr_member axd_required⟧
* {vosem_tag} - Identifier used in
{vose_marker_s}
(e.g., `JJK`, `JJK_GALLOPS`)

[[vose_marker]]
// ⟦axl_voices axt_string⟧
{vose_marker}::
Delimiters bounding a
{vose_managed_section}
in CLAUDE.md.
+
Format: `<\!-- MANAGED:{tag}:BEGIN -->` and `<\!-- MANAGED:{tag}:END -->`
+
Content between
{vose_marker_s}
is replaced entirely on
{vosoi_install}.
Content outside
{vose_marker_s}
is preserved.

== Places

[[vosp_kit_forge]]
// ⟦axl_voices axo_entity⟧
{vosp_kit_forge}::
The source repository where
{vose_kit_s}
are developed.
Contains full source including
{vosp_veiled}
content.
{vosor_release}
runs from the
{vosp_kit_forge}.

[[vosp_target_repo]]
// ⟦axl_voices axo_entity⟧
{vosp_target_repo}::
A consumer repository where
{vose_kit_s}
are installed.
Receives only distributed assets - no
{vosp_veiled}
content.
{vosoi_install}
deploys to the
{vosp_target_repo}.

[[vosp_veiled]]
// ⟦axl_voices axo_entity⟧
{vosp_veiled}::
Content that never leaves the
{vosp_kit_forge}.
Each
{vose_kit}
has a `vov_veiled/` subdirectory containing:
+
* {vose_whisper}
Rust source (`vo{cipher}w_whisper.rs`)
* {vose_managed_section}
templates (`vo{cipher}mc_*.md`)
* {vosa_concept_model_s}
(AsciiDoc specs)
+
Excluded from
{vose_parcel}
by structural convention:
during
{vosor_release}
asset collection, any path containing `vov_veiled/` is skipped.
VOK itself is inherently
{vosp_veiled}
(entire `Tools/vok/` stays in
{vosp_kit_forge}).

== Assets

Assets are artifacts that participate in
{vosoi_install}
and
{vosou_uninstall}.
All assets must comply with
{vosk_prefix_validation}.

[[vosa_command]]
// ⟦axl_voices axo_entity⟧
{vosa_command}::
A slash command file.
Located in `{kit}/commands/` in source, installed to `.claude/commands/` in target.
+
Naming: `{cipher}c-{name}.md`
+
Example: `jjc-heat-mount.md` for JJK.

[[vosa_hook]]
// ⟦axl_voices axo_entity⟧
{vosa_hook}::
A hook definition.
+
Naming: `{cipher}h_{name}.*`
+
[Reserved for future implementation]

[[vosa_skill]]
// ⟦axl_voices axo_entity⟧
{vosa_skill}::
A skill declaration.
+
Naming:
{vosls_signet}
must derive from
{vose_kit_p}
{voslc_cipher}.
+
[Reserved for future implementation]

[[vosa_subagent]]
// ⟦axl_voices axo_entity⟧
{vosa_subagent}::
A subagent declaration.
+
Naming:
{vosls_signet}
must derive from
{vose_kit_p}
{voslc_cipher}.
+
[Reserved for future implementation]

[[vosa_concept_model]]
// ⟦axl_voices axo_entity⟧
{vosa_concept_model}::
An AsciiDoc specification file following MCM patterns.
Lives in
{vosp_veiled},
never distributed.
Indexed by
{vose_conclave}
for acronym registry and uniqueness validation.
+
Naming: Keeps existing acronym (e.g., `JJD-GallopsData.adoc`).
Registered in
{vose_whisper}
via `.concept_model()` builder method.

== Operations

[[vosor_release]]
// ⟦axl_voices axo_command axe_bash_scripted axd_transient⟧
=== {vosor_release}

Creates a
{vose_parcel}
from the
{vosp_kit_forge}.

{voss_inputs}

// ⟦axd_none⟧
No external inputs. Operates on current
{vosp_kit_forge}
state.

{voss_behavior}

. *Collect kit declarations*:
.. {vosc_call}
{vose_conclave}
to enumerate all
{vose_whisper_s}
.. {vosc_store}
kit list for processing

. *Validate prefix compliance*:
.. For each
{vose_kit}:
{vosc_require}
all asset
{vosls_signet_s}
derive from
{voslc_cipher}
.. {vosc_fatal}
if any violations: list non-compliant
{vosli_inscription_s}

. *Run testbenches*:
.. {vosc_call}
each kit's testbench
.. {vosc_fatal}
if any tests fail

. *Build binaries*:
.. {vosc_call}
cargo build for each target platform
.. {vosc_store}
binary paths

. *Collect assets*:
.. For each
{vose_kit}:
collect files excluding
{vosp_veiled}

. *Generate sigil*:
.. {vosc_store}
{vost_sigil}
as current timestamp (YYMMDD-HHMM)

. *Package parcel*:
.. Create `vvk-parcel-{sigil}.tar.gz` with structure:
... `vvi_install.sh` — install script (bootstrap, not installed)
... `kits/` — all kit assets by directory (including VVK with binaries)

{voss_outputs}

* {vose_parcel}
archive: `vvk-parcel-{sigil}.tar.gz`

{voss_completion}

{vose_parcel}
created with all validated
{vose_kit}
assets and platform binaries.


[[vosoi_install]]
// ⟦axl_voices axo_command axe_bash_scripted axd_transient⟧
=== {vosoi_install}

Deploys a
{vose_parcel}
to a
{vosp_target_repo}.
Invokes
{vosok_kit}
for each kit in the parcel.

Invocation (from extracted parcel):

----
./vvi_install.sh /path/to/target-repo
----

{voss_inputs}

// ⟦axd_required⟧
* Target repository path (positional argument)

{voss_behavior}

. *Verify prerequisites*:
.. {vosc_require}
target path is a git repository
.. {vosc_require}
`.buk/burc.env` exists in target
.. {vosc_fatal}
if missing: "BURC not configured"
.. {vosc_call}
source BURC
.. {vosc_store}
`BURC_TOOLS_DIR` from BURC

. *Pre-install commit*:
.. If working tree dirty:
{vosc_call}
`git add -A && git commit -m "Pre-install snapshot"`
.. {vosc_step}
"Pre-install snapshot created"

. *Install each kit*:
.. For each kit directory in `kits/`:
... Invoke
{vosok_kit}
with kit source and target paths
.. VVK is installed like any other kit (binaries land at `${BURC_TOOLS_DIR}/vvk/bin/`)

. *Write manifest*:
.. {vosc_store}
installed kit list, sigil, timestamp
.. {vosc_call}
write `.claude/vvx-manifest.json`

. *Post-install commit*:
.. {vosc_call}
`git add -A && git commit -m "VVK install: {sigil}"`
.. {vosc_step}
"Post-install commit created"

. *Diff analysis*:
.. {vosc_call}
compare pre-install to post-install
.. {vosc_show}
user modifications that may need recovery

{voss_outputs}

* Kit assets under `${BURC_TOOLS_DIR}/` (including VVK binaries at `vvk/bin/`)
* Manifest at `.claude/vvx-manifest.json`
* Two git commits (pre-install, post-install)

{voss_completion}

All
{vose_kit_s}
installed.
CLAUDE.md sections updated.
Manifest written.
User notified of any modifications requiring recovery.


[[vosok_kit]]
// ⟦axl_voices axo_routine axe_bash_scripted axd_transient⟧
=== {vosok_kit}

Installs a single
{vose_kit}
to the
{vosp_target_repo}.
Called by
{vosoi_install}
for each kit in the
{vose_parcel}.

{voss_inputs}

// ⟦axd_required⟧
* Kit source directory (within extracted parcel)

// ⟦axd_required⟧
* Target tools directory (`BURC_TOOLS_DIR`)

// ⟦axd_required⟧
* Target CLAUDE.md path

{voss_behavior}

. *Copy kit assets*:
.. {vosc_call}
copy kit directory to `${BURC_TOOLS_DIR}/{kit}/`
.. Preserve directory structure
.. {vosc_step}
"{kit} assets copied"

. *Install commands*:
.. For each file matching `{cipher}c-*.md` in `commands/`:
... {vosc_call}
copy to `.claude/commands/`
.. {vosc_step}
"{n} commands installed"

. *Install hooks*:
.. For each file matching `{cipher}h_*` in `hooks/`:
... {vosc_call}
copy to `.claude/hooks/`
.. {vosc_step}
"{n} hooks installed"

. *Update managed sections*:
.. For each
{vose_managed_section}
declared in kit's manifest:
... {vosc_require}
{vose_marker_s}
exist in CLAUDE.md
... {vosc_fatal}
if markers missing: "Missing markers for {tag}"
... {vosc_call}
replace content between markers with template content
.. {vosc_step}
"CLAUDE.md sections updated"

{voss_outputs}

* Kit directory at `${BURC_TOOLS_DIR}/{kit}/`
* Commands in `.claude/commands/`
* Hooks in `.claude/hooks/`
* Updated sections in CLAUDE.md

{voss_completion}

Single
{vose_kit}
fully installed with all assets and CLAUDE.md sections.


[[vosou_uninstall]]
// ⟦axl_voices axo_command axe_bash_scripted axd_transient⟧
=== {vosou_uninstall}

Removes a
{vose_kit}
from
{vosp_target_repo}.
Script lives in target after
{vosoi_install}.

Invocation (from target repo):

----
./Tools/vvk/vvu_uninstall.sh
----

{voss_inputs}

// ⟦axd_none⟧
No external inputs. Operates on current repository state.

{voss_behavior}

. *Load configuration*:
.. {vosc_call}
source `.buk/burc.env`
.. {vosc_store}
`BURC_TOOLS_DIR`

. *Read manifest*:
.. {vosc_call}
parse `.claude/vvx-manifest.json`
.. {vosc_store}
list of installed kits and their
{vost_cipher_s}

. *Remove commands*:
.. For each
{vost_cipher}:
... {vosc_call}
remove files matching `{cipher}c-*` from `.claude/commands/`

. *Remove hooks*:
.. For each
{vost_cipher}:
... {vosc_call}
remove files matching `{cipher}h_*` from `.claude/hooks/`

. *Remove managed sections*:
.. For each
{vose_managed_section}
in manifest:
... {vosc_call}
delete content between
{vose_marker_s}
(preserve markers)

. *Remove kit directories*:
.. For each kit in manifest:
... {vosc_call}
remove `${BURC_TOOLS_DIR}/{kit}/`

. *Update manifest*:
.. {vosc_call}
remove uninstalled kits from manifest
.. If no kits remain:
{vosc_call}
delete manifest file

. *Commit changes*:
.. {vosc_call}
`git add -A && git commit -m "VVK uninstall"`

{voss_outputs}

* Removed kit directories
* Removed commands and hooks
* Cleared managed sections (markers preserved)
* Updated or removed manifest

{voss_completion}

{vose_kit}
cleanly removed.
No orphaned assets remain.


== Whisper Builder API

The
{vose_whisper}
builder provides a fluent interface for
{vose_kit}
registration.

=== Required Methods

`Whisper::for_kit(id: &str)` — Create whisper for kit with given
{vosem_kit_id}.

`.cipher(c: Cipher)` — Set the
{vost_cipher}
(symbolic const from `voci_ciphers`).

`.display_name(name: &str)` — Set human-readable name.

`.register(&mut Conclave)` — Finalize and register with
{vose_conclave}.

=== Optional Methods

`.managed_section(file: &str, tag: &str)` — Add a
{vose_managed_section}.
May be called multiple times.

`.concept_model(path: &str)` — Register a
{vosa_concept_model}
for acronym indexing.
May be called multiple times.

=== Validation

Each builder method validates its input immediately.
Final validation occurs at `.register()`:

* {vosem_kit_id}
must be valid identifier
* {vost_cipher}
must be a valid const from `voci_ciphers`
* All
{vose_managed_section}
files must exist
* All
{vosa_concept_model}
files must exist

== Cipher Registry

{voslc_cipher_s}
are declared as const values in `Tools/voi/src/voic_registry.rs`.
The VOI crate (Vox Obscura Infrastructure) is the single source of truth for all project prefixes across the entire VO/VV ecosystem.
Each const
{voslc_cipher}
seeds the namespace for derived
{vosls_signet_s}.

=== Crate Structure

----
Tools/voi/
  Cargo.toml
  src/
    lib.rs           # Re-exports voic_registry
    voic_registry.rs # Cipher type and all cipher constants
----

=== Declaration Pattern

[source,rust]
----
// Tools/voi/src/voic_registry.rs

/// Cipher represents a project's namespace root.
/// Uniqueness enforced at compile time by const declaration.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct voic_Cipher {
    prefix: &'static str,
    project: &'static str,
}

impl voic_Cipher {
    pub const fn new(prefix: &'static str, project: &'static str) -> Self {
        Self { prefix, project }
    }

    pub const fn prefix(&self) -> &'static str { self.prefix }
    pub const fn project(&self) -> &'static str { self.project }
    pub fn matches_prefix(&self, s: &str) -> bool { s.starts_with(self.prefix) }
}

// Project cipher declarations by domain
pub const VV: voic_Cipher = voic_Cipher::new("vv", "Voce Viva");
pub const VO: voic_Cipher = voic_Cipher::new("vo", "Vox Obscura");
pub const JJ: voic_Cipher = voic_Cipher::new("jj", "Job Jockey");
pub const BU: voic_Cipher = voic_Cipher::new("bu", "Bash Utilities");
pub const CM: voic_Cipher = voic_Cipher::new("cm", "Concept Model");
pub const RB: voic_Cipher = voic_Cipher::new("rb", "Recipe Bottle");
pub const GAD: voic_Cipher = voic_Cipher::new("gad", "Google AsciiDoc Differ");
// ... all projects (17 total)

pub const ALL_CIPHERS: &[voic_Cipher] = &[VV, VO, JJ, BU, CM, ...];
----

=== Complete Cipher List

[cols="1,3,3", options="header"]
|===
| Cipher | Project | Domain

| `vv` | Voce Viva | Universal kit (in every target repo)
| `vo` | Vox Obscura | Kit forge infrastructure
| `jj` | Job Jockey | Project management
| `bu` | Bash Utilities | Enterprise bash infrastructure
| `cm` | Concept Model | MCM/AXLA tooling
| `hm` | Hard-state Machine | State machine infrastructure
| `rb` | Recipe Bottle | Container orchestration
| `crg` | Config Regime | Configuration management
| `gad` | Google AsciiDoc Differ | Diff visualization
| `ccc` | Claude Code Container | Docker operations
| `lmci` | Language Model Console Integration | LLM CI utilities
| `vsl` | Visual SlickEdit Local | IDE integration
| `mcm` | Meta Concept Model | Concept model specification
| `axl` | Axiom Lexicon | Shared vocabulary
| `pb` | Paneboard | Cross-platform UI toolkit
| `wrs` | Ward Realm Substrate | Distributed state machines
| `srf` | Study Raft | Learning and exploration
|===

=== Uniqueness Guarantees

* Compile-time: duplicate const names are compilation errors
* Runtime: `voic_validate_terminal_exclusivity()` verifies no prefix is a prefix of another
* Convention: new ciphers require coordinated addition to `voic_registry.rs`

=== Utility Functions

[source,rust]
----
// Find cipher by prefix
pub fn voic_find_by_prefix(prefix: &str) -> Option<&'static voic_Cipher>;

// Check if prefix is registered
pub fn voic_is_registered(prefix: &str) -> bool;

// Validate terminal exclusivity (returns conflicting pair if violated)
pub fn voic_validate_terminal_exclusivity() -> Option<(&'static voic_Cipher, &'static voic_Cipher)>;
----

=== Usage

{vose_kit_s}
import their
{voslc_cipher}
via the `voi` crate:

[source,rust]
----
use voi::{JJ, voic_Cipher};

Whisper::for_kit("jjk")
    .cipher(JJ)
    // ...
----
