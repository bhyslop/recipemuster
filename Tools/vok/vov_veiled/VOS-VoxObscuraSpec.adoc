= Vox Obscura Specification
:doctype: book

// tag::mapping-section[]
//
// Category declarations:
// vost_:  Types (scalar identifiers with validation rules)
// vose_:  Entities (objects with structure and behavior)
// vosem_: Entity members (fields within entities)
// vosp_:  Places (repository and location concepts)
// vosa_:  Assets (distributable or indexed artifacts)
// voso:   Operations (non-terminal, has children: vosoi_, vosok_, vosou_, vosor_)
// vosr_:  Routines (internal reusable procedures)
// vosk_:  Key premises (design constraints)
// vosc_:  Control terms (voices axc_* in bash scripted context)
// voss_:  Section headers (voices axs_*)
//
// vosl:   Liturgy (non-terminal, naming system umbrella)
// voslc_: Liturgy Cipher (project root prefix)
// vosls_: Liturgy Signet (complete prefix before separator)
// vosle_: Liturgy Epithet (descriptive word after separator)
// vosli_: Liturgy Inscription (full artifact name)
// voslv_: Liturgy Vesture (domain construction rules)
// vosln_: Liturgy Ensign (signet extension that classifies category)
// voslm_: Liturgy Monogram (signet extension that binds to epithet initial)
// vosld:  Liturgy Domain (non-terminal, domain-specific vestures)
// vosldr_: Liturgy Domain Rust (Rust source vesture)
// vosldb_: Liturgy Domain Bash (Bash source vesture)
// voslda_: Liturgy Domain AsciiDoc (AsciiDoc attribute vesture)
// vosldp_: Liturgy Domain Publication (spec/publication vesture)
// vosldg_: Liturgy Domain Git (git ref vesture)
// voslds_: Liturgy Domain Slash (slash command vesture)
// vosldt_: Liturgy Domain Tabtarget (tabtarget vesture)
//
// vosd:   Dispatch (non-terminal, tabtarget system umbrella)
// vosdc_: Dispatch Colophon (routing identifier)
// vosdf_: Dispatch Frontispiece (human-readable description)
// vosdi_: Dispatch Imprint (embedded parameter/target specifier)
// vosdm_: Dispatch Formulary (routing component)
// vosdl_: Dispatch Launcher (bootstrap script)
//
// Variant patterns:
//   _s: plural form
//   _p: possessive form
//

// Liturgy (naming system)
:voslc_cipher:          <<voslc_cipher,Cipher>>
:voslc_cipher_s:        <<voslc_cipher,Ciphers>>
:voslc_cipher_p:        <<voslc_cipher,Cipher's>>
:vosls_signet:          <<vosls_signet,Signet>>
:vosls_signet_s:        <<vosls_signet,Signets>>
:vosle_epithet:         <<vosle_epithet,Epithet>>
:vosle_epithet_s:       <<vosle_epithet,Epithets>>
:vosli_inscription:     <<vosli_inscription,Inscription>>
:vosli_inscription_s:   <<vosli_inscription,Inscriptions>>
:voslv_vesture:         <<voslv_vesture,Vesture>>
:voslv_vesture_s:       <<voslv_vesture,Vestures>>
:vosln_ensign:          <<vosln_ensign,Ensign>>
:vosln_ensign_s:        <<vosln_ensign,Ensigns>>
:voslm_monogram:        <<voslm_monogram,Monogram>>
:voslm_monogram_s:      <<voslm_monogram,Monograms>>

// Liturgy Domains (vesture specializations)
:vosldr_rust:           <<vosldr_rust,Rust Vesture>>
:vosldb_bash:           <<vosldb_bash,Bash Vesture>>
:voslda_asciidoc:       <<voslda_asciidoc,AsciiDoc Vesture>>
:vosldp_publication:    <<vosldp_publication,Publication Vesture>>
:vosldg_git:            <<vosldg_git,Git Vesture>>
:voslds_slash:          <<voslds_slash,Slash Command Vesture>>
:vosldt_tabtarget:      <<vosldt_tabtarget,Tabtarget Vesture>>

// Dispatch (tabtarget system)
:vosdc_colophon:        <<vosdc_colophon,Colophon>>
:vosdc_colophon_s:      <<vosdc_colophon,Colophons>>
:vosdf_frontispiece:    <<vosdf_frontispiece,Frontispiece>>
:vosdf_frontispiece_s:  <<vosdf_frontispiece,Frontispieces>>
:vosdi_imprint:         <<vosdi_imprint,Imprint>>
:vosdi_imprint_s:       <<vosdi_imprint,Imprints>>
:vosdm_formulary:       <<vosdm_formulary,Formulary>>
:vosdm_formulary_s:     <<vosdm_formulary,Formularies>>
:vosdl_launcher:        <<vosdl_launcher,Launcher>>
:vosdl_launcher_s:      <<vosdl_launcher,Launchers>>

// Types (aliases for backward compatibility)
:vost_cipher:           <<voslc_cipher,Cipher>>
:vost_cipher_s:         <<voslc_cipher,Ciphers>>
:vost_cipher_p:         <<voslc_cipher,Cipher's>>
:vost_hallmark:         <<vost_hallmark,Hallmark>>
:vost_hallmark_s:       <<vost_hallmark,Hallmarks>>
:vost_sigil:            <<vost_sigil,Sigil>>
:vost_sigil_s:          <<vost_sigil,Sigils>>

// Entities
:vose_brand_file:       <<vose_brand_file,Brand File>>
:vose_brand_file_s:     <<vose_brand_file,Brand Files>>
:vose_parcel:           <<vose_parcel,Parcel>>
:vose_parcel_s:         <<vose_parcel,Parcels>>
:vose_parcel_p:         <<vose_parcel,Parcel's>>
:vose_registry:         <<vose_registry,Registry>>
:vose_whisper:          <<vose_whisper,Whisper>>
:vose_whisper_s:        <<vose_whisper,Whispers>>
:vose_whisper_p:        <<vose_whisper,Whisper's>>
:vose_conclave:         <<vose_conclave,Conclave>>
:vose_conclave_p:       <<vose_conclave,Conclave's>>
:vose_kit:              <<vose_kit,Kit>>
:vose_kit_s:            <<vose_kit,Kits>>
:vose_kit_p:            <<vose_kit,Kit's>>
:vose_managed_section:  <<vose_managed_section,Managed Section>>
:vose_managed_section_s: <<vose_managed_section,Managed Sections>>
:vose_marker:           <<vose_marker,Marker>>
:vose_marker_s:         <<vose_marker,Markers>>
:vose_uninstalled_marker: <<vose_uninstalled_marker,Uninstalled Marker>>

// Entity members
:vosem_brand_commit:    <<vosem_brand_commit,brand_commit>>
:vosem_brand_date:      <<vosem_brand_date,brand_date>>
:vosem_brand_kits:      <<vosem_brand_kits,brand_kits>>
:vosem_brand_sha:       <<vosem_brand_sha,brand_sha>>
:vosem_display_name:    <<vosem_display_name,display_name>>
:vosem_file:            <<vosem_file,file>>
:vosem_hallmark:        <<vosem_hallmark,hallmark>>
:vosem_kit_id:          <<vosem_kit_id,kit_id>>
:vosem_tag:             <<vosem_tag,tag>>

// Places
:vosp_kit_forge:        <<vosp_kit_forge,Kit Forge>>
:vosp_target_repo:      <<vosp_target_repo,Target Repo>>
:vosp_veiled:           <<vosp_veiled,Veiled>>

// Assets
:vosa_command:          <<vosa_command,Command>>
:vosa_command_s:        <<vosa_command,Commands>>
:vosa_hook:             <<vosa_hook,Hook>>
:vosa_hook_s:           <<vosa_hook,Hooks>>
:vosa_skill:            <<vosa_skill,Skill>>
:vosa_skill_s:          <<vosa_skill,Skills>>
:vosa_subagent:         <<vosa_subagent,Subagent>>
:vosa_subagent_s:       <<vosa_subagent,Subagents>>
:vosa_concept_model:    <<vosa_concept_model,Concept Model>>
:vosa_concept_model_s:  <<vosa_concept_model,Concept Models>>

// Operations (voso has children)
:vosor_release:         <<vosor_release,Release>>
:vosoi_install:         <<vosoi_install,Install>>
:vosou_uninstall:       <<vosou_uninstall,Uninstall>>

// Routines (internal reusable procedures)
:vosr_lock:             <<vosr_lock,lock routine>>
:vosr_commit:           <<vosr_commit,commit routine>>
:vosr_guard:            <<vosr_guard,guard routine>>
:vosr_probe:            <<vosr_probe,probe routine>>

// Control terms (voice axc_* in bash scripted context)
:vosc_require:          <<vosc_require,REQUIRE>>
:vosc_fatal:            <<vosc_fatal,FATAL>>
:vosc_store:            <<vosc_store,STORE>>
:vosc_call:             <<vosc_call,CALL>>
:vosc_show:             <<vosc_show,SHOW>>
:vosc_step:             <<vosc_step,STEP>>

// Commit architecture terms
:vosca_vvb:             <<vosca_vvb,vvb>>
:voscf_format:          <<voscf_format,Commit Format>>
:voscaa_allocate:       <<voscaa_allocate,Allocate>>
:voscai_invitatory:     <<voscai_invitatory,Invitatory>>
:voscar_release:        <<voscar_release,Release>>
:vost_officium:         <<vost_officium,Officium>>

// Section headers (voice axs_*)
:voss_inputs:           <<voss_inputs,Inputs:>>
:voss_behavior:         <<voss_behavior,Behavior:>>
:voss_outputs:          <<voss_outputs,Outputs:>>
:voss_completion:       <<voss_completion,Completion:>>

// Key premises
:vosk_prefix_validation: <<vosk_prefix_validation,Prefix Validation>>
:vosk_all_or_none:       <<vosk_all_or_none,All Or None>>
:vosk_parcel_self_contained: <<vosk_parcel_self_contained,Parcel Self-Contained>>
:vosk_burc_prerequisite: <<vosk_burc_prerequisite,BURC Prerequisite>>
:vosk_default_routing:   <<vosk_default_routing,Default Routing>>

// end::mapping-section[]

== Overview

The Vox Obscura Specification defines the release and installation infrastructure for Claude Code
{vose_kit_s}.
{vose_kit_s}
are developed in a
{vosp_kit_forge}
and distributed via
{vose_parcel_s}
to
{vosp_target_repo}
consumers.

Each
{vose_kit}
declares itself to the
{vose_conclave}
through a
{vose_whisper}
- a builder-pattern API that registers the
{vose_kit_p}
identity,
{vose_managed_section_s},
and
{vosa_concept_model_s}.

The
{vosor_release}
operation creates a
{vose_parcel}
containing all
{vose_kit}
assets.
The
{vosoi_install}
operation deploys a
{vose_parcel}
to a
{vosp_target_repo}.
The
{vosou_uninstall}
operation removes Claude Code integration (commands, hooks, CLAUDE.md sections, vvx binary) while preserving
{vose_kit}
directories.
Uses
{vosls_signet}
-based prefix matching for command/hook removal.

**Related Specifications:**

* **VLS-VoxLiturgicalSpec.adoc** — Universal naming vocabulary (Cipher, Signet, Epithet, Inscription, Vesture)
* **BUS-BashUtilitiesSpec.adoc** — Tabtarget dispatch vocabulary (Colophon, Frontispiece, Imprint, Formulary, Launcher)

== Key Premises

[[vosk_prefix_validation]]
// ⟦axl_voices axk_premise⟧
{vosk_prefix_validation}::
All
{vosa_command_s},
{vosa_hook_s},
{vosa_skill_s},
and
{vosa_subagent_s}
must have
{vosls_signet_s}
derived from their
{vose_kit_p}
{voslc_cipher}.
{vosor_release}
fails if any asset's
{vosli_inscription}
violates the
{voslc_cipher}
derivation rules.
This constraint enables deterministic
{vosou_uninstall}
by
{vosls_signet}
matching.
+
Validation applies to artifact *file names* only.
Internal content (function names, variable names within scripts) is not validated during
{vosor_release}.

[[vosk_all_or_none]]
// ⟦axl_voices axk_premise⟧
{vosk_all_or_none}::
{vosoi_install}
is atomic.
A
{vose_parcel}
represents a tested, coherent release.
No selective installation of individual
{vose_kit_s}
or assets.

[[vosk_parcel_self_contained]]
// ⟦axl_voices axk_premise⟧
{vosk_parcel_self_contained}::
A
{vose_parcel}
contains everything needed for installation.
No dependency resolution or external fetches during
{vosoi_install}.
The
{vose_parcel}
can function from its extracted directory.

[[vosk_burc_prerequisite]]
// ⟦axl_voices axk_premise⟧
{vosk_burc_prerequisite}::
{vosoi_install}
requires BURC (BUK Regime Configuration) in the
{vosp_target_repo}.
The install script reads `.buk/burc.env` for required variables:
`BURC_PROJECT_ROOT` (path from burc.env's location to project root),
`BURC_TOOLS_DIR` (relative to project root), and
`BURC_MANAGED_KITS` (comma-separated list of kits included in vvx).
Install fails immediately if any required variable is missing — no bootstrap, no prompts.

[[vosk_default_routing]]
// ⟦axl_voices axk_premise⟧
{vosk_default_routing}::
Assets without special routing rules copy in place, preserving directory structure relative to
{vose_kit}
root.
Only
{vosa_command_s}
and
{vosa_hook_s}
have special routing (to `.claude/commands/` and `.claude/hooks/` respectively).
All other files install to `${BURC_TOOLS_DIR}/{kit}/` maintaining their source-relative paths.

== Control Terms

VOS control terms voice `axc_*` motifs for bash scripted execution context.
These terms appear inline within procedure steps to classify actions.

[[vosc_require]]
// ⟦axl_voices axc_require⟧
{vosc_require}::
Validation check that confirms an expected condition.
Script exits with error if condition not met.

[[vosc_fatal]]
// ⟦axl_voices axc_fatal⟧
{vosc_fatal}::
Immediate termination with error status.
Displays error message and exits non-zero.

[[vosc_store]]
// ⟦axl_voices axc_store⟧
{vosc_store}::
Capture a value into a shell variable for later use.

[[vosc_call]]
// ⟦axl_voices axc_call⟧
{vosc_call}::
Invoke an external command or function.
Captures exit status for processing.

[[vosc_show]]
// ⟦axl_voices axc_show⟧
{vosc_show}::
Display information to stdout.
Progress messages or results.

[[vosc_step]]
// ⟦axl_voices axc_step⟧
{vosc_step}::
Progress message indicating completion of a processing stage.

== Section Headers

VOS section headers voice `axs_*` motifs for procedure documentation structure.

[[voss_inputs]]
// ⟦axl_voices axs_inputs⟧
{voss_inputs}::
Section header for operation input parameters.

[[voss_behavior]]
// ⟦axl_voices axs_behavior⟧
{voss_behavior}::
Section header for operation behavior steps.

[[voss_outputs]]
// ⟦axl_voices axs_outputs⟧
{voss_outputs}::
Section header for operation outputs and artifacts.

[[voss_completion]]
// ⟦axl_voices axs_completion⟧
{voss_completion}::
Section header for operation completion criteria.

== Types

[[vost_hallmark]]
// ⟦axl_voices axt_string⟧
{vost_hallmark}::
A 4-digit version identifier starting at 1000.
{vost_hallmark_s}
increment for each unique content set during
{vosor_release}.
Unlike
{vost_sigil}
(timestamp-based),
{vost_hallmark}
represents content identity — same content always produces same
{vost_hallmark}.
+
Examples: `1000`, `1001`, `1042`.

[[vost_sigil]]
// ⟦axl_voices axt_string⟧
{vost_sigil}::
A version identifier in YYMMDD-HHMM format.
Generated at
{vosor_release}
time.
Appears in
{vose_parcel}
filenames and manifests.
+
Example: `260115-1430` for January 15, 2026 at 14:30.

[[vost_officium]]
// ⟦axl_voices axt_string⟧
{vost_officium}::
A bounded work period opened by the
{voscai_invitatory}
commit.
Replaces the concept of "session" with liturgical terminology.
The term derives from the Latin for the Divine Office, emphasizing the structured, intentional nature of the work period.
+
An
{vost_officium}
is considered current if the most recent
{voscai_invitatory}
commit was created within the gap threshold (1 hour by default).

== Entities

[[vose_parcel]]
// ⟦axl_voices axo_entity⟧
{vose_parcel}::
The distribution archive for
{vose_kit_s}.
Named `vvk-parcel-{hallmark}.tar.gz`.
Contains platform binaries and plain-text
{vose_kit}
assets.
+
Structure:
+
----
vvk-parcel-1000/
  vvi_install.sh          # Install script (BCG-style, not installed)
  vvbf_brand.json         # Brand file (runtime identity)
  kits/
    buk/
      buc_command.sh
      ...
    jjk/
      jju_utility.sh
      ...
    vvk/
      bin/
        vvx-darwin-arm64
        vvx-darwin-x86_64
        vvx-linux-x86_64
      vvu_uninstall.sh
  claude/
    commands/
      jjc-heat-mount.md
      cma-normalize.md
      vvc-commit.md
    hooks/                # Future
----
+
The `kits/` directory mirrors the target `Tools/` structure: `kits/*` becomes `Tools/*`.
The `claude/` directory contains Claude Code configuration assets collected from kit forges and routed to `.claude/*` in the target.
VVK is a
{vose_kit}
like any other — it just happens to contain binaries.
+
**Scripts:**
+
* `vvi_install.sh` — Bootstrap script at archive root. Takes `burc.env` path as argument; Rust validates file and parses needed variables (`BURC_TOOLS_DIR`, `BURC_PROJECT_ROOT`). Not installed to target.
* `vvu_uninstall.sh` — Lives in `kits/vvk/`, installs to `${BURC_TOOLS_DIR}/vvk/`.

[[vose_whisper]]
// ⟦axl_voices axo_entity⟧
{vose_whisper}::
A
{vose_kit_p}
declaration to the
{vose_conclave}.
Implemented as a Rust builder API in the
{vose_kit_p}
{vosp_veiled}
directory.
+
Builder API:
+
[source,rust]
----
use voci_ciphers::JJ;

Whisper::for_kit("jjk")
    .cipher(JJ)                 // symbolic reference to const
    .display_name("Job Jockey")
    .managed_section("vocjjmc_core.md", "JJK")
    .managed_section("vocjjmc_gallops.md", "JJK_GALLOPS")
    .concept_model("JJSA-GallopsData.adoc")
    .register(&mut conclave)
----
+
File location: `Tools/{kit}/vov_veiled/vo{cipher}w_whisper.rs`

[[vose_conclave]]
// ⟦axl_voices axo_entity⟧
{vose_conclave}::
The central API that
{vose_kit_s}
use to describe themselves.
Lives in VOK as `vocv_conclave.rs`.
Collects
{vose_whisper_s}
and validates
{vosk_prefix_validation}
during
{vosor_release}.
+
Responsibilities:
+
* Collect
{vose_whisper_s}
from all participating
{vose_kit_s}
* Enforce
{vosk_prefix_validation}
during
{vosor_release}
* Provide asset enumeration for
{vosoi_install}
and
{vosou_uninstall}

[[vose_kit]]
// ⟦axl_voices axo_entity⟧
{vose_kit}::
A distributable Claude Code extension.
Lives in `Tools/{kit}/` in the
{vosp_kit_forge}.
+
Structure:
+
----
Tools/{kit}/
  {kit}a_arcanum.sh      # Public - install script
  {kit}u_utility.sh      # Public - utilities
  README.md              # Public - documentation
  commands/              # Public - slash commands
    {cipher}c-*.md
  vov_veiled/            # Private - never distributed
    vo{cipher}w_whisper.rs
    vo{cipher}mc_*.md    # CLAUDE.md templates
    {ACRONYM}-*.adoc     # Concept models
----
+
**VVK Special Status:**
VVK (Voce Viva Kit) is a
{vose_kit}
with unique characteristics:
+
* Has a
{vose_whisper}
like other kits (for CLAUDE.md knowledge)
* Contents are primarily binaries (`vvx-{platform}`) and the uninstall script
* Installed like any other kit — `kits/vvk/` in
{vose_parcel}
becomes `Tools/vvk/` in target
* Present in every
{vosp_target_repo}
— the universal kit
* Uses cipher `vv` (Voce Viva)

[[vose_managed_section]]
// ⟦axl_voices axo_entity⟧
{vose_managed_section}::
A block of content in the target CLAUDE.md file bounded by
{vose_marker_s}.
Each
{vose_kit}
may contribute multiple
{vose_managed_section_s}
for distinct feature groups.
+
Members:

[[vosem_file]]
// ⟦axl_voices axr_member axd_required⟧
* {vosem_file} - Template file path relative to
{vosp_veiled}
(e.g., `vocjjmc_core.md`)

[[vosem_tag]]
// ⟦axl_voices axr_member axd_required⟧
* {vosem_tag} - Identifier used in
{vose_marker_s}
(e.g., `JJK`, `JJK_GALLOPS`)

[[vose_marker]]
// ⟦axl_voices axt_string⟧
{vose_marker}::
Delimiters bounding a
{vose_managed_section}
in CLAUDE.md.
+
Format: `<\!-- MANAGED:{tag}:BEGIN -->` and `<\!-- MANAGED:{tag}:END -->`
+
Content between
{vose_marker_s}
is replaced entirely on
{vosoi_install}.
Content outside
{vose_marker_s}
is preserved.

[[vose_uninstalled_marker]]
// ⟦axl_voices axt_string⟧
{vose_uninstalled_marker}::
Placeholder preserving position of a removed
{vose_managed_section}.
+
Format: `<\!-- MANAGED:{tag}:UNINSTALLED -->`
+
On
{vosoi_install},
an
{vose_uninstalled_marker}
is expanded back to
{vose_marker_s}
at the same location.
On
{vosou_uninstall},
{vose_marker_s}
are collapsed to a single
{vose_uninstalled_marker},
preserving user's chosen section ordering for future reinstall.

[[vose_brand_file]]
// ⟦axl_voices axj_structure⟧
{vose_brand_file}::
Runtime identity file at
{vose_parcel}
root.
Contains
{vost_hallmark},
minted timestamp, and content super-SHA.
+
File location: `vvbf_brand.json` at parcel root.
Installed to `.vvk/vvbf_brand.json` in target.
+
Members:

[[vosem_hallmark]]
// ⟦axl_voices axj_field axd_required⟧
* {vosem_hallmark} — {axj_field_tag}: `vvbh_hallmark`.
4-digit version identifier (
{vost_hallmark}
).

[[vosem_brand_date]]
// ⟦axl_voices axj_field axd_required⟧
* {vosem_brand_date} — {axj_field_tag}: `vvbd_date`.
Minted timestamp in YYMMDD-HHMM format.

[[vosem_brand_sha]]
// ⟦axl_voices axj_field axd_required⟧
* {vosem_brand_sha} — {axj_field_tag}: `vvbs_sha`.
Content super-SHA (order-independent hash of all parcel files).

[[vosem_brand_commit]]
// ⟦axl_voices axj_field axd_required⟧
* {vosem_brand_commit} — {axj_field_tag}: `vvbc_commit`.
Git commit SHA of source repo at release time.

[[vosem_brand_kits]]
// ⟦axl_voices axj_field axd_required⟧
* {vosem_brand_kits} — {axj_field_tag}: `vvbk_kits`.
Array of kit identifiers included in this release.
Used by
{vosou_uninstall}
to enumerate installed kits.

[[vose_registry]]
// ⟦axl_voices axj_structure⟧
{vose_registry}::
{vosp_veiled}
mapping of
{vost_hallmark}
to content identity.
Keys are
{vost_hallmark}
values; entries contain
{vosem_brand_date}
and
{vosem_brand_sha}.
+
File location: `Tools/vok/vov_veiled/vovr_registry.json`
+
Used by
{vosor_release}
to allocate
{vost_hallmark_s}
— if super-SHA exists, reuse its
{vost_hallmark};
otherwise allocate next sequential value.

== Places

[[vosp_kit_forge]]
// ⟦axl_voices axo_entity⟧
{vosp_kit_forge}::
The source repository where
{vose_kit_s}
are developed.
Contains full source including
{vosp_veiled}
content.
{vosor_release}
runs from the
{vosp_kit_forge}.

[[vosp_target_repo]]
// ⟦axl_voices axo_entity⟧
{vosp_target_repo}::
A consumer repository where
{vose_kit_s}
are installed.
Receives only distributed assets - no
{vosp_veiled}
content.
{vosoi_install}
deploys to the
{vosp_target_repo}.

[[vosp_veiled]]
// ⟦axl_voices axo_entity⟧
{vosp_veiled}::
Content that never leaves the
{vosp_kit_forge}.
Each
{vose_kit}
has a `vov_veiled/` subdirectory containing:
+
* {vose_whisper}
Rust source (`vo{cipher}w_whisper.rs`)
* {vose_managed_section}
templates (`vo{cipher}mc_*.md`)
* {vosa_concept_model_s}
(AsciiDoc specs)
+
Excluded from
{vose_parcel}
by structural convention:
during
{vosor_release}
asset collection, any path containing `vov_veiled/` is skipped.
VOK itself is inherently
{vosp_veiled}
(entire `Tools/vok/` stays in
{vosp_kit_forge}).

== Assets

Assets are artifacts that participate in
{vosoi_install}
and
{vosou_uninstall}.
All assets must comply with
{vosk_prefix_validation}.

[[vosa_command]]
// ⟦axl_voices axo_entity⟧
{vosa_command}::
A slash command file.
Located in `.claude/commands/` in
{vosp_kit_forge},
collected during
{vosor_release}
by
{voslc_cipher}
pattern, installed to `.claude/commands/` in target.
+
Naming: `{cipher}c-{name}.md`
+
Example: `jjc-heat-mount.md` for JJK.

[[vosa_hook]]
// ⟦axl_voices axo_entity⟧
{vosa_hook}::
A hook definition.
Located in `.claude/hooks/` in
{vosp_kit_forge},
collected during
{vosor_release}
by
{voslc_cipher}
pattern, installed to `.claude/hooks/` in target.
+
Naming: `{cipher}h-{name}.md`
+
[Reserved for future implementation]

[[vosa_skill]]
// ⟦axl_voices axo_entity⟧
{vosa_skill}::
A skill declaration.
+
Naming:
{vosls_signet}
must derive from
{vose_kit_p}
{voslc_cipher}.
+
[Reserved for future implementation]

[[vosa_subagent]]
// ⟦axl_voices axo_entity⟧
{vosa_subagent}::
A subagent declaration.
+
Naming:
{vosls_signet}
must derive from
{vose_kit_p}
{voslc_cipher}.
+
[Reserved for future implementation]

[[vosa_concept_model]]
// ⟦axl_voices axo_entity⟧
{vosa_concept_model}::
An AsciiDoc specification file following MCM patterns.
Lives in
{vosp_veiled},
never distributed.
Indexed by
{vose_conclave}
for acronym registry and uniqueness validation.
+
Naming: Keeps existing acronym (e.g., `JJSA-GallopsData.adoc`).
Registered in
{vose_whisper}
via `.concept_model()` builder method.

== Operations

[[vosor_release]]
// ⟦axl_voices axo_command axe_bash_scripted axd_transient⟧
=== {vosor_release}

Creates a
{vose_parcel}
from the
{vosp_kit_forge}.

{voss_inputs}

// ⟦axd_none⟧
No external inputs. Operates on current
{vosp_kit_forge}
state.

{voss_behavior}

. *Collect kit declarations*:
.. {vosc_call}
read `BURC_MANAGED_KITS` from kit forge's `.buk/burc.env`
.. {vosc_fatal}
if missing or empty: "burc.env missing required variable: BURC_MANAGED_KITS"
.. {vosc_store}
kit list for processing (only kits in BURC_MANAGED_KITS)

. *Validate prefix compliance*:
.. For each
{vose_kit}:
{vosc_require}
all asset
{vosls_signet_s}
derive from
{voslc_cipher}
.. {vosc_fatal}
if any violations: list non-compliant
{vosli_inscription_s}

. *Run testbenches*:
.. {vosc_call}
each kit's testbench
.. {vosc_fatal}
if any tests fail

. *Build binaries*:
.. {vosc_call}
cargo build for each target platform
.. {vosc_store}
binary paths

. *Collect assets*:
.. For each
{vose_kit}:
collect files excluding
{vosp_veiled}
.. For each
{voslc_cipher}
from kit list:
... Scan kit forge `.claude/commands/` for files matching `{cipher}c-*.md`
... Scan kit forge `.claude/hooks/` for files matching `{cipher}h-*.md`
... Copy matching files to parcel `claude/commands/` and `claude/hooks/` respectively
.. {vosc_step}
"Claude config assets collected by cipher pattern"

. *Generate sigil*:
.. {vosc_store}
{vost_sigil}
as current timestamp (YYMMDD-HHMM)

. *Compute brand identity*:
.. {vosc_call}
compute order-independent super-SHA:
... Sort all parcel files by path
... Hash each file's path + content
... Combine hashes
... Exclude
{vose_brand_file}
from computation
.. {vosc_store}
super-SHA for registry lookup

. *Allocate hallmark*:
.. {vosc_call}
read
{vose_registry}
.. If super-SHA exists in registry:
{vosc_store}
existing
{vost_hallmark}
.. If super-SHA is new:
... {vosc_store}
next sequential
{vost_hallmark}
(max + 1, starting at 1000)
... {vosc_call}
update
{vose_registry}
with new entry
... {vosc_call}
commit registry change

. *Write brand file*:
.. {vosc_call}
create
{vose_brand_file}
at parcel root with
{vosem_hallmark},
{vosem_brand_date},
{vosem_brand_sha},
{vosem_brand_commit}
(current git HEAD),
{vosem_brand_kits}
(list of kit identifiers)

. *Package parcel*:
.. Create `vvk-parcel-{hallmark}.tar.gz` with structure:
... `vvi_install.sh` — install script (bootstrap, not installed)
... `vvbf_brand.json` —
{vose_brand_file}
at parcel root
... `kits/` — all kit assets by directory (including VVK with binaries)
... `claude/` — commands and hooks collected by cipher pattern

{voss_outputs}

* {vose_parcel}
archive: `vvk-parcel-{hallmark}.tar.gz`
* {vose_brand_file}
at parcel root

{voss_completion}

{vose_parcel}
created with all validated
{vose_kit}
assets and platform binaries.


[[vosoi_install]]
// ⟦axl_voices axo_command axe_rust_impl axd_transient⟧
=== {vosoi_install}

Deploys a
{vose_parcel}
to a
{vosp_target_repo}.
Nuclear replacement: deletes existing installation before copying fresh.
Handles both first-time install and reinstall identically.

Invocation (from extracted parcel):

----
./vvi_install.sh /path/to/target/.buk/burc.env
----

The bash script is a thin bootstrap: detect platform, exec `vvx_emplace`.
All logic is implemented in Rust for path safety and testability.

{voss_inputs}

// ⟦axd_required⟧
* Path to target repository's `burc.env` file (positional argument)

{voss_behavior}

. *Validate burc.env*:
.. {vosc_require}
burc.env exists and is readable
.. {vosc_call}
parse burc.env as KEY=VALUE pairs
.. {vosc_require}
`BURC_PROJECT_ROOT` is defined and non-empty
.. {vosc_require}
`BURC_TOOLS_DIR` is defined and non-empty
.. {vosc_require}
`BURC_MANAGED_KITS` is defined and non-empty
.. {vosc_fatal}
if missing or empty: "burc.env missing required variable: {name}"
.. {vosc_call}
resolve `BURC_PROJECT_ROOT` as path from burc.env's location to project root
.. {vosc_call}
resolve `BURC_TOOLS_DIR` relative to resolved project_root (per BURC spec)
.. {vosc_store}
absolute paths for tools_dir and project_root, kit list from BURC_MANAGED_KITS

. *Validate git state*:
.. {vosc_require}
project_root is a git repository
.. {vosc_fatal}
if not: "Target is not a git repository"
.. {vosc_require}
working tree is clean (no uncommitted changes)
.. {vosc_fatal}
if dirty: "Target repo has uncommitted changes. Commit or stash before install."

. *Read brand identity*:
.. {vosc_call}
parse
{vose_brand_file}
from parcel root
.. {vosc_store}
{vosem_hallmark}
and
{vosem_brand_kits}

. *Validate kit match*:
.. {vosc_require}
`BURC_MANAGED_KITS` exactly matches
{vosem_brand_kits}
(same kits, order independent)
.. {vosc_fatal}
if mismatch: "Target requests kits [{target_kits}] but parcel contains [{parcel_kits}]"

. *Nuclear cleanup*:
.. If `.vvk/` exists:
{vosc_call}
delete recursively
.. If `.vvk/` absent: no action (first-time install)
.. For each kit in `BURC_MANAGED_KITS`:
... If `${BURC_TOOLS_DIR}/{kit}/` exists:
{vosc_call}
delete recursively
... If absent: no action
.. {vosc_step}
"Previous installation removed" or "Clean target (first-time install)"

. *Create brand directory*:
.. {vosc_call}
create `.vvk/` directory
.. {vosc_call}
copy
{vose_brand_file}
to `.vvk/vvbf_brand.json`

. *Install kits*:
.. For each kit in `BURC_MANAGED_KITS`:
... {vosc_call}
copy `kits/{kit}/` to `${BURC_TOOLS_DIR}/{kit}/`
.. {vosc_step}
"{n} kits installed"

. *Install Claude config assets*:
.. {vosc_call}
copy `claude/commands/*` to `.claude/commands/`
.. {vosc_call}
copy `claude/hooks/*` to `.claude/hooks/`
.. {vosc_step}
"{m} commands installed, {p} hooks installed"

. *Freshen CLAUDE.md*:
.. If CLAUDE.md absent:
{vosc_call}
create with header `# Claude Code Project Memory`
.. {vosc_call}
read templates from `kits/{kit}/templates/`
.. For each
{vose_managed_section}:
... If
{vose_marker_s}
exist: replace content between markers
... Else if
{vose_uninstalled_marker}
exists: expand at that location
... Else: append at end of file
.. {vosc_step}
"CLAUDE.md sections updated"
+
NOTE: This is a deterministic text transformation implemented in Rust.
No LLM assistance required for marker manipulation.

. *Commit installation*:
.. {vosc_call}
`git add -A`
.. {vosc_call}
`git commit -m "VVK install: hallmark {hallmark}"`
.. {vosc_step}
"Installation committed"

{voss_outputs}

* Kit assets under `${BURC_TOOLS_DIR}/`
* Commands in `.claude/commands/`
* Hooks in `.claude/hooks/`
* Brand file at `.vvk/vvbf_brand.json`
* Updated CLAUDE.md with
{vose_managed_section_s}
* Single git commit

{voss_completion}

All
{vose_kit_s}
installed atomically.
Clean git history with single install commit.


[[vosou_uninstall]]
// ⟦axl_voices axo_command axe_rust_impl axd_transient⟧
=== {vosou_uninstall}

Removes Claude Code integration from
{vosp_target_repo}
while preserving
{vose_kit}
directories.
Unveiled kit content is typically open-source and remains functional outside Claude Code; vacate removes only the Claude-specific layer (commands, hooks, managed sections, vvx binary).
Uses brand file to enumerate what to remove.

Invocation (from target repo root):

----
./Tools/vvk/vvu_uninstall.sh
----

The bash script is a thin bootstrap: exec `vvx_vacate`.
All logic is implemented in Rust.

{voss_inputs}

// ⟦axd_none⟧
No arguments. Operates on current repository using `.buk/burc.env`.

{voss_behavior}

. *Validate burc.env*:
.. {vosc_require}
`.buk/burc.env` exists and is readable
.. {vosc_call}
parse burc.env as KEY=VALUE pairs
.. {vosc_require}
`BURC_PROJECT_ROOT` is defined and non-empty
.. {vosc_require}
`BURC_TOOLS_DIR` is defined and non-empty
.. {vosc_require}
`BURC_MANAGED_KITS` is defined and non-empty
.. {vosc_fatal}
if missing or empty: "burc.env missing required variable: {name}"
.. {vosc_call}
resolve `BURC_PROJECT_ROOT` as path from burc.env's location to project root
.. {vosc_call}
resolve `BURC_TOOLS_DIR` relative to resolved project_root (per BURC spec)
+
NOTE: `BURC_MANAGED_KITS` is required for defense in depth; any VVK-managed repo should declare its kit inventory.

. *Validate git state*:
.. {vosc_require}
working tree is clean
.. {vosc_fatal}
if dirty: "Repo has uncommitted changes. Commit or stash before uninstall."

. *Read brand file*:
.. {vosc_require}
`.vvk/vvbf_brand.json` exists
.. {vosc_fatal}
if absent: "No VVK installation found (.vvk/vvbf_brand.json missing)"
.. {vosc_call}
parse brand file
.. {vosc_require}
{vosem_brand_kits}
is present and non-empty
.. {vosc_fatal}
if malformed: "Brand file malformed: {details}"
.. {vosc_store}
kit list and their
{voslc_cipher_s}

. *Remove commands and hooks*:
.. For each
{voslc_cipher}
from kit list:
... {vosc_call}
remove files matching `{cipher}c-*.md` from `.claude/commands/`
... {vosc_call}
remove files matching `{cipher}h-*.md` from `.claude/hooks/`
.. {vosc_step}
"{n} commands removed, {m} hooks removed"

. *Collapse CLAUDE.md sections*:
.. If CLAUDE.md exists:
... For each
{vose_managed_section}
tag from kit list:
.... If
{vose_marker_s}
exist: replace with single
{vose_uninstalled_marker}
.... If markers absent: no action (section was never added or already collapsed)
.. {vosc_step}
"CLAUDE.md sections collapsed"
+
NOTE: Preserves user's chosen section ordering for future reinstall.

. *Remove vvx binary*:
.. {vosc_call}
enumerate files in `${BURC_TOOLS_DIR}/vvk/bin/`
.. For each file starting with `vvx`:
... {vosc_call}
delete file (e.g., `vvx-darwin-arm64`, `vvx-linux-x86_64`)
.. {vosc_step}
"{n} vvx binaries removed"
+
NOTE: Kit directories (`buk/`, `jjk/`, etc.) are intentionally *preserved*.
Unveiled kit content is typically open-source and remains functional outside Claude Code.
Vacate removes Claude-specific integration while retaining underlying functionality.

. *Remove brand infrastructure*:
.. {vosc_call}
delete `.vvk/vvbf_brand.json`
.. {vosc_call}
delete `.vvk/` directory if empty
.. {vosc_step}
"Brand file removed"

. *Commit uninstallation*:
.. {vosc_call}
`git add -A`
.. {vosc_call}
`git commit -m "VVK uninstall"`
.. {vosc_step}
"Uninstallation committed"

{voss_outputs}

* vvx binaries removed from `${BURC_TOOLS_DIR}/vvk/bin/`
* Commands removed from `.claude/commands/`
* Hooks removed from `.claude/hooks/`
* CLAUDE.md sections collapsed to
{vose_uninstalled_marker_s}
* Brand file and `.vvk/` removed
* Kit directories *preserved* (unveiled content remains functional)
* Single git commit

{voss_completion}

Claude Code integration cleanly removed.
Kit directories remain for continued use outside Claude Code.
{vose_uninstalled_marker_s}
preserve section positions for future reinstall.


== Routines

Routines are internal reusable procedures invoked by operations.
They encapsulate common logic for consistent behavior across the codebase.

[[vosr_lock]]
// ⟦axl_voices axo_routine⟧
=== {vosr_lock}

include::VOSRL-lock.adoc[]

[[vosr_commit]]
// ⟦axl_voices axo_routine⟧
=== {vosr_commit}

include::VOSRC-commit.adoc[]

[[vosr_guard]]
// ⟦axl_voices axo_routine⟧
=== {vosr_guard}

include::VOSRG-guard.adoc[]

[[vosr_probe]]
// ⟦axl_voices axo_routine⟧
=== {vosr_probe}

include::VOSRP-probe.adoc[]


== Commit Message Architecture

VOK operations use a specialized commit message
{voscf_format}
that shares the
{vost_hallmark}
concept with Job Jockey but omits identity nesting (no heat/pace hierarchy).

[[voscf_format]]
// ⟦axl_voices axt_string⟧
{voscf_format}::
The canonical structure for VVK commits:
+
----
vvb:HALLMARK::ACTION: message
----
+
Fields:
+
* {vosca_vvb}
— Voce Viva brand prefix (literal string)
* `HALLMARK` —
{vost_hallmark}
from
{vose_brand_file}
or
{vose_registry}
plus `HEAD`
* `` — Empty identity field (VOK operations lack heat/pace nesting)
* `ACTION` — Single-letter operation code
+
The
{vost_hallmark}
source follows the same resolution as Job Jockey:
first check `.vvk/vvbf_brand.json` in the target repo; if absent or operation is in the kit forge, use
{vose_registry}
plus `HEAD`.

[[vosca_vvb]]
// ⟦axl_voices axt_string⟧
{vosca_vvb}::
Voce Viva brand prefix.
Literal string "vvb" appearing as the first field in the
{voscf_format}.

=== Action Codes

[[voscaa_allocate]]
// ⟦axl_voices axo_operation⟧
{voscaa_allocate}::
Action code `A`.
Allocates a new
{vost_hallmark}
in the
{vose_registry}.
+
Example:
+
----
vvb:1000::A: allocated hallmark for initial release
----

[[voscai_invitatory]]
// ⟦axl_voices axo_operation⟧
{voscai_invitatory}::
Action code `i` (lowercase).
Opens a new
{vost_officium}
(bounded work period).
Created automatically when no recent invitatory exists or the gap exceeds the threshold.
Includes environment probe data in the commit body.
+
Example:
+
----
vvb:1011::i: OFFICIUM 260207-0701
----

[[voscar_release]]
// ⟦axl_voices axo_operation⟧
{voscar_release}::
Action code `R`.
Creates a
{vose_parcel}
and tags the release.
+
Example:
+
----
vvb:1000::R: release parcel 1000
----

**Cross-reference:**
The
{vost_hallmark}
concept is shared with Job Jockey's `jjb:` commit format (documented in JJSA-GallopsData.adoc).
Both systems use the same resolution logic for sourcing
{vost_hallmark_s},
but Job Jockey includes heat/pace identity in the third field while VOK leaves it empty.


== Whisper Builder API

The
{vose_whisper}
builder provides a fluent interface for
{vose_kit}
registration.

=== Required Methods

`Whisper::for_kit(id: &str)` — Create whisper for kit with given
{vosem_kit_id}.

`.cipher(c: Cipher)` — Set the
{vost_cipher}
(symbolic const from `voci_ciphers`).

`.display_name(name: &str)` — Set human-readable name.

`.register(&mut Conclave)` — Finalize and register with
{vose_conclave}.

=== Optional Methods

`.managed_section(file: &str, tag: &str)` — Add a
{vose_managed_section}.
May be called multiple times.

`.concept_model(path: &str)` — Register a
{vosa_concept_model}
for acronym indexing.
May be called multiple times.

=== Validation

Each builder method validates its input immediately.
Final validation occurs at `.register()`:

* {vosem_kit_id}
must be valid identifier
* {vost_cipher}
must be a valid const from `voci_ciphers`
* All
{vose_managed_section}
files must exist
* All
{vosa_concept_model}
files must exist

