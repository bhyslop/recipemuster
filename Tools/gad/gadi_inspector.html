<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GAD Inspector</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .comparison-header {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }

        .status-section {
            background: #e8f4fd;
            border: 1px solid #b3d9ff;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
            display: none;
        }

        .dropdown-container {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 15px;
        }

        .dropdown-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .dropdown-group label {
            font-weight: 500;
            color: #555;
        }

        select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            min-width: 200px;
        }

        select:focus {
            border-color: #007acc;
            outline: none;
        }

        .rendered-pane {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 400px;
            line-height: 1.6;
        }

        .navigation-section {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
        }

        .nav-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-button {
            background: #007acc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .nav-button:hover {
            background: #005a9e;
        }

        .nav-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .change-counter {
            font-weight: 500;
            color: #555;
        }

        .console-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }

        .console-button:hover {
            background: #218838;
        }

        .commit-tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 14px;
            max-width: 400px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            line-height: 1.4;
            display: none;
        }

        .unchanged-commit {
            opacity: 0.6;
        }

        .unchanged-commit::after {
            content: " â‰¡";
            color: #888;
        }

        /* Diff styling - Block-level annotations with GADS-compliant deletions */
        .diff-deletion {
            background-color: #ffeef0;
            color: #d73a49;
            text-decoration: line-through;
            display: inline; /* Inline display for deletions */
            border: 1px solid #f97583;
            border-radius: 2px;
            padding: 1px 3px;
            margin: 0 2px;
        }

        .gad-deleted {
            background-color: #ffeef0;
            color: #d73a49;
            text-decoration: line-through;
            border: 1px solid #f97583;
            border-radius: 3px;
            padding: 8px 12px;
            margin: 8px 0;
            display: block;
            font-style: italic;
        }

        .gad-deleted::before {
            content: "[DELETED] ";
            font-weight: bold;
        }

        .diff-insertion {
            background-color: #f0fff4;
            border: 1px solid #28a745;
            border-radius: 3px;
            /* Block-level background highlighting */
            padding: 4px;
        }

        .diff-moved {
            background-color: #fff3cd;
            border: 1px solid #856404;
            border-radius: 3px;
            /* Block-level background highlighting */
            padding: 4px;
        }

        .diff-modification {
            background-color: #e2e3e5;
            border: 1px solid #6c757d;
            border-radius: 3px;
            /* Block-level background highlighting for text changes */
            padding: 4px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .error {
            color: #d73a49;
            background: #ffeef0;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #f97583;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="comparison-header" id="comparisonHeader">GAD Inspector</div>
        <div class="status-section" id="statusSection"></div>

        <div class="dropdown-container">
            <div class="dropdown-group">
                <label for="fromDropdown">From:</label>
                <select id="fromDropdown">
                    <option value="">Loading...</option>
                </select>
            </div>

            <div class="dropdown-group">
                <label for="toDropdown">To:</label>
                <select id="toDropdown">
                    <option value="">Loading...</option>
                </select>
            </div>

            <button class="console-button" id="consoleButton">Copy Debug Report</button>
        </div>
    </div>

    <div class="rendered-pane" id="renderedPane">
        <div class="loading">Loading manifest...</div>
    </div>

    <div class="navigation-section" id="navigationSection">
        <div class="nav-controls">
            <button class="nav-button" id="previousButton">Previous</button>
            <span class="change-counter" id="changeCounter">Change 0 of 0</span>
            <button class="nav-button" id="nextButton">Next</button>
        </div>
    </div>

    <div class="commit-tooltip" id="commitTooltip"></div>

    <script type="module">
        // Use ESM import for modern diff-dom
        import { DiffDOM } from 'https://cdn.skypack.dev/diff-dom@5.2.0';
        window.diffDom = { DiffDOM };
        console.log('[DEBUG] diff-dom loaded via ESM:', typeof DiffDOM);
        // Trigger initialization if DOM is already ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => window.dispatchEvent(new Event('diff-dom-ready')));
        } else {
            window.dispatchEvent(new Event('diff-dom-ready'));
        }
    </script>
    <script>
        // Trace buffer implementation per GADS specification
        class TraceBuffer {
            constructor() {
                this.maxEntries = 1000;
                this.storageKey = 'gad_trace_buffer';
                this.loadBuffer();
            }

            loadBuffer() {
                try {
                    const stored = sessionStorage.getItem(this.storageKey);
                    this.entries = stored ? JSON.parse(stored) : [];
                } catch (e) {
                    this.entries = [];
                }
            }

            saveBuffer() {
                try {
                    sessionStorage.setItem(this.storageKey, JSON.stringify(this.entries));
                } catch (e) {
                    console.warn('Failed to save trace buffer to sessionStorage');
                }
            }

            append(prefix, message) {
                const timestamp = new Date().toISOString();
                const entry = `${timestamp} ${prefix} ${message}`;
                this.entries.push(entry);

                // Maintain rolling buffer
                if (this.entries.length > this.maxEntries) {
                    this.entries = this.entries.slice(-this.maxEntries);
                }

                this.saveBuffer();
                console.log(entry);
            }

            getContents() {
                return this.entries.join('\n');
            }
        }

        const traceBuffer = new TraceBuffer();

        // WebSocket trace handler for GADS compliance
        class WebSocketTraceHandler {
            constructor() {
                this.ws = null;
                this.connect();
            }

            connect() {
                try {
                    const wsPort = window.location.port || 8080; // Use same port as HTTP
                    const wsUrl = `ws://${window.location.hostname}:${wsPort}/ws`;
                    console.log(`[DEBUG] Attempting WebSocket connection to: ${wsUrl}`);
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('[DEBUG] WebSocket connected');
                    };

                    this.ws.onerror = (error) => {
                        console.log('[DEBUG] WebSocket error:', error);
                    };

                    this.ws.onclose = () => {
                        console.log('[DEBUG] WebSocket disconnected');
                    };
                } catch (error) {
                    console.log('[DEBUG] WebSocket connection failed:', error);
                }
            }

            sendTrace(prefix, message) {
                // Send to WebSocket if connected
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    try {
                        this.ws.send(JSON.stringify({
                            type: 'trace',
                            message: `${prefix} ${message}`
                        }));
                    } catch (error) {
                        // Fallback to console only if WebSocket fails
                        console.log(`[WS-ERROR] ${prefix} ${message}`);
                    }
                } else {
                    // Fallback to console if WebSocket not connected
                    console.log(`[NO-WS] ${prefix} ${message}`);
                }
            }

            sendRenderedContent(htmlContent) {
                // Send rendered content to Factory for debug temp file creation
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    try {
                        this.ws.send(JSON.stringify({
                            type: 'rendered_content',
                            content: htmlContent
                        }));
                        console.log('[RENDERED-CONTENT] Sent to Factory for debug temp file');
                    } catch (error) {
                        console.log(`[WS-ERROR] Failed to send rendered content: ${error}`);
                    }
                } else {
                    console.log('[NO-WS] Cannot send rendered content - WebSocket not connected');
                }
            }
        }

        const wsTraceHandler = new WebSocketTraceHandler();

        // GAD Inspector implementation
        class GadInspector {
            constructor() {
                this.manifest = null;
                this.currentChanges = [];
                this.currentChangeIndex = 0;
                this.lastDiffDomHtml = null;
                this.lastDiffOperations = null;
                this.lastDomBeforeStyling = null;

                wsTraceHandler.sendTrace('[DEBUG]', 'GadInspector constructor called');
                this.initializeElements();
                this.setupEventListeners();
                this.loadManifest();
            }

            initializeElements() {
                wsTraceHandler.sendTrace('[DEBUG]', 'Initializing DOM elements');
                this.elements = {
                    comparisonHeader: document.getElementById('comparisonHeader'),
                    statusSection: document.getElementById('statusSection'),
                    fromDropdown: document.getElementById('fromDropdown'),
                    toDropdown: document.getElementById('toDropdown'),
                    renderedPane: document.getElementById('renderedPane'),
                    navigationSection: document.getElementById('navigationSection'),
                    previousButton: document.getElementById('previousButton'),
                    nextButton: document.getElementById('nextButton'),
                    changeCounter: document.getElementById('changeCounter'),
                    commitTooltip: document.getElementById('commitTooltip'),
                    consoleButton: document.getElementById('consoleButton')
                };

                // Check if all elements were found
                Object.entries(this.elements).forEach(([key, element]) => {
                    if (!element) {
                        wsTraceHandler.sendTrace('[ERROR]', `Failed to find DOM element: ${key}`);
                    }
                });
                wsTraceHandler.sendTrace('[DEBUG]', 'DOM elements initialized');
            }

            setupEventListeners() {
                this.elements.fromDropdown.addEventListener('change', () => this.onDropdownChange());
                this.elements.toDropdown.addEventListener('change', () => this.onDropdownChange());

                this.elements.previousButton.addEventListener('click', () => this.previousChange());
                this.elements.nextButton.addEventListener('click', () => this.nextChange());
                this.elements.consoleButton.addEventListener('click', () => this.copyDiffDomResult());


                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'j') this.nextChange();
                    if (e.key === 'k') this.previousChange();
                    if (e.key >= '1' && e.key <= '9') {
                        const index = parseInt(e.key) - 1;
                        if (index < this.currentChanges.length) {
                            this.currentChangeIndex = index;
                            this.highlightChange();
                        }
                    }
                });

                // Tooltip handling
                [this.elements.fromDropdown, this.elements.toDropdown].forEach(dropdown => {
                    dropdown.addEventListener('mouseover', (e) => this.showCommitTooltip(e));
                    dropdown.addEventListener('mouseout', () => this.hideCommitTooltip());
                });

                // Parse URL hash on load
                window.addEventListener('load', () => this.parseUrlHash());
                window.addEventListener('hashchange', () => this.parseUrlHash());
            }

            async loadManifest() {
                wsTraceHandler.sendTrace('[DEBUG]', 'Starting manifest load');
                wsTraceHandler.sendTrace('[MANIFEST]', 'Loading start');

                try {
                    wsTraceHandler.sendTrace('[DEBUG]', 'Fetching manifest.json');
                    wsTraceHandler.sendTrace('[DEBUG]', `Fetch URL: ${window.location.origin}/manifest.json`);
                    const response = await fetch('manifest.json');
                    wsTraceHandler.sendTrace('[DEBUG]', `Fetch response status: ${response.status}`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    wsTraceHandler.sendTrace('[DEBUG]', 'Parsing manifest JSON');
                    this.manifest = await response.json();
                    wsTraceHandler.sendTrace('[DEBUG]', `Manifest loaded successfully with ${this.manifest.commits.length} commits`);
                    wsTraceHandler.sendTrace('[MANIFEST]', `Successful load with ${this.manifest.commits.length} commits`);

                    wsTraceHandler.sendTrace('[DEBUG]', 'Starting populateDropdowns');
                    this.populateDropdowns();
                    wsTraceHandler.sendTrace('[DEBUG]', 'populateDropdowns completed');

                    wsTraceHandler.sendTrace('[DEBUG]', 'Starting parseUrlHash');
                    this.parseUrlHash();
                    wsTraceHandler.sendTrace('[DEBUG]', 'parseUrlHash completed');

                } catch (error) {
                    wsTraceHandler.sendTrace('[DEBUG]', `Manifest load failed: ${error.message}`);
                    wsTraceHandler.sendTrace('[MANIFEST]', `Load failure: ${error.message}`);
                    this.elements.renderedPane.innerHTML = `
                        <div class="error">
                            <h3>Failed to load manifest.json</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            }

            populateDropdowns() {
                wsTraceHandler.sendTrace('[DEBUG]', 'Clearing dropdown options');
                // Clear existing options
                this.elements.fromDropdown.innerHTML = '';
                this.elements.toDropdown.innerHTML = '';

                wsTraceHandler.sendTrace('[DEBUG]', 'Adding magic values to dropdowns');
                // Add magic values to from dropdown
                this.addOption(this.elements.fromDropdown, 'before-last', 'before-last (previous commit)');
                this.addOption(this.elements.fromDropdown, 'before-substantive', 'before-substantive (last different)');

                // Add magic value to to dropdown
                this.addOption(this.elements.toDropdown, 'latest', 'latest (newest commit)');

                wsTraceHandler.sendTrace('[DEBUG]', `Processing ${this.manifest.commits.length} commits for dropdowns`);
                // Add commits to both dropdowns
                this.manifest.commits.forEach((commit, index) => {
                    wsTraceHandler.sendTrace('[DEBUG]', `Processing commit ${index + 1}: ${commit.hash.substring(0, 8)}`);
                    const isUnchanged = index > 0 &&
                        commit.html_sha256 === this.manifest.commits[index - 1].html_sha256;

                    const shortHash = commit.hash.substring(0, 8);
                    const text = `${shortHash} - ${commit.message}`;

                    this.addOption(this.elements.fromDropdown, commit.hash, text, isUnchanged);
                    this.addOption(this.elements.toDropdown, commit.hash, text, isUnchanged);
                });
                wsTraceHandler.sendTrace('[DEBUG]', 'Dropdown population completed');
            }

            addOption(dropdown, value, text, isUnchanged = false) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = text;
                if (isUnchanged) {
                    option.className = 'unchanged-commit';
                }
                dropdown.appendChild(option);
            }

            parseUrlHash() {
                wsTraceHandler.sendTrace('[DEBUG]', `parseUrlHash called with hash: "${window.location.hash}"`);
                const hash = window.location.hash.substring(1);
                const params = new URLSearchParams(hash);

                const fromValue = params.get('from');
                const toValue = params.get('to');
                wsTraceHandler.sendTrace('[DEBUG]', `Parsed URL params - from: "${fromValue}", to: "${toValue}"`);

                if (fromValue) {
                    wsTraceHandler.sendTrace('[DEBUG]', `Setting fromDropdown to: ${fromValue}`);
                    this.elements.fromDropdown.value = fromValue;
                }
                if (toValue) {
                    wsTraceHandler.sendTrace('[DEBUG]', `Setting toDropdown to: ${toValue}`);
                    this.elements.toDropdown.value = toValue;
                }

                if (fromValue || toValue) {
                    wsTraceHandler.sendTrace('[DEBUG]', 'URL params found, calling performDiff');
                    this.performDiff();
                } else {
                    wsTraceHandler.sendTrace('[DEBUG]', 'No URL params found, not calling performDiff');
                }
            }

            onDropdownChange() {
                const fromValue = this.elements.fromDropdown.value;
                const toValue = this.elements.toDropdown.value;

                wsTraceHandler.sendTrace('[DROPDOWN]', `From changed to: ${fromValue}`);
                wsTraceHandler.sendTrace('[DROPDOWN]', `To changed to: ${toValue}`);

                this.updateUrlHash();
                this.performDiff();
            }

            updateUrlHash() {
                const fromValue = this.elements.fromDropdown.value;
                const toValue = this.elements.toDropdown.value;

                if (fromValue && toValue) {
                    window.location.hash = `from=${encodeURIComponent(fromValue)}&to=${encodeURIComponent(toValue)}`;
                }
            }

            async performDiff() {
                const fromValue = this.elements.fromDropdown.value;
                const toValue = this.elements.toDropdown.value;

                if (!fromValue || !toValue) return;

                try {
                    wsTraceHandler.sendTrace('[RESOLVE]', 'Magic value resolution start');

                    const fromCommit = this.resolveCommit(fromValue);
                    const toCommit = this.resolveCommit(toValue);

                    if (!fromCommit || !toCommit) {
                        wsTraceHandler.sendTrace('[ERROR]', 'Invalid magic values or missing commits in manifest');
                        throw new Error('Failed to resolve commits');
                    }

                    wsTraceHandler.sendTrace('[RESOLVE]', `Resolved from: ${fromCommit.hash.substring(0, 8)}, to: ${toCommit.hash.substring(0, 8)}`);

                    // Update comparison header
                    this.elements.comparisonHeader.textContent =
                        `${fromCommit.hash.substring(0, 8)} â†’ ${toCommit.hash.substring(0, 8)}`;

                    // Check for identical SHA256
                    if (fromCommit.html_sha256 === toCommit.html_sha256) {
                        wsTraceHandler.sendTrace('[SHA256]', 'Detection of identical html_sha256 values between selected commits');
                        this.showStatusMessage('These commits have identical rendered content');
                    } else {
                        wsTraceHandler.sendTrace('[SHA256]', 'Detection of different html_sha256 values between selected commits');
                        this.hideStatusMessage();
                    }

                    await this.fetchAndDiff(fromCommit, toCommit);

                } catch (error) {
                    wsTraceHandler.sendTrace('[ERROR]', `Diff error: ${error.message}`);
                    this.elements.renderedPane.innerHTML = `
                        <div class="error">
                            <h3>Diff Error</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            }

            resolveCommit(value) {
                if (value === 'latest') {
                    return this.manifest.commits[this.manifest.commits.length - 1];
                } else if (value === 'before-last') {
                    return this.manifest.commits[this.manifest.commits.length - 2];
                } else if (value === 'before-substantive') {
                    const latest = this.manifest.commits[this.manifest.commits.length - 1];
                    let skippedCount = 0;
                    for (let i = this.manifest.commits.length - 2; i >= 0; i--) {
                        if (this.manifest.commits[i].html_sha256 !== latest.html_sha256) {
                            if (skippedCount > 0) {
                                wsTraceHandler.sendTrace('[RESOLVE]', `Skipped ${skippedCount} unchanged commits for before-substantive`);
                                this.showStatusMessage(`Skipped ${skippedCount} unchanged commits to find last substantive change`);
                            }
                            return this.manifest.commits[i];
                        }
                        skippedCount++;
                    }
                    return this.manifest.commits[0];
                } else {
                    return this.manifest.commits.find(c => c.hash === value);
                }
            }

            async fetchAndDiff(fromCommit, toCommit) {
                wsTraceHandler.sendTrace('[FETCH]', `HTML fetch start for ${fromCommit.html_file} and ${toCommit.html_file}`);

                try {
                    const [fromResponse, toResponse] = await Promise.all([
                        fetch(`/output/${fromCommit.html_file}`),
                        fetch(`/output/${toCommit.html_file}`)
                    ]);

                    if (!fromResponse.ok || !toResponse.ok) {
                        throw new Error('Failed to fetch HTML files');
                    }

                    const [fromHtml, toHtml] = await Promise.all([
                        fromResponse.text(),
                        toResponse.text()
                    ]);

                    wsTraceHandler.sendTrace('[FETCH]', 'Successful fetch completion');
                    wsTraceHandler.sendTrace('[DIFF]', 'Diff computation start');

                    // Use diff-dom library
                    const styledDiff = this.styleDiff(fromHtml, toHtml);

                    this.elements.renderedPane.innerHTML = styledDiff;

                    // Send rendered content to Factory via WebSocket for debug temp file
                    wsTraceHandler.sendRenderedContent(styledDiff);

                    // Count changes for navigation - updated for GADS classifications
                    this.currentChanges = this.elements.renderedPane.querySelectorAll('.diff-deletion, .diff-insertion, .diff-moved, .diff-modification');
                    this.currentChangeIndex = 0;

                    // Enhanced logging for Factory debugging
                    const changeTypeBreakdown = {
                        insertions: this.elements.renderedPane.querySelectorAll('.diff-insertion').length,
                        moves: this.elements.renderedPane.querySelectorAll('.diff-moved').length,
                        deletions: this.elements.renderedPane.querySelectorAll('.diff-deletion').length,
                        modifications: this.elements.renderedPane.querySelectorAll('.diff-modification').length
                    };

                    // Debug trace for change counting
                    wsTraceHandler.sendTrace('[COUNT]', `Found ${this.currentChanges.length} total change elements in rendered output`);
                    wsTraceHandler.sendTrace('[COUNT]', `Breakdown: ${changeTypeBreakdown.insertions} insertions, ${changeTypeBreakdown.moves} moves, ${changeTypeBreakdown.deletions} deletions, ${changeTypeBreakdown.modifications} modifications`);

                    wsTraceHandler.sendTrace('[DIFF]', `Completion with ${this.currentChanges.length} total changes`);
                    wsTraceHandler.sendTrace('[DIFF]', `Change breakdown: ${JSON.stringify(changeTypeBreakdown)}`);

                    this.updateNavigation();

                } catch (error) {
                    // Enhanced error reporting for Factory debugging
                    if (error.message.includes('diff-dom')) {
                        wsTraceHandler.sendTrace('[ERROR]', `diff-dom library failure: ${error.message}`);
                    } else if (error.message.includes('fetch') || error.message.includes('HTTP')) {
                        wsTraceHandler.sendTrace('[FETCH]', `Fetch failure: ${error.message}`);
                    } else {
                        wsTraceHandler.sendTrace('[ERROR]', `GADS processing failure: ${error.message}`);
                    }

                    // Additional debugging context
                    wsTraceHandler.sendTrace('[DEBUG]', `Error occurred during diff processing for commits: ${fromCommit?.hash?.substring(0,8)} â†’ ${toCommit?.hash?.substring(0,8)}`);
                    throw error;
                }
            }

            styleDiff(fromHtml, toHtml) {
                const startTime = performance.now();
                wsTraceHandler.sendTrace('[DIFF]', 'Starting GADS-compliant immutable diff processing');
                wsTraceHandler.sendTrace('[DEBUG]', `Input sizes: fromHtml=${fromHtml.length} chars, toHtml=${toHtml.length} chars`);
                wsTraceHandler.sendTrace('[DEBUG]', `diff-dom type at diff time: ${typeof window.diffDom}`);

                if (typeof window.diffDom === 'undefined' || typeof window.diffDom.DiffDOM === 'undefined') {
                    throw new Error('diff-dom library not available - required for diff processing');
                }

                try {
                    // Phase 1: Create Immutable Input DOMs (never modify these)
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 1: Creating immutable input DOM trees');
                    const immutableFromDOM = this.createDOMFromHTML(fromHtml);
                    const immutableToDOM = this.createDOMFromHTML(toHtml);
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 1: Immutable DOM trees created and preserved');

                    // Phase 2: Pre-capture Deletion Content
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 2: Pre-capturing deletion content from immutable fromDOM');
                    const routeElementMap = this.createRouteElementMap(immutableFromDOM);
                    wsTraceHandler.sendTrace('[DEBUG]', `Pre-captured ${Object.keys(routeElementMap).length} elements for deletion handling`);
                    
                    this.lastDomBeforeStyling = immutableToDOM.innerHTML; // Store original "to" DOM

                    // Phase 3: Generate Diff Operations
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 3: Generating diff operations via diff-dom');
                    const diffDOM = new window.diffDom.DiffDOM();
                    const diffOperations = diffDOM.diff(immutableFromDOM, immutableToDOM);
                    
                    // Enhance operations with pre-captured content
                    this.enhanceOperationsWithCapturedContent(diffOperations, routeElementMap);
                    
                    this.lastDiffOperations = diffOperations; // Store for debug report
                    wsTraceHandler.sendTrace('[DIFF]', `Phase 3: Generated ${diffOperations.length} diff operations`);

                    // Phase 4: Generate Clean Output DOM
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 4: Generating clean output DOM from immutable inputs');
                    const outputDOM = this.generateOutputDOM(immutableToDOM, diffOperations);
                    this.lastDiffDomHtml = outputDOM.innerHTML; // Store for clipboard functionality
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 4: Clean output DOM generation completed');

                    // Performance logging for Factory debugging
                    const endTime = performance.now();
                    const totalTime = Math.round(endTime - startTime);
                    wsTraceHandler.sendTrace('[PERF]', `GADS immutable diff processing completed in ${totalTime}ms`);
                    wsTraceHandler.sendTrace('[ARCH]', 'Input DOMs remain completely unmodified throughout processing');

                    return outputDOM.innerHTML;

                } catch (error) {
                    wsTraceHandler.sendTrace('[ERROR]', `GADS immutable diff processing failed: ${error.message}`);
                    throw error;
                }
            }

            // Phase 1: Block Identification - GADS compliant implementation
            identifyBlocks(html, source) {
                wsTraceHandler.sendTrace('[DEBUG]', `Block identification starting for ${source}`);

                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const blocks = [];

                // Target block-level elements per GADS specification
                const blockElements = ['P', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6',
                                      'LI', 'TD', 'TH', 'BLOCKQUOTE', 'PRE', 'SECTION', 'ARTICLE',
                                      'HEADER', 'FOOTER', 'NAV', 'ASIDE', 'MAIN'];

                const walker = doc.createTreeWalker(
                    doc.body || doc.documentElement,
                    NodeFilter.SHOW_ELEMENT,
                    {
                        acceptNode: function(node) {
                            return blockElements.includes(node.tagName) ?
                                NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
                        }
                    }
                );

                let node;
                let blockIndex = 0;
                while (node = walker.nextNode()) {
                    // Generate unique identifier based on element type, DOM path, and content
                    const domPath = this.getDomPath(node);
                    const textContent = node.textContent.trim();
                    const blockId = `${node.tagName}-${blockIndex}-${this.hashString(domPath + textContent)}`;

                    blocks.push({
                        id: blockId,
                        source: source,  // Track source separately
                        element: node,
                        tagName: node.tagName,
                        domPath: domPath,
                        textContent: textContent,
                        innerHTML: node.innerHTML,
                        index: blockIndex
                    });

                    blockIndex++;
                }

                wsTraceHandler.sendTrace('[DEBUG]', `Block identification completed for ${source}: ${blocks.length} blocks`);
                return blocks;
            }

            getDomPath(element) {
                const path = [];
                let current = element;
                while (current && current.nodeType === Node.ELEMENT_NODE) {
                    let selector = current.tagName.toLowerCase();
                    if (current.id) {
                        selector += '#' + current.id;
                    } else if (current.className) {
                        selector += '.' + current.className.split(/\s+/).join('.');
                    }
                    path.unshift(selector);
                    current = current.parentElement;
                }
                return path.join(' > ');
            }

            hashString(str) {
                // Simple hash function for unique identifiers
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash).toString(16);
            }

            linearizeBlocks(blocks) {
                wsTraceHandler.sendTrace('[DEBUG]', `Linearizing ${blocks.length} blocks`);

                // Create text linearization preserving block boundaries with identical separator markers
                const BLOCK_START = 'âŸ¨BLOCKâŸ©';
                const BLOCK_END = 'âŸ¨/BLOCKâŸ©';
                const linearized = blocks.map(block => {
                    return `${BLOCK_START}${block.textContent}${BLOCK_END}`;
                }).join('\n');

                wsTraceHandler.sendTrace('[DEBUG]', `Linearization completed, length: ${linearized.length}`);
                return linearized;
            }

            // Helper method for creating DOM from HTML strings
            createDOMFromHTML(html) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                return doc.body;
            }

            findElementByRoute(dom, route) {
                let element = dom;
                for (let i = 0; i < route.length; i++) {
                    const index = route[i];
                    if (element.childNodes && element.childNodes[index]) {
                        element = element.childNodes[index];
                    } else {
                        const availableCount = element.childNodes ? element.childNodes.length : 0;
                        
                        // Simple fix for diff-dom off-by-one indexing: try the last valid child
                        if (availableCount > 0 && index >= availableCount) {
                            const correctedIndex = availableCount - 1;
                            wsTraceHandler.sendTrace('[DEBUG]', `Route index ${index} out of bounds (${availableCount} children), trying last child at index ${correctedIndex}`);
                            element = element.childNodes[correctedIndex];
                        } else {
                            wsTraceHandler.sendTrace('[DEBUG]', `Route traversal failed at index ${index} for route [${route.join(',')}]`);
                            wsTraceHandler.sendTrace('[DEBUG]', `Parent has ${availableCount} children, requested index ${index}`);
                            wsTraceHandler.sendTrace('[DEBUG]', `Failed at route position ${i}, partial route was [${route.slice(0, i).join(',')}]`);
                            return null;
                        }
                    }
                }
                return element;
            }

            escapeHtml(unsafe) {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            extractTextFromHtml(htmlString) {
                try {
                    // Create a temporary element to parse HTML and extract text content
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlString;
                    return tempDiv.textContent || tempDiv.innerText || '';
                } catch (e) {
                    // Fallback: basic tag stripping
                    return htmlString.replace(/<[^>]*>/g, '').trim();
                }
            }

            generateOutputDOM(immutableToDOM, diffOperations) {
                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Generating clean output DOM from ${diffOperations.length} operations`);
                
                // Create completely new output DOM structure - never modify inputs
                const outputDOM = document.createElement('div');
                
                // Deep clone the immutable "to" DOM structure as foundation
                this.deepCloneElement(immutableToDOM, outputDOM);
                wsTraceHandler.sendTrace('[OUTPUT-GEN]', 'Created output DOM foundation from immutable toDOM');
                
                // Apply diff annotations to output DOM with deduplication
                let insertions = 0, deletions = 0, moves = 0, modifications = 0;
                const processedDeletions = new Set(); // Track processed deletion routes to prevent duplicates
                
                // Process operations to generate annotations
                for (const op of diffOperations) {
                    switch (op.action) {
                        case 'addElement':
                        case 'addTextElement':
                            this.applyInsertionAnnotation(outputDOM, op);
                            insertions++;
                            break;
                        case 'removeElement': 
                        case 'removeTextElement':
                            const routeKey = op.route.join(',');
                            if (!processedDeletions.has(routeKey)) {
                                this.generateDeletionBlock(outputDOM, op);
                                processedDeletions.add(routeKey);
                                deletions++;
                                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Processed unique deletion at route [${routeKey}]`);
                            } else {
                                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Skipped duplicate deletion at route [${routeKey}]`);
                            }
                            break;
                        case 'relocateNode':
                            this.applyMoveAnnotation(outputDOM, op);
                            moves++;
                            break;
                        case 'modifyTextElement':
                        case 'modifyAttribute':
                            // Only apply modification styling, don't double-annotate as insertion
                            this.applyModificationAnnotation(outputDOM, op);
                            modifications++;
                            break;
                        default:
                            wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Unknown operation type: ${op.action}`);
                    }
                }
                
                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Applied annotations: ${insertions} insertions, ${deletions} deletions (${processedDeletions.size} unique), ${moves} moves, ${modifications} modifications`);
                wsTraceHandler.sendTrace('[OUTPUT-GEN]', 'Output DOM generation completed with all annotations applied');
                
                return outputDOM;
            }

            isInlineElement(element) {
                const inlineElements = new Set(['A', 'SPAN', 'EM', 'STRONG', 'B', 'I', 'U', 'CODE', 'MARK', 'SMALL', 'SUP', 'SUB']);
                return inlineElements.has(element.tagName);
            }

            deepCloneElement(sourceElement, targetParent) {
                if (!sourceElement || !sourceElement.childNodes) return;
                
                // Clone all child nodes recursively
                for (let i = 0; i < sourceElement.childNodes.length; i++) {
                    const sourceChild = sourceElement.childNodes[i];
                    let clonedChild;
                    
                    if (sourceChild.nodeType === Node.ELEMENT_NODE) {
                        // Create element with all attributes
                        clonedChild = document.createElement(sourceChild.tagName.toLowerCase());
                        for (let j = 0; j < sourceChild.attributes.length; j++) {
                            const attr = sourceChild.attributes[j];
                            clonedChild.setAttribute(attr.name, attr.value);
                        }
                        // Recursively clone children
                        this.deepCloneElement(sourceChild, clonedChild);
                    } else if (sourceChild.nodeType === Node.TEXT_NODE) {
                        clonedChild = document.createTextNode(sourceChild.textContent);
                    } else {
                        // Other node types (comments, etc.)
                        clonedChild = sourceChild.cloneNode(false);
                    }
                    
                    if (clonedChild) {
                        targetParent.appendChild(clonedChild);
                    }
                }
            }

            applyInsertionAnnotation(outputDOM, operation) {
                const element = this.findElementByRoute(outputDOM, operation.route);
                if (element && element.nodeType === Node.ELEMENT_NODE) {
                    // For inline elements (A, SPAN, etc.) use inline highlighting
                    if (this.isInlineElement(element)) {
                        element.style.backgroundColor = '#d4edda';
                        element.style.padding = '2px';
                        element.style.borderRadius = '2px';
                        element.classList.add('diff-insertion');
                        wsTraceHandler.sendTrace('[INSERTION]', `Applied inline insertion annotation at route [${operation.route.join(',')}]`);
                    } else {
                        // For block elements, use full block styling
                        element.classList.add('diff-insertion');
                        element.style.backgroundColor = '#d4edda';
                        element.style.borderLeft = '4px solid #28a745';
                        element.style.padding = '4px';
                        wsTraceHandler.sendTrace('[INSERTION]', `Applied block insertion annotation at route [${operation.route.join(',')}]`);
                    }
                } else if (element && element.nodeType === Node.TEXT_NODE && element.parentElement) {
                    // For text insertions, create inline highlighting
                    const parent = element.parentElement;
                    const span = document.createElement('span');
                    span.classList.add('diff-insertion');
                    span.style.backgroundColor = '#d4edda';
                    span.style.padding = '2px';
                    span.style.borderRadius = '2px';
                    
                    parent.insertBefore(span, element);
                    span.appendChild(element);
                    
                    wsTraceHandler.sendTrace('[INSERTION]', `Applied insertion annotation with span wrapper at route [${operation.route.join(',')}]`);
                } else {
                    wsTraceHandler.sendTrace('[INSERTION]', `Could not find element for insertion annotation at route [${operation.route.join(',')}]`);
                }
            }

            applyMoveAnnotation(outputDOM, operation) {
                const element = this.findElementByRoute(outputDOM, operation.route);
                if (element && element.nodeType === Node.ELEMENT_NODE) {
                    element.classList.add('diff-moved');
                    element.style.backgroundColor = '#fff3cd';
                    element.style.borderLeft = '4px solid #ffc107';
                    wsTraceHandler.sendTrace('[MOVE]', `Applied move annotation at route [${operation.route.join(',')}]`);
                } else {
                    wsTraceHandler.sendTrace('[MOVE]', `Could not find element for move annotation at route [${operation.route.join(',')}]`);
                }
            }

            applyModificationAnnotation(outputDOM, operation) {
                // Don't apply modification styling to parent containers that have child insertions
                // This prevents the entire paragraph from being marked as modified when only parts changed
                wsTraceHandler.sendTrace('[MODIFICATION]', `Skipping broad modification annotation at route [${operation.route.join(',')}] - let child insertions handle specific changes`);
            }

            generateDeletionBlock(outputDOM, operation) {
                wsTraceHandler.sendTrace('[DELETION-BLOCK]', `Generating deletion block for ${operation.action} at route [${operation.route.join(',')}]`);

                const deletionBlock = document.createElement('div');
                // Clean CSS classes - only diff-deletion, no mixing
                deletionBlock.className = 'diff-deletion';
                deletionBlock.style.backgroundColor = '#f8d7da';
                deletionBlock.style.borderLeft = '4px solid #dc3545';
                deletionBlock.style.padding = '8px';
                deletionBlock.style.margin = '4px 0';

                // Use pre-captured content with enhanced formatting
                if (operation.capturedContent) {
                    wsTraceHandler.sendTrace('[DELETION-BLOCK]', `Using pre-captured content (${operation.capturedType}): ${operation.capturedContent.substring(0, 50)}...`);
                    
                    if (operation.capturedType === 'text' || operation.capturedType === 'fallback-text') {
                        deletionBlock.innerHTML = `<strong>Deleted text:</strong> <span style="font-style: italic; color: #721c24;">"${this.escapeHtml(operation.capturedContent)}"</span>`;
                    } else if (operation.capturedType === 'element') {
                        const textContent = this.extractTextFromHtml(operation.capturedContent);
                        if (textContent && textContent !== operation.capturedContent) {
                            deletionBlock.innerHTML = `<strong>Deleted element:</strong> <span style="font-style: italic; color: #721c24;">${this.escapeHtml(textContent)}</span><br><details style="margin-top: 4px;"><summary style="cursor: pointer; color: #6f42c1;">Show HTML</summary><code style="display: block; background: rgba(0,0,0,0.05); padding: 4px; margin-top: 4px; font-size: 12px;">${this.escapeHtml(operation.capturedContent)}</code></details>`;
                        } else {
                            deletionBlock.innerHTML = `<strong>Deleted element:</strong><br><code style="display: block; background: rgba(0,0,0,0.05); padding: 4px; font-size: 12px;">${this.escapeHtml(operation.capturedContent)}</code>`;
                        }
                    } else {
                        deletionBlock.innerHTML = `<strong>Deleted content:</strong> <span style="font-style: italic; color: #721c24;">"${this.escapeHtml(operation.capturedContent)}"</span>`;
                    }
                } else {
                    // Fallback when no captured content available
                    deletionBlock.innerHTML = `<strong>Deleted content</strong> <span style="color: #6a737d;">(content not captured)</span><br><em style="font-size: 12px; color: #6a737d;">Action: ${operation.action}, Route: [${operation.route.join(',')}]</em>`;
                    wsTraceHandler.sendTrace('[DELETION-BLOCK]', `No captured content available for deletion`);
                }

                // Insert deletion block in output DOM at block-level location
                const insertPoint = this.findDeletionInsertionPoint(outputDOM, operation.route);
                if (insertPoint && insertPoint.container) {
                    if (insertPoint.insertBefore) {
                        insertPoint.container.insertBefore(deletionBlock, insertPoint.insertBefore);
                        wsTraceHandler.sendTrace('[DELETION-BLOCK]', `Inserted deletion block before sibling in ${insertPoint.container.tagName || 'container'}`);
                    } else {
                        insertPoint.container.appendChild(deletionBlock);
                        wsTraceHandler.sendTrace('[DELETION-BLOCK]', `Appended deletion block to ${insertPoint.container.tagName || 'container'}`);
                    }
                } else {
                    // Fallback: append to output DOM root
                    outputDOM.appendChild(deletionBlock);
                    wsTraceHandler.sendTrace('[DELETION-BLOCK]', `Fallback: appended deletion block to output DOM root`);
                }
            }

            findDeletionInsertionPoint(outputDOM, route) {
                wsTraceHandler.sendTrace('[DELETION-INSERT]', `Finding block-level insertion point for route [${route.join(',')}]`);
                
                if (route.length === 0) {
                    wsTraceHandler.sendTrace('[DELETION-INSERT]', 'Empty route, using output DOM start');
                    return { container: outputDOM, insertBefore: outputDOM.firstChild };
                }

                // Traverse route to find the element that would be deleted
                let element = outputDOM;
                for (let i = 0; i < route.length; i++) {
                    if (element.childNodes && element.childNodes[route[i]]) {
                        element = element.childNodes[route[i]];
                    } else {
                        wsTraceHandler.sendTrace('[DELETION-INSERT]', `Route traversal failed at position ${i}, using parent container`);
                        return this.findBlockLevelContainer(element);
                    }
                }

                // Found the target element - now find appropriate block-level insertion point
                return this.findBlockLevelContainer(element);
            }

            findBlockLevelContainer(element) {
                if (!element) {
                    wsTraceHandler.sendTrace('[DELETION-INSERT]', 'No element provided, defaulting to document level');
                    return { container: document.body || document.documentElement, insertBefore: null };
                }

                // Walk up the DOM tree to find a suitable block-level container
                let current = element;
                let blockLevelTags = new Set(['DIV', 'P', 'SECTION', 'ARTICLE', 'HEADER', 'FOOTER', 'NAV', 'ASIDE', 'MAIN', 'BLOCKQUOTE', 'DL', 'DD', 'LI', 'TD', 'TH']);
                
                while (current && current.parentNode) {
                    const parent = current.parentNode;
                    
                    // If parent is a block-level element, we can insert after current as a sibling
                    if (parent.tagName && blockLevelTags.has(parent.tagName)) {
                        wsTraceHandler.sendTrace('[DELETION-INSERT]', `Found block container: ${parent.tagName}, inserting after ${current.tagName || 'node'}`);
                        return { container: parent, insertBefore: current.nextSibling };
                    }
                    
                    current = parent;
                }

                // Fallback: insert at document level
                wsTraceHandler.sendTrace('[DELETION-INSERT]', 'No suitable block container found, using document level');
                const documentRoot = current.ownerDocument ? current.ownerDocument.body || current.ownerDocument.documentElement : document.body;
                return { container: documentRoot, insertBefore: null };
            }

            createRouteElementMap(dom) {
                wsTraceHandler.sendTrace('[ROUTE-MAP]', 'Building route-to-element mapping for deletion capture');
                const routeMap = {};

                const mapElement = (element, route) => {
                    if (!element) return;
                    
                    const routeKey = route.join(',');
                    routeMap[routeKey] = {
                        element: element,
                        nodeType: element.nodeType,
                        outerHTML: element.nodeType === Node.ELEMENT_NODE ? element.outerHTML : null,
                        textContent: element.textContent || '',
                        nodeName: element.nodeName || ''
                    };
                    
                    // Recursively map child nodes
                    if (element.childNodes) {
                        for (let i = 0; i < element.childNodes.length; i++) {
                            const childRoute = [...route, i];
                            mapElement(element.childNodes[i], childRoute);
                        }
                    }
                };
                
                // Start mapping from root with empty route
                mapElement(dom, []);
                
                wsTraceHandler.sendTrace('[ROUTE-MAP]', `Created mapping for ${Object.keys(routeMap).length} DOM nodes`);
                return routeMap;
            }

            enhanceOperationsWithCapturedContent(diffOperations, routeElementMap) {
                wsTraceHandler.sendTrace('[ENHANCE]', `Enhancing ${diffOperations.length} operations with pre-captured content`);
                
                let deletionsFound = 0;
                let deletionsEnhanced = 0;
                
                for (const op of diffOperations) {
                    if (op.action === 'removeElement' || op.action === 'removeTextElement') {
                        deletionsFound++;
                        const routeKey = op.route.join(',');
                        wsTraceHandler.sendTrace('[ENHANCE]', `Enhancing deletion ${deletionsFound}: ${op.action} at route [${routeKey}]`);
                        
                        const mappedElement = routeElementMap[routeKey];
                        if (mappedElement) {
                            if (mappedElement.nodeType === Node.TEXT_NODE) {
                                op.capturedContent = mappedElement.textContent;
                                op.capturedType = 'text';
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with captured text: "${mappedElement.textContent}"`);
                            } else if (mappedElement.nodeType === Node.ELEMENT_NODE) {
                                op.capturedContent = mappedElement.outerHTML;
                                op.capturedType = 'element';
                                const preview = mappedElement.outerHTML.substring(0, 100);
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with captured element: ${preview}${mappedElement.outerHTML.length > 100 ? '...' : ''}`);
                            } else {
                                op.capturedContent = mappedElement.textContent || `Unknown node: ${mappedElement.nodeName}`;
                                op.capturedType = 'unknown';
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with captured unknown node: ${op.capturedContent}`);
                            }
                            deletionsEnhanced++;
                        } else {
                            wsTraceHandler.sendTrace('[ENHANCE]', `No mapping found for deletion route [${routeKey}]`);
                            // Fallback to operation text if available
                            if (op.text) {
                                op.capturedContent = op.text;
                                op.capturedType = 'fallback-text';
                                deletionsEnhanced++;
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with fallback text: "${op.text}"`);
                            }
                        }
                    }
                }
                
                wsTraceHandler.sendTrace('[ENHANCE]', `Operation enhancement complete: ${deletionsEnhanced}/${deletionsFound} deletions enhanced`);
            }



            updateNavigation() {
                if (this.currentChanges.length > 0) {
                    this.elements.navigationSection.style.display = 'block';
                    this.elements.changeCounter.textContent =
                        `Change ${this.currentChangeIndex + 1} of ${this.currentChanges.length}`;

                    this.elements.previousButton.disabled = this.currentChangeIndex === 0;
                    this.elements.nextButton.disabled = this.currentChangeIndex === this.currentChanges.length - 1;

                    this.highlightChange();
                } else {
                    this.elements.navigationSection.style.display = 'none';
                }
            }

            highlightChange() {
                // Remove previous highlights
                this.currentChanges.forEach(change => {
                    change.style.outline = '';
                });

                // Highlight current change
                if (this.currentChanges[this.currentChangeIndex]) {
                    const currentChange = this.currentChanges[this.currentChangeIndex];
                    currentChange.style.outline = '2px solid #007acc';
                    currentChange.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            previousChange() {
                if (this.currentChangeIndex > 0) {
                    this.currentChangeIndex--;
                    this.updateNavigation();
                }
            }

            nextChange() {
                if (this.currentChangeIndex < this.currentChanges.length - 1) {
                    this.currentChangeIndex++;
                    this.updateNavigation();
                }
            }

            showStatusMessage(message) {
                this.elements.statusSection.textContent = message;
                this.elements.statusSection.style.display = 'block';
            }

            hideStatusMessage() {
                this.elements.statusSection.style.display = 'none';
            }

            showCommitTooltip(event) {
                const option = event.target.selectedOptions[0];
                if (!option || option.value === '') return;

                const commit = this.resolveCommit(option.value);
                if (!commit) return;

                this.elements.commitTooltip.innerHTML = `
                    <div><strong>${commit.hash}</strong></div>
                    <div>${commit.message}</div>
                `;

                this.elements.commitTooltip.style.display = 'block';
                this.elements.commitTooltip.style.left = event.pageX + 10 + 'px';
                this.elements.commitTooltip.style.top = event.pageY - 10 + 'px';
            }

            hideCommitTooltip() {
                this.elements.commitTooltip.style.display = 'none';
            }

            copyDiffDomResult() {
                if (!this.lastDiffOperations || !this.lastDiffDomHtml) {
                    alert('No diff-dom result available. Please select different commits first.');
                    return;
                }

                // Create comprehensive debug report
                const debugReport = `
=== GADI DEBUG REPORT ===

=== RAW DIFF-DOM OPERATIONS (${this.lastDiffOperations.length}) ===
${this.lastDiffOperations.map((op, i) => 
    `${i+1}. name: "${op.name}", route: [${(op.route || []).join(',')}], element: ${op.element ? 'present' : 'null'}`
).join('\n')}

=== DOM STRUCTURE BEFORE STYLING ===
${this.lastDomBeforeStyling || 'Not captured'}

=== FINAL HTML OUTPUT ===
${this.lastDiffDomHtml}

=== CHANGE COUNT SELECTORS ===
.diff-deletion: ${this.elements.renderedPane ? this.elements.renderedPane.querySelectorAll('.diff-deletion').length : 'N/A'}
.diff-insertion: ${this.elements.renderedPane ? this.elements.renderedPane.querySelectorAll('.diff-insertion').length : 'N/A'}  
.diff-moved: ${this.elements.renderedPane ? this.elements.renderedPane.querySelectorAll('.diff-moved').length : 'N/A'}
.diff-modification: ${this.elements.renderedPane ? this.elements.renderedPane.querySelectorAll('.diff-modification').length : 'N/A'}

=== END DEBUG REPORT ===
                `.trim();

                // Copy to clipboard using modern API
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(debugReport).then(() => {
                        wsTraceHandler.sendTrace('[DEBUG]', 'Debug report copied to clipboard');
                        // Briefly change button text to show success
                        const originalText = this.elements.consoleButton.textContent;
                        this.elements.consoleButton.textContent = 'Debug Copied!';
                        setTimeout(() => {
                            this.elements.consoleButton.textContent = originalText;
                        }, 1000);
                    }).catch(err => {
                        wsTraceHandler.sendTrace('[ERROR]', `Failed to copy to clipboard: ${err}`);
                        this.fallbackCopyToClipboard(debugReport);
                    });
                } else {
                    // Fallback for non-secure contexts
                    this.fallbackCopyToClipboard(debugReport);
                }
            }

            fallbackCopyToClipboard(text) {
                // Create temporary textarea for fallback copy
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    wsTraceHandler.sendTrace('[DEBUG]', 'diff-dom HTML copied to clipboard (fallback)');
                    // Briefly change button text to show success
                    const originalText = this.elements.consoleButton.textContent;
                    this.elements.consoleButton.textContent = 'Copied!';
                    setTimeout(() => {
                        this.elements.consoleButton.textContent = originalText;
                    }, 1000);
                } catch (err) {
                    wsTraceHandler.sendTrace('[ERROR]', `Fallback copy failed: ${err}`);
                    alert('Could not copy to clipboard. Please copy manually from browser console.');
                    console.log('diff-dom HTML:', text);
                }
                document.body.removeChild(textArea);
            }

        }

        // Initialize inspector when both DOM and diff-dom are ready
        let domReady = false;
        let diffDomReady = false;

        function checkInitialization() {
            if (domReady && diffDomReady && wsTraceHandler.ws && wsTraceHandler.ws.readyState === WebSocket.OPEN) {
                wsTraceHandler.sendTrace('[DEBUG]', 'All dependencies ready, initializing inspector');
                wsTraceHandler.sendTrace('[DEBUG]', `diff-dom available: ${typeof window.diffDom !== 'undefined'}`);
                if (typeof window.diffDom !== 'undefined') {
                    wsTraceHandler.sendTrace('[DEBUG]', 'diff-dom ESM loaded successfully');
                }
                window.gadInspector = new GadInspector();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            wsTraceHandler.sendTrace('[DEBUG]', 'DOM loaded, waiting for diff-dom ESM');
            domReady = true;
            checkInitialization();
        });

        window.addEventListener('diff-dom-ready', () => {
            wsTraceHandler.sendTrace('[DEBUG]', 'diff-dom ESM ready');
            diffDomReady = true;
            checkInitialization();
        });

        // Fallback timer in case WebSocket takes time
        setTimeout(checkInitialization, 1000);
    </script>
</body>
</html>
