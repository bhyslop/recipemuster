<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GAD Inspector</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .comparison-header {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }

        .status-section {
            background: #e8f4fd;
            border: 1px solid #b3d9ff;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
            display: none;
        }

        .dropdown-container {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 15px;
        }

        .dropdown-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .dropdown-group label {
            font-weight: 500;
            color: #555;
        }

        select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            min-width: 200px;
        }

        select:focus {
            border-color: #007acc;
            outline: none;
        }

        .rendered-pane {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 400px;
            line-height: 1.6;
        }

        .navigation-section {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
        }

        .nav-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-button {
            background: #007acc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .nav-button:hover {
            background: #005a9e;
        }

        .nav-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .change-counter {
            font-weight: 500;
            color: #555;
        }

        .console-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }

        .console-button:hover {
            background: #218838;
        }

        .commit-tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 14px;
            max-width: 400px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            line-height: 1.4;
            display: none;
        }

        .unchanged-commit {
            opacity: 0.6;
        }

        .unchanged-commit::after {
            content: " ≡";
            color: #888;
        }

        /* Diff styling - Block-level annotations with GADS-compliant deletions */
        .diff-deletion {
            background-color: #ffeef0;
            color: #d73a49;
            text-decoration: line-through;
            display: inline; /* Inline display for deletions */
            border: 1px solid #f97583;
            border-radius: 2px;
            padding: 1px 3px;
            margin: 0 2px;
        }

        .gad-deleted {
            background-color: #ffeef0;
            color: #d73a49;
            text-decoration: line-through;
            border: 1px solid #f97583;
            border-radius: 3px;
            padding: 8px 12px;
            margin: 8px 0;
            display: block;
            font-style: italic;
        }

        .gad-deleted::before {
            content: "[DELETED] ";
            font-weight: bold;
        }

        .diff-insertion {
            background-color: #f0fff4;
            border: 1px solid #28a745;
            border-radius: 3px;
            /* Block-level background highlighting */
            padding: 4px;
        }

        .diff-moved {
            background-color: #fff3cd;
            border: 1px solid #856404;
            border-radius: 3px;
            /* Block-level background highlighting */
            padding: 4px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .error {
            color: #d73a49;
            background: #ffeef0;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #f97583;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="comparison-header" id="comparisonHeader">GAD Inspector</div>
        <div class="status-section" id="statusSection"></div>

        <div class="dropdown-container">
            <div class="dropdown-group">
                <label for="fromDropdown">From:</label>
                <select id="fromDropdown">
                    <option value="">Loading...</option>
                </select>
            </div>

            <div class="dropdown-group">
                <label for="toDropdown">To:</label>
                <select id="toDropdown">
                    <option value="">Loading...</option>
                </select>
            </div>

            <button class="console-button" id="consoleButton">Copy WikiEd Diff</button>
        </div>
    </div>

    <div class="rendered-pane" id="renderedPane">
        <div class="loading">Loading manifest...</div>
    </div>

    <div class="navigation-section" id="navigationSection">
        <div class="nav-controls">
            <button class="nav-button" id="previousButton">Previous</button>
            <span class="change-counter" id="changeCounter">Change 0 of 0</span>
            <button class="nav-button" id="nextButton">Next</button>
        </div>
    </div>

    <div class="commit-tooltip" id="commitTooltip"></div>

    <script type="module">
        // Use ESM import for modern diff-dom
        import { DiffDOM } from 'https://cdn.skypack.dev/diff-dom@5.2.0';
        window.diffDom = { DiffDOM };
        console.log('[DEBUG] diff-dom loaded via ESM:', typeof DiffDOM);
        // Trigger initialization if DOM is already ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => window.dispatchEvent(new Event('diff-dom-ready')));
        } else {
            window.dispatchEvent(new Event('diff-dom-ready'));
        }
    </script>
    <script>
        // Trace buffer implementation per GADS specification
        class TraceBuffer {
            constructor() {
                this.maxEntries = 1000;
                this.storageKey = 'gad_trace_buffer';
                this.loadBuffer();
            }

            loadBuffer() {
                try {
                    const stored = sessionStorage.getItem(this.storageKey);
                    this.entries = stored ? JSON.parse(stored) : [];
                } catch (e) {
                    this.entries = [];
                }
            }

            saveBuffer() {
                try {
                    sessionStorage.setItem(this.storageKey, JSON.stringify(this.entries));
                } catch (e) {
                    console.warn('Failed to save trace buffer to sessionStorage');
                }
            }

            append(prefix, message) {
                const timestamp = new Date().toISOString();
                const entry = `${timestamp} ${prefix} ${message}`;
                this.entries.push(entry);

                // Maintain rolling buffer
                if (this.entries.length > this.maxEntries) {
                    this.entries = this.entries.slice(-this.maxEntries);
                }

                this.saveBuffer();
                console.log(entry);
            }

            getContents() {
                return this.entries.join('\n');
            }
        }

        const traceBuffer = new TraceBuffer();

        // WebSocket trace handler for GADS compliance
        class WebSocketTraceHandler {
            constructor() {
                this.ws = null;
                this.connect();
            }

            connect() {
                try {
                    const wsPort = window.location.port || 8080; // Use same port as HTTP
                    const wsUrl = `ws://${window.location.hostname}:${wsPort}/ws`;
                    console.log(`[DEBUG] Attempting WebSocket connection to: ${wsUrl}`);
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('[DEBUG] WebSocket connected');
                    };

                    this.ws.onerror = (error) => {
                        console.log('[DEBUG] WebSocket error:', error);
                    };

                    this.ws.onclose = () => {
                        console.log('[DEBUG] WebSocket disconnected');
                    };
                } catch (error) {
                    console.log('[DEBUG] WebSocket connection failed:', error);
                }
            }

            sendTrace(prefix, message) {
                // Send to WebSocket if connected
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    try {
                        this.ws.send(JSON.stringify({
                            type: 'trace',
                            message: `${prefix} ${message}`
                        }));
                    } catch (error) {
                        // Fallback to console only if WebSocket fails
                        console.log(`[WS-ERROR] ${prefix} ${message}`);
                    }
                } else {
                    // Fallback to console if WebSocket not connected
                    console.log(`[NO-WS] ${prefix} ${message}`);
                }
            }
        }

        const wsTraceHandler = new WebSocketTraceHandler();

        // GAD Inspector implementation
        class GadInspector {
            constructor() {
                this.manifest = null;
                this.currentChanges = [];
                this.currentChangeIndex = 0;
                this.lastDiffDomHtml = null;

                wsTraceHandler.sendTrace('[DEBUG]', 'GadInspector constructor called');
                this.initializeElements();
                this.setupEventListeners();
                this.loadManifest();
            }

            initializeElements() {
                wsTraceHandler.sendTrace('[DEBUG]', 'Initializing DOM elements');
                this.elements = {
                    comparisonHeader: document.getElementById('comparisonHeader'),
                    statusSection: document.getElementById('statusSection'),
                    fromDropdown: document.getElementById('fromDropdown'),
                    toDropdown: document.getElementById('toDropdown'),
                    renderedPane: document.getElementById('renderedPane'),
                    navigationSection: document.getElementById('navigationSection'),
                    previousButton: document.getElementById('previousButton'),
                    nextButton: document.getElementById('nextButton'),
                    changeCounter: document.getElementById('changeCounter'),
                    commitTooltip: document.getElementById('commitTooltip'),
                    consoleButton: document.getElementById('consoleButton')
                };

                // Check if all elements were found
                Object.entries(this.elements).forEach(([key, element]) => {
                    if (!element) {
                        wsTraceHandler.sendTrace('[ERROR]', `Failed to find DOM element: ${key}`);
                    }
                });
                wsTraceHandler.sendTrace('[DEBUG]', 'DOM elements initialized');
            }

            setupEventListeners() {
                this.elements.fromDropdown.addEventListener('change', () => this.onDropdownChange());
                this.elements.toDropdown.addEventListener('change', () => this.onDropdownChange());

                this.elements.previousButton.addEventListener('click', () => this.previousChange());
                this.elements.nextButton.addEventListener('click', () => this.nextChange());
                this.elements.consoleButton.addEventListener('click', () => this.copyDiffDomResult());


                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'j') this.nextChange();
                    if (e.key === 'k') this.previousChange();
                    if (e.key >= '1' && e.key <= '9') {
                        const index = parseInt(e.key) - 1;
                        if (index < this.currentChanges.length) {
                            this.currentChangeIndex = index;
                            this.highlightChange();
                        }
                    }
                });

                // Tooltip handling
                [this.elements.fromDropdown, this.elements.toDropdown].forEach(dropdown => {
                    dropdown.addEventListener('mouseover', (e) => this.showCommitTooltip(e));
                    dropdown.addEventListener('mouseout', () => this.hideCommitTooltip());
                });

                // Parse URL hash on load
                window.addEventListener('load', () => this.parseUrlHash());
                window.addEventListener('hashchange', () => this.parseUrlHash());
            }

            async loadManifest() {
                wsTraceHandler.sendTrace('[DEBUG]', 'Starting manifest load');
                wsTraceHandler.sendTrace('[MANIFEST]', 'Loading start');

                try {
                    wsTraceHandler.sendTrace('[DEBUG]', 'Fetching manifest.json');
                    wsTraceHandler.sendTrace('[DEBUG]', `Fetch URL: ${window.location.origin}/manifest.json`);
                    const response = await fetch('manifest.json');
                    wsTraceHandler.sendTrace('[DEBUG]', `Fetch response status: ${response.status}`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    wsTraceHandler.sendTrace('[DEBUG]', 'Parsing manifest JSON');
                    this.manifest = await response.json();
                    wsTraceHandler.sendTrace('[DEBUG]', `Manifest loaded successfully with ${this.manifest.commits.length} commits`);
                    wsTraceHandler.sendTrace('[MANIFEST]', `Successful load with ${this.manifest.commits.length} commits`);

                    wsTraceHandler.sendTrace('[DEBUG]', 'Starting populateDropdowns');
                    this.populateDropdowns();
                    wsTraceHandler.sendTrace('[DEBUG]', 'populateDropdowns completed');

                    wsTraceHandler.sendTrace('[DEBUG]', 'Starting parseUrlHash');
                    this.parseUrlHash();
                    wsTraceHandler.sendTrace('[DEBUG]', 'parseUrlHash completed');

                } catch (error) {
                    wsTraceHandler.sendTrace('[DEBUG]', `Manifest load failed: ${error.message}`);
                    wsTraceHandler.sendTrace('[MANIFEST]', `Load failure: ${error.message}`);
                    this.elements.renderedPane.innerHTML = `
                        <div class="error">
                            <h3>Failed to load manifest.json</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            }

            populateDropdowns() {
                wsTraceHandler.sendTrace('[DEBUG]', 'Clearing dropdown options');
                // Clear existing options
                this.elements.fromDropdown.innerHTML = '';
                this.elements.toDropdown.innerHTML = '';

                wsTraceHandler.sendTrace('[DEBUG]', 'Adding magic values to dropdowns');
                // Add magic values to from dropdown
                this.addOption(this.elements.fromDropdown, 'before-last', 'before-last (previous commit)');
                this.addOption(this.elements.fromDropdown, 'before-substantive', 'before-substantive (last different)');

                // Add magic value to to dropdown
                this.addOption(this.elements.toDropdown, 'latest', 'latest (newest commit)');

                wsTraceHandler.sendTrace('[DEBUG]', `Processing ${this.manifest.commits.length} commits for dropdowns`);
                // Add commits to both dropdowns
                this.manifest.commits.forEach((commit, index) => {
                    wsTraceHandler.sendTrace('[DEBUG]', `Processing commit ${index + 1}: ${commit.hash.substring(0, 8)}`);
                    const isUnchanged = index > 0 &&
                        commit.html_sha256 === this.manifest.commits[index - 1].html_sha256;

                    const shortHash = commit.hash.substring(0, 8);
                    const text = `${shortHash} - ${commit.message}`;

                    this.addOption(this.elements.fromDropdown, commit.hash, text, isUnchanged);
                    this.addOption(this.elements.toDropdown, commit.hash, text, isUnchanged);
                });
                wsTraceHandler.sendTrace('[DEBUG]', 'Dropdown population completed');
            }

            addOption(dropdown, value, text, isUnchanged = false) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = text;
                if (isUnchanged) {
                    option.className = 'unchanged-commit';
                }
                dropdown.appendChild(option);
            }

            parseUrlHash() {
                wsTraceHandler.sendTrace('[DEBUG]', `parseUrlHash called with hash: "${window.location.hash}"`);
                const hash = window.location.hash.substring(1);
                const params = new URLSearchParams(hash);

                const fromValue = params.get('from');
                const toValue = params.get('to');
                wsTraceHandler.sendTrace('[DEBUG]', `Parsed URL params - from: "${fromValue}", to: "${toValue}"`);

                if (fromValue) {
                    wsTraceHandler.sendTrace('[DEBUG]', `Setting fromDropdown to: ${fromValue}`);
                    this.elements.fromDropdown.value = fromValue;
                }
                if (toValue) {
                    wsTraceHandler.sendTrace('[DEBUG]', `Setting toDropdown to: ${toValue}`);
                    this.elements.toDropdown.value = toValue;
                }

                if (fromValue || toValue) {
                    wsTraceHandler.sendTrace('[DEBUG]', 'URL params found, calling performDiff');
                    this.performDiff();
                } else {
                    wsTraceHandler.sendTrace('[DEBUG]', 'No URL params found, not calling performDiff');
                }
            }

            onDropdownChange() {
                const fromValue = this.elements.fromDropdown.value;
                const toValue = this.elements.toDropdown.value;

                wsTraceHandler.sendTrace('[DROPDOWN]', `From changed to: ${fromValue}`);
                wsTraceHandler.sendTrace('[DROPDOWN]', `To changed to: ${toValue}`);

                this.updateUrlHash();
                this.performDiff();
            }

            updateUrlHash() {
                const fromValue = this.elements.fromDropdown.value;
                const toValue = this.elements.toDropdown.value;

                if (fromValue && toValue) {
                    window.location.hash = `from=${encodeURIComponent(fromValue)}&to=${encodeURIComponent(toValue)}`;
                }
            }

            async performDiff() {
                const fromValue = this.elements.fromDropdown.value;
                const toValue = this.elements.toDropdown.value;

                if (!fromValue || !toValue) return;

                try {
                    wsTraceHandler.sendTrace('[RESOLVE]', 'Magic value resolution start');

                    const fromCommit = this.resolveCommit(fromValue);
                    const toCommit = this.resolveCommit(toValue);

                    if (!fromCommit || !toCommit) {
                        wsTraceHandler.sendTrace('[ERROR]', 'Invalid magic values or missing commits in manifest');
                        throw new Error('Failed to resolve commits');
                    }

                    wsTraceHandler.sendTrace('[RESOLVE]', `Resolved from: ${fromCommit.hash.substring(0, 8)}, to: ${toCommit.hash.substring(0, 8)}`);

                    // Update comparison header
                    this.elements.comparisonHeader.textContent =
                        `${fromCommit.hash.substring(0, 8)} → ${toCommit.hash.substring(0, 8)}`;

                    // Check for identical SHA256
                    if (fromCommit.html_sha256 === toCommit.html_sha256) {
                        wsTraceHandler.sendTrace('[SHA256]', 'Detection of identical html_sha256 values between selected commits');
                        this.showStatusMessage('These commits have identical rendered content');
                    } else {
                        wsTraceHandler.sendTrace('[SHA256]', 'Detection of different html_sha256 values between selected commits');
                        this.hideStatusMessage();
                    }

                    await this.fetchAndDiff(fromCommit, toCommit);

                } catch (error) {
                    wsTraceHandler.sendTrace('[ERROR]', `Diff error: ${error.message}`);
                    this.elements.renderedPane.innerHTML = `
                        <div class="error">
                            <h3>Diff Error</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            }

            resolveCommit(value) {
                if (value === 'latest') {
                    return this.manifest.commits[this.manifest.commits.length - 1];
                } else if (value === 'before-last') {
                    return this.manifest.commits[this.manifest.commits.length - 2];
                } else if (value === 'before-substantive') {
                    const latest = this.manifest.commits[this.manifest.commits.length - 1];
                    let skippedCount = 0;
                    for (let i = this.manifest.commits.length - 2; i >= 0; i--) {
                        if (this.manifest.commits[i].html_sha256 !== latest.html_sha256) {
                            if (skippedCount > 0) {
                                wsTraceHandler.sendTrace('[RESOLVE]', `Skipped ${skippedCount} unchanged commits for before-substantive`);
                                this.showStatusMessage(`Skipped ${skippedCount} unchanged commits to find last substantive change`);
                            }
                            return this.manifest.commits[i];
                        }
                        skippedCount++;
                    }
                    return this.manifest.commits[0];
                } else {
                    return this.manifest.commits.find(c => c.hash === value);
                }
            }

            async fetchAndDiff(fromCommit, toCommit) {
                wsTraceHandler.sendTrace('[FETCH]', `HTML fetch start for ${fromCommit.html_file} and ${toCommit.html_file}`);

                try {
                    const [fromResponse, toResponse] = await Promise.all([
                        fetch(`/output/${fromCommit.html_file}`),
                        fetch(`/output/${toCommit.html_file}`)
                    ]);

                    if (!fromResponse.ok || !toResponse.ok) {
                        throw new Error('Failed to fetch HTML files');
                    }

                    const [fromHtml, toHtml] = await Promise.all([
                        fromResponse.text(),
                        toResponse.text()
                    ]);

                    wsTraceHandler.sendTrace('[FETCH]', 'Successful fetch completion');
                    wsTraceHandler.sendTrace('[DIFF]', 'Diff computation start');

                    // Use diff-dom library
                    const styledDiff = this.styleDiff(fromHtml, toHtml);

                    this.elements.renderedPane.innerHTML = styledDiff;

                    // Count changes for navigation - updated for GADS classifications
                    this.currentChanges = this.elements.renderedPane.querySelectorAll('.diff-deletion, .diff-insertion, .diff-moved');
                    this.currentChangeIndex = 0;

                    // Enhanced logging for Factory debugging
                    const changeTypeBreakdown = {
                        insertions: this.elements.renderedPane.querySelectorAll('.diff-insertion').length,
                        moves: this.elements.renderedPane.querySelectorAll('.diff-moved').length,
                        deletions: this.elements.renderedPane.querySelectorAll('.diff-deletion').length
                    };

                    // Debug trace for change counting
                    wsTraceHandler.sendTrace('[COUNT]', `Found ${this.currentChanges.length} total change elements in rendered output`);
                    wsTraceHandler.sendTrace('[COUNT]', `Breakdown: ${changeTypeBreakdown.insertions} insertions, ${changeTypeBreakdown.moves} moves, ${changeTypeBreakdown.deletions} deletions`);

                    wsTraceHandler.sendTrace('[DIFF]', `Completion with ${this.currentChanges.length} total changes`);
                    wsTraceHandler.sendTrace('[DIFF]', `Change breakdown: ${JSON.stringify(changeTypeBreakdown)}`);

                    this.updateNavigation();

                } catch (error) {
                    // Enhanced error reporting for Factory debugging
                    if (error.message.includes('diff-dom')) {
                        wsTraceHandler.sendTrace('[ERROR]', `diff-dom library failure: ${error.message}`);
                    } else if (error.message.includes('fetch') || error.message.includes('HTTP')) {
                        wsTraceHandler.sendTrace('[FETCH]', `Fetch failure: ${error.message}`);
                    } else {
                        wsTraceHandler.sendTrace('[ERROR]', `GADS processing failure: ${error.message}`);
                    }

                    // Additional debugging context
                    wsTraceHandler.sendTrace('[DEBUG]', `Error occurred during diff processing for commits: ${fromCommit?.hash?.substring(0,8)} → ${toCommit?.hash?.substring(0,8)}`);
                    throw error;
                }
            }

            styleDiff(fromHtml, toHtml) {
                const startTime = performance.now();
                wsTraceHandler.sendTrace('[DIFF]', 'Starting GADS-compliant 4-phase diff processing');
                wsTraceHandler.sendTrace('[DEBUG]', `Input sizes: fromHtml=${fromHtml.length} chars, toHtml=${toHtml.length} chars`);
                wsTraceHandler.sendTrace('[DEBUG]', `diff-dom type at diff time: ${typeof window.diffDom}`);

                if (typeof window.diffDom === 'undefined' || typeof window.diffDom.DiffDOM === 'undefined') {
                    throw new Error('diff-dom library not available - required for diff processing');
                }

                try {
                    // Phase 1: Block Identification
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 1: Block Identification start');
                    const fromDOM = this.createDOMFromHTML(fromHtml);
                    const toDOM = this.createDOMFromHTML(toHtml);
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 1: DOM trees created from HTML sources');

                    // Phase 2: diff-dom Processing
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 2: diff-dom Processing start');
                    const diffDOM = new window.diffDom.DiffDOM();
                    const diffOperations = diffDOM.diff(fromDOM, toDOM);
                    wsTraceHandler.sendTrace('[DIFF]', `Phase 2: Generated ${diffOperations.length} diff operations`);

                    // Phase 3: Operation Application
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 3: Operation Application start');
                    const operationResults = this.processOperations(diffOperations, toDOM);
                    wsTraceHandler.sendTrace('[DIFF]', `Phase 3: Processed ${operationResults.changes} operations`);

                    // Phase 4: Rendered Output
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 4: Rendered Output start');
                    const annotatedHtml = this.renderDiffDOM(toDOM, diffOperations);
                    this.lastDiffDomHtml = annotatedHtml; // Store for clipboard functionality
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 4: Rendered output completed');

                    // Performance logging for Factory debugging
                    const endTime = performance.now();
                    const totalTime = Math.round(endTime - startTime);
                    wsTraceHandler.sendTrace('[PERF]', `GADS diff processing completed in ${totalTime}ms`);

                    return annotatedHtml;

                } catch (error) {
                    wsTraceHandler.sendTrace('[ERROR]', `GADS diff processing failed: ${error.message}`);
                    throw error;
                }
            }

            // Phase 1: Block Identification - GADS compliant implementation
            identifyBlocks(html, source) {
                wsTraceHandler.sendTrace('[DEBUG]', `Block identification starting for ${source}`);

                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const blocks = [];

                // Target block-level elements per GADS specification
                const blockElements = ['P', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6',
                                      'LI', 'TD', 'TH', 'BLOCKQUOTE', 'PRE', 'SECTION', 'ARTICLE',
                                      'HEADER', 'FOOTER', 'NAV', 'ASIDE', 'MAIN'];

                const walker = doc.createTreeWalker(
                    doc.body || doc.documentElement,
                    NodeFilter.SHOW_ELEMENT,
                    {
                        acceptNode: function(node) {
                            return blockElements.includes(node.tagName) ?
                                NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
                        }
                    }
                );

                let node;
                let blockIndex = 0;
                while (node = walker.nextNode()) {
                    // Generate unique identifier based on element type, DOM path, and content
                    const domPath = this.getDomPath(node);
                    const textContent = node.textContent.trim();
                    const blockId = `${node.tagName}-${blockIndex}-${this.hashString(domPath + textContent)}`;

                    blocks.push({
                        id: blockId,
                        source: source,  // Track source separately
                        element: node,
                        tagName: node.tagName,
                        domPath: domPath,
                        textContent: textContent,
                        innerHTML: node.innerHTML,
                        index: blockIndex
                    });

                    blockIndex++;
                }

                wsTraceHandler.sendTrace('[DEBUG]', `Block identification completed for ${source}: ${blocks.length} blocks`);
                return blocks;
            }

            getDomPath(element) {
                const path = [];
                let current = element;
                while (current && current.nodeType === Node.ELEMENT_NODE) {
                    let selector = current.tagName.toLowerCase();
                    if (current.id) {
                        selector += '#' + current.id;
                    } else if (current.className) {
                        selector += '.' + current.className.split(/\s+/).join('.');
                    }
                    path.unshift(selector);
                    current = current.parentElement;
                }
                return path.join(' > ');
            }

            hashString(str) {
                // Simple hash function for unique identifiers
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash).toString(16);
            }

            linearizeBlocks(blocks) {
                wsTraceHandler.sendTrace('[DEBUG]', `Linearizing ${blocks.length} blocks`);

                // Create text linearization preserving block boundaries with identical separator markers
                const BLOCK_START = '⟨BLOCK⟩';
                const BLOCK_END = '⟨/BLOCK⟩';
                const linearized = blocks.map(block => {
                    return `${BLOCK_START}${block.textContent}${BLOCK_END}`;
                }).join('\n');

                wsTraceHandler.sendTrace('[DEBUG]', `Linearization completed, length: ${linearized.length}`);
                return linearized;
            }

            // Helper methods for diff-dom processing
            createDOMFromHTML(html) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                return doc.body;
            }

            processOperations(diffOperations, targetDOM) {
                wsTraceHandler.sendTrace('[DEBUG]', `Processing ${diffOperations.length} diff-dom operations`);

                let changeCount = 0;
                const processedOps = [];

                for (const op of diffOperations) {
                    wsTraceHandler.sendTrace('[RAW-OP]', `Raw diff-dom operation: name='${op.name}', route=[${(op.route || []).join(',')}]`);
                    
                    const processedOp = {
                        type: this.mapOperationType(op.name),
                        route: op.route || [],
                        element: op.element || null,
                        text: op.text || null,
                        oldValue: op.oldValue || null,
                        newValue: op.newValue || null
                    };

                    processedOps.push(processedOp);
                    changeCount++;
                }

                wsTraceHandler.sendTrace('[DEBUG]', `Processed ${changeCount} operations`);
                return { changes: changeCount, operations: processedOps };
            }

            mapOperationType(diffDomType) {
                const typeMap = {
                    'addElement': 'insert',
                    'removeElement': 'delete',
                    'relocateNode': 'move',
                    'modifyTextElement': 'modify'
                };
                const mapped = typeMap[diffDomType] || diffDomType;
                wsTraceHandler.sendTrace('[MAP]', `Mapped diff-dom type '${diffDomType}' to '${mapped}'`);
                return mapped;
            }

            renderDiffDOM(targetDOM, diffOperations) {
                wsTraceHandler.sendTrace('[DEBUG]', 'Rendering diff-dom operations to HTML');

                // Apply styling based on diff-dom operations
                const processedOps = this.processOperations(diffOperations, targetDOM);

                wsTraceHandler.sendTrace('[DEBUG]', `Processing ${processedOps.operations.length} diff operations for styling`);

                for (const op of processedOps.operations) {
                    if (op.type === 'insert') {
                        wsTraceHandler.sendTrace('[OP]', `Processing insert operation`);
                        this.styleInsertedElement(targetDOM, op);
                    } else if (op.type === 'delete') {
                        wsTraceHandler.sendTrace('[OP]', `Processing delete operation`);
                        this.createDeletionBlock(targetDOM, op);
                    } else if (op.type === 'move') {
                        wsTraceHandler.sendTrace('[OP]', `Processing move operation`);
                        this.styleMoveElement(targetDOM, op);
                    } else if (op.type === 'modify') {
                        wsTraceHandler.sendTrace('[OP]', `Processing modify operation`);
                        this.styleModifiedElement(targetDOM, op);
                    }
                }

                return targetDOM.innerHTML;
            }

            styleInsertedElement(dom, operation) {
                wsTraceHandler.sendTrace('[ROUTE]', `Looking for insert element with route: [${operation.route.join(',')}]`);
                const element = this.findElementByRoute(dom, operation.route);
                if (element) {
                    element.classList.add('diff-insertion');
                    element.style.backgroundColor = '#d4edda';
                    element.style.borderLeft = '4px solid #28a745';
                    wsTraceHandler.sendTrace('[STYLE]', `Applied diff-insertion class to element`);
                } else {
                    wsTraceHandler.sendTrace('[ROUTE]', `Failed to find insert element with route: [${operation.route.join(',')}]`);
                }
            }

            createDeletionBlock(dom, operation) {
                const deletionBlock = document.createElement('div');
                deletionBlock.classList.add('diff-deletion');
                deletionBlock.style.backgroundColor = '#f8d7da';
                deletionBlock.style.borderLeft = '4px solid #dc3545';
                deletionBlock.style.padding = '8px';
                deletionBlock.style.margin = '4px 0';
                wsTraceHandler.sendTrace('[STYLE]', `Created diff-deletion block`);

                if (operation.element) {
                    deletionBlock.innerHTML = operation.element.outerHTML || operation.text || 'Deleted content';
                } else {
                    deletionBlock.textContent = operation.text || 'Deleted content';
                }

                // Insert deletion block at route-specified location
                const insertPoint = this.findInsertionPoint(dom, operation.route);
                if (insertPoint) {
                    insertPoint.parentNode.insertBefore(deletionBlock, insertPoint);
                } else {
                    dom.appendChild(deletionBlock);
                }
            }

            styleMoveElement(dom, operation) {
                wsTraceHandler.sendTrace('[ROUTE]', `Looking for move element with route: [${operation.route.join(',')}]`);
                const element = this.findElementByRoute(dom, operation.route);
                if (element) {
                    element.classList.add('diff-moved');
                    element.style.backgroundColor = '#fff3cd';
                    element.style.borderLeft = '4px solid #ffc107';
                    wsTraceHandler.sendTrace('[STYLE]', `Applied diff-moved class to element`);
                } else {
                    wsTraceHandler.sendTrace('[ROUTE]', `Failed to find move element with route: [${operation.route.join(',')}]`);
                }
            }

            styleModifiedElement(dom, operation) {
                wsTraceHandler.sendTrace('[ROUTE]', `Looking for modify element with route: [${operation.route.join(',')}]`);
                const element = this.findElementByRoute(dom, operation.route);
                if (element) {
                    element.classList.add('diff-insertion');
                    element.style.backgroundColor = '#e2e3e5';
                    element.style.borderLeft = '4px solid #6c757d';
                    wsTraceHandler.sendTrace('[STYLE]', `Applied diff-insertion class to modified element`);
                } else {
                    wsTraceHandler.sendTrace('[ROUTE]', `Failed to find modify element with route: [${operation.route.join(',')}]`);
                }
            }

            findElementByRoute(dom, route) {
                let element = dom;
                for (const index of route) {
                    if (element.children && element.children[index]) {
                        element = element.children[index];
                    } else {
                        return null;
                    }
                }
                return element;
            }

            findInsertionPoint(dom, route) {
                if (route.length === 0) return dom.firstChild;

                let element = dom;
                for (let i = 0; i < route.length - 1; i++) {
                    if (element.children && element.children[route[i]]) {
                        element = element.children[route[i]];
                    } else {
                        return null;
                    }
                }

                const lastIndex = route[route.length - 1];
                return element.children ? element.children[lastIndex] : null;
            }

            // Phase 3: Block Classification with GADS hierarchy
            classifyBlocks(toBlocks, diffOperations, fromBlocks) {
                wsTraceHandler.sendTrace('[DEBUG]', 'Starting block classification with GADS hierarchy');

                const classifications = {};

                // Initialize all blocks as UNCHANGED
                toBlocks.forEach((block, index) => {
                    classifications[block.id] = 'UNCHANGED';
                });

                // Process operations to classify blocks by index
                // GADS hierarchy: MOVED > MODIFIED > INSERTED > UNCHANGED

                const blockOperations = {};
                diffOperations.forEach(op => {
                    if (op.blockIndex !== undefined && op.blockIndex < toBlocks.length) {
                        const blockId = toBlocks[op.blockIndex].id;
                        if (!blockOperations[blockId]) {
                            blockOperations[blockId] = [];
                        }
                        blockOperations[blockId].push(op.type);
                    }
                });

                // Apply classifications based on operation combinations
                Object.keys(blockOperations).forEach(blockId => {
                    const ops = blockOperations[blockId];
                    const uniqueOps = [...new Set(ops)];

                    if (uniqueOps.includes('move')) {
                        classifications[blockId] = 'MOVED';
                    } else if (uniqueOps.length > 1 || uniqueOps.includes('delete') || uniqueOps.includes('insert')) {
                        // Mixed operations indicate modification
                        classifications[blockId] = 'MODIFIED';
                    } else if (uniqueOps.includes('insert')) {
                        classifications[blockId] = 'INSERTED';
                    }
                });

                // Log classification summary
                const summary = {};
                Object.values(classifications).forEach(classification => {
                    summary[classification] = (summary[classification] || 0) + 1;
                });

                wsTraceHandler.sendTrace('[DEBUG]', `Block classification summary: ${JSON.stringify(summary)}`);
                return classifications;
            }

            // Phase 4: Rendered Output with deterministic deletion placement
            renderAnnotatedOutput(toHtml, toBlocks, blockClassifications, fromBlocks, diffOperations) {
                wsTraceHandler.sendTrace('[DEBUG]', 'Starting rendered output generation');

                // Create new DOM structure to avoid iterator invalidation (GADS safe processing)
                const parser = new DOMParser();
                const targetDoc = parser.parseFromString(toHtml, 'text/html');

                // Apply block-level classifications
                toBlocks.forEach(block => {
                    const classification = blockClassifications[block.id];
                    const targetElement = this.findElementInDoc(targetDoc, block);

                    if (targetElement && classification !== 'UNCHANGED') {
                        // Apply CSS class based on classification
                        const cssClass = this.getClassificationCssClass(classification);
                        targetElement.classList.add(cssClass);
                        wsTraceHandler.sendTrace('[DEBUG]', `Applied ${cssClass} to block ${block.id}`);
                    }
                });

                // Process deletion blocks with deterministic placement
                const deletionOperations = diffOperations.filter(op => op.type === 'delete');
                this.placeDeletionBlocks(targetDoc, deletionOperations, fromBlocks, toBlocks);

                return targetDoc.body.innerHTML || targetDoc.documentElement.innerHTML;
            }

            findElementInDoc(doc, block) {
                // Find matching element in new document by DOM path and content
                const elements = doc.querySelectorAll(block.tagName.toLowerCase());
                for (let element of elements) {
                    if (element.textContent.trim() === block.textContent) {
                        return element;
                    }
                }
                return null;
            }

            getClassificationCssClass(classification) {
                switch (classification) {
                    case 'INSERTED': return 'diff-insertion';
                    case 'MOVED': return 'diff-moved';
                    case 'MODIFIED': return 'diff-insertion'; // Use insertion styling for modified
                    default: return '';
                }
            }

            // GADS-compliant deterministic deletion placement algorithm
            placeDeletionBlocks(targetDoc, deletionOperations, fromBlocks, toBlocks) {
                wsTraceHandler.sendTrace('[DEBUG]', `Placing ${deletionOperations.length} deletion blocks`);

                deletionOperations.forEach((deleteOp, index) => {
                    const deletedBlockId = deleteOp.blockId;
                    if (!deletedBlockId) {
                        wsTraceHandler.sendTrace('[DEBUG]', `Skipping deletion ${index}: no block ID`);
                        return;
                    }

                    const deletedBlock = fromBlocks.find(b => b.id === deletedBlockId);
                    if (!deletedBlock) {
                        wsTraceHandler.sendTrace('[DEBUG]', `Skipping deletion ${index}: block not found`);
                        return;
                    }

                    // Find anchor for deterministic placement
                    const anchor = this.findDeletionAnchor(deletedBlock, fromBlocks, toBlocks, targetDoc);

                    if (anchor.element && anchor.position) {
                        this.insertDeletionBlock(targetDoc, deletedBlock, anchor.element, anchor.position);
                        wsTraceHandler.sendTrace('[DEBUG]', `Placed deletion block ${deletedBlockId} ${anchor.position} anchor`);
                    } else {
                        // Boundary fallback
                        this.insertDeletionBlockAtBoundary(targetDoc, deletedBlock, deletedBlock.index);
                        wsTraceHandler.sendTrace('[DEBUG]', `Placed deletion block ${deletedBlockId} at boundary fallback`);
                    }
                });
            }

            // GADS anchor algorithm: Primary -> Secondary -> Boundary
            findDeletionAnchor(deletedBlock, fromBlocks, toBlocks, targetDoc) {
                // Primary anchor: Find next surviving block
                const nextSurvivingBlock = this.findNextSurvivingBlock(deletedBlock, fromBlocks, toBlocks);
                if (nextSurvivingBlock) {
                    const anchorElement = this.findElementInDoc(targetDoc, nextSurvivingBlock);
                    if (anchorElement) {
                        return { element: anchorElement, position: 'before' };
                    }
                }

                // Secondary anchor: Find previous surviving block
                const prevSurvivingBlock = this.findPreviousSurvivingBlock(deletedBlock, fromBlocks, toBlocks);
                if (prevSurvivingBlock) {
                    const anchorElement = this.findElementInDoc(targetDoc, prevSurvivingBlock);
                    if (anchorElement) {
                        return { element: anchorElement, position: 'after' };
                    }
                }

                // Boundary fallback
                return { element: null, position: null };
            }

            findNextSurvivingBlock(deletedBlock, fromBlocks, toBlocks) {
                const startIndex = deletedBlock.index + 1;
                for (let i = startIndex; i < fromBlocks.length; i++) {
                    const candidate = fromBlocks[i];
                    // Check if this block survived in toBlocks
                    if (toBlocks.some(toBlock => this.blocksMatch(candidate, toBlock))) {
                        return candidate;
                    }
                }
                return null;
            }

            findPreviousSurvivingBlock(deletedBlock, fromBlocks, toBlocks) {
                const startIndex = deletedBlock.index - 1;
                for (let i = startIndex; i >= 0; i--) {
                    const candidate = fromBlocks[i];
                    // Check if this block survived in toBlocks
                    if (toBlocks.some(toBlock => this.blocksMatch(candidate, toBlock))) {
                        return candidate;
                    }
                }
                return null;
            }

            blocksMatch(fromBlock, toBlock) {
                // Simple content-based matching
                return fromBlock.textContent === toBlock.textContent &&
                       fromBlock.tagName === toBlock.tagName;
            }

            insertDeletionBlock(targetDoc, deletedBlock, anchorElement, position) {
                const deletionDiv = targetDoc.createElement('div');
                deletionDiv.className = 'diff-deletion gad-deleted';
                deletionDiv.textContent = deletedBlock.textContent;

                if (position === 'before') {
                    anchorElement.parentNode.insertBefore(deletionDiv, anchorElement);
                } else if (position === 'after') {
                    anchorElement.parentNode.insertBefore(deletionDiv, anchorElement.nextSibling);
                }
            }

            insertDeletionBlockAtBoundary(targetDoc, deletedBlock, originalIndex) {
                const deletionDiv = targetDoc.createElement('div');
                deletionDiv.className = 'diff-deletion gad-deleted';
                deletionDiv.textContent = deletedBlock.textContent;

                const body = targetDoc.body || targetDoc.documentElement;
                if (originalIndex === 0) {
                    // Insert at document start
                    body.insertBefore(deletionDiv, body.firstChild);
                } else {
                    // Insert at document end
                    body.appendChild(deletionDiv);
                }
            }

            updateNavigation() {
                if (this.currentChanges.length > 0) {
                    this.elements.navigationSection.style.display = 'block';
                    this.elements.changeCounter.textContent =
                        `Change ${this.currentChangeIndex + 1} of ${this.currentChanges.length}`;

                    this.elements.previousButton.disabled = this.currentChangeIndex === 0;
                    this.elements.nextButton.disabled = this.currentChangeIndex === this.currentChanges.length - 1;

                    this.highlightChange();
                } else {
                    this.elements.navigationSection.style.display = 'none';
                }
            }

            highlightChange() {
                // Remove previous highlights
                this.currentChanges.forEach(change => {
                    change.style.outline = '';
                });

                // Highlight current change
                if (this.currentChanges[this.currentChangeIndex]) {
                    const currentChange = this.currentChanges[this.currentChangeIndex];
                    currentChange.style.outline = '2px solid #007acc';
                    currentChange.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            previousChange() {
                if (this.currentChangeIndex > 0) {
                    this.currentChangeIndex--;
                    this.updateNavigation();
                }
            }

            nextChange() {
                if (this.currentChangeIndex < this.currentChanges.length - 1) {
                    this.currentChangeIndex++;
                    this.updateNavigation();
                }
            }

            showStatusMessage(message) {
                this.elements.statusSection.textContent = message;
                this.elements.statusSection.style.display = 'block';
            }

            hideStatusMessage() {
                this.elements.statusSection.style.display = 'none';
            }

            showCommitTooltip(event) {
                const option = event.target.selectedOptions[0];
                if (!option || option.value === '') return;

                const commit = this.resolveCommit(option.value);
                if (!commit) return;

                this.elements.commitTooltip.innerHTML = `
                    <div><strong>${commit.hash}</strong></div>
                    <div>${commit.message}</div>
                `;

                this.elements.commitTooltip.style.display = 'block';
                this.elements.commitTooltip.style.left = event.pageX + 10 + 'px';
                this.elements.commitTooltip.style.top = event.pageY - 10 + 'px';
            }

            hideCommitTooltip() {
                this.elements.commitTooltip.style.display = 'none';
            }

            copyDiffDomResult() {
                if (!this.lastDiffDomHtml) {
                    alert('No diff-dom result available. Please select different commits first.');
                    return;
                }

                // Copy to clipboard using modern API
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(this.lastDiffDomHtml).then(() => {
                        wsTraceHandler.sendTrace('[DEBUG]', 'diff-dom HTML copied to clipboard');
                        // Briefly change button text to show success
                        const originalText = this.elements.consoleButton.textContent;
                        this.elements.consoleButton.textContent = 'Copied!';
                        setTimeout(() => {
                            this.elements.consoleButton.textContent = originalText;
                        }, 1000);
                    }).catch(err => {
                        wsTraceHandler.sendTrace('[ERROR]', `Failed to copy to clipboard: ${err}`);
                        this.fallbackCopyToClipboard(this.lastDiffDomHtml);
                    });
                } else {
                    // Fallback for non-secure contexts
                    this.fallbackCopyToClipboard(this.lastDiffDomHtml);
                }
            }

            fallbackCopyToClipboard(text) {
                // Create temporary textarea for fallback copy
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    wsTraceHandler.sendTrace('[DEBUG]', 'diff-dom HTML copied to clipboard (fallback)');
                    // Briefly change button text to show success
                    const originalText = this.elements.consoleButton.textContent;
                    this.elements.consoleButton.textContent = 'Copied!';
                    setTimeout(() => {
                        this.elements.consoleButton.textContent = originalText;
                    }, 1000);
                } catch (err) {
                    wsTraceHandler.sendTrace('[ERROR]', `Fallback copy failed: ${err}`);
                    alert('Could not copy to clipboard. Please copy manually from browser console.');
                    console.log('diff-dom HTML:', text);
                }
                document.body.removeChild(textArea);
            }

        }

        // Initialize inspector when both DOM and diff-dom are ready
        let domReady = false;
        let diffDomReady = false;

        function checkInitialization() {
            if (domReady && diffDomReady && wsTraceHandler.ws && wsTraceHandler.ws.readyState === WebSocket.OPEN) {
                wsTraceHandler.sendTrace('[DEBUG]', 'All dependencies ready, initializing inspector');
                wsTraceHandler.sendTrace('[DEBUG]', `diff-dom available: ${typeof window.diffDom !== 'undefined'}`);
                if (typeof window.diffDom !== 'undefined') {
                    wsTraceHandler.sendTrace('[DEBUG]', 'diff-dom ESM loaded successfully');
                }
                window.gadInspector = new GadInspector();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            wsTraceHandler.sendTrace('[DEBUG]', 'DOM loaded, waiting for diff-dom ESM');
            domReady = true;
            checkInitialization();
        });

        window.addEventListener('diff-dom-ready', () => {
            wsTraceHandler.sendTrace('[DEBUG]', 'diff-dom ESM ready');
            diffDomReady = true;
            checkInitialization();
        });

        // Fallback timer in case WebSocket takes time
        setTimeout(checkInitialization, 1000);
    </script>
</body>
</html>
