<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GAD Inspector</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }


        .status-section {
            background: #e8f4fd;
            border: 1px solid #b3d9ff;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
            display: none;
        }

        .workspace {
            display: grid;
            grid-template-columns: auto auto 1fr;
            grid-template-rows: auto 1fr;
            grid-template-areas: 
                "railheader railheader renderheader"
                "from to render";
            gap: 0px;
            height: calc(100vh - 100px);
            margin-top: 20px;
        }

        .rail-header {
            grid-area: railheader;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: white;
            border-radius: 8px 8px 0 0;
            padding: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-bottom: 1px solid #eee;
            border-right: 1px solid #eee;
            font-weight: bold;
            color: #666;
        }

        .render-header {
            grid-area: renderheader;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border-radius: 8px 8px 0 0;
            padding: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-bottom: 1px solid #eee;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            color: #333;
        }

        .rail {
            background: white;
            border-radius: 0 0 8px 8px;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-y: auto;
            max-height: 100%;
        }

        .rail.from {
            grid-area: from;
            border-top-left-radius: 0;
            border-right: 1px solid #eee;
        }

        .rail.to {
            grid-area: to;
            border-top-right-radius: 0;
        }

        .rail-row {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 2px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .rail-row:hover {
            background-color: #f8f9fa;
        }

        .rail-row.selected {
            background-color: #e3f2fd;
            border: 1px solid #2196f3;
        }

        .rail-label {
            min-width: 30px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            font-weight: bold;
            color: #666;
            text-align: center;
        }

        .rail-radio {
            margin-left: auto;
        }

        .rail-commit-info {
            flex: 1;
            margin-left: 10px;
        }

        .rail-hash {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            color: #333;
        }

        .unchanged-rail-row {
            opacity: 0.6;
        }

        .unchanged-rail-row .rail-hash::after {
            content: " ≡";
            color: #888;
        }

        .rendered-pane {
            grid-area: render;
            background: white;
            border-radius: 0 0 8px 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-y: auto;
            max-height: 100%;
            line-height: 1.6;
        }

        .popover {
            position: fixed;
            background: white;
            border: 2px solid #007acc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 15px;
            z-index: 1000;
            display: none;
            max-width: 400px;
            min-width: 300px;
            font-size: 13px;
        }

        .popover-header {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        .popover-field {
            margin-bottom: 8px;
        }

        .popover-label {
            font-weight: bold;
            color: #555;
            font-size: 11px;
        }

        .popover-value {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: #f6f8fa;
            padding: 4px 6px;
            border-radius: 3px;
            border: 1px solid #e1e4e8;
            margin-top: 3px;
            word-break: break-all;
            font-size: 10px;
        }

        .swap-button {
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            margin: 0 6px;
        }

        .swap-button:hover {
            background: #005a9e;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .swap-button:active {
            transform: scale(0.95);
        }




        .unchanged-commit {
            opacity: 0.6;
        }

        .unchanged-commit::after {
            content: " ≡";
            color: #888;
        }

        /* Simplified deletion styling - inline struck-through text with minimal red highlight */
        .diff-deletion {
            background-color: #ffeef0;
            color: #d73a49;
            text-decoration: line-through;
            display: inline;
        }

        .diff-deletion-inline {
            background-color: #ffeef0;
            color: #d73a49;
            text-decoration: line-through;
            display: inline;
        }

        .diff-insertion {
            background-color: #f0fff4;
            border: 1px solid #28a745;
            border-radius: 3px;
            /* Block-level background highlighting */
            padding: 4px;
        }

        .diff-moved {
            background-color: #fff3cd;
            border: 1px solid #856404;
            border-radius: 3px;
            /* Block-level background highlighting */
            padding: 4px;
        }

        .diff-modification {
            background-color: #e2e3e5;
            border: 1px solid #6c757d;
            border-radius: 3px;
            /* Block-level background highlighting for text changes */
            padding: 4px;
        }

        /* Simplified coalescing - single consolidated elements only */
        /* Adjacent same-type diff elements are replaced with single consolidated spans */
        /* No additional CSS needed - existing .diff-insertion, .diff-moved, etc. styles apply */

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .error {
            color: #d73a49;
            background: #ffeef0;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #f97583;
        }
    </style>
</head>
<body>
    <div class="status-section" id="statusSection"></div>

    <div class="workspace">
        <div class="rail-header">
            F <button class="swap-button" id="swapButton" title="Transpose rail positions">⇄</button> T
        </div>

        <div class="render-header" id="comparisonHeader">
            <!-- Commit comparison will be displayed here -->
        </div>

        <div class="rail from" id="fromRail">
            <div id="fromRailContent">
                <div class="loading">Loading...</div>
            </div>
        </div>

        <div class="rail to" id="toRail">
            <div id="toRailContent">
                <div class="loading">Loading...</div>
            </div>
        </div>

        <div class="rendered-pane" id="renderedPane">
            <div class="loading">Loading manifest...</div>
        </div>
    </div>

    <div class="popover" id="commitPopover">
        <div class="popover-header">Commit Details</div>
        <div id="commitPopoverContent">
        </div>
    </div>

    <script type="module">
        // Use ESM import for modern diff-dom
        import { DiffDOM } from 'https://cdn.skypack.dev/diff-dom@5.2.0';
        window.diffDom = { DiffDOM };
        console.log('[DEBUG] diff-dom loaded via ESM:', typeof DiffDOM);
        // Trigger initialization if DOM is already ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => window.dispatchEvent(new Event('diff-dom-ready')));
        } else {
            window.dispatchEvent(new Event('diff-dom-ready'));
        }
    </script>
    <script>
        // Trace buffer implementation per GADS specification
        class TraceBuffer {
            constructor() {
                this.maxEntries = 1000;
                this.storageKey = 'gad_trace_buffer';
                this.loadBuffer();
            }

            loadBuffer() {
                try {
                    const stored = sessionStorage.getItem(this.storageKey);
                    this.entries = stored ? JSON.parse(stored) : [];
                } catch (e) {
                    this.entries = [];
                }
            }

            saveBuffer() {
                try {
                    sessionStorage.setItem(this.storageKey, JSON.stringify(this.entries));
                } catch (e) {
                    console.warn('Failed to save trace buffer to sessionStorage');
                }
            }

            append(prefix, message) {
                const timestamp = new Date().toISOString();
                const entry = `${timestamp} ${prefix} ${message}`;
                this.entries.push(entry);

                // Maintain rolling buffer
                if (this.entries.length > this.maxEntries) {
                    this.entries = this.entries.slice(-this.maxEntries);
                }

                this.saveBuffer();
                console.log(entry);
            }

            getContents() {
                return this.entries.join('\n');
            }
        }

        const traceBuffer = new TraceBuffer();

        // WebSocket trace handler for GADS compliance
        class WebSocketTraceHandler {
            constructor() {
                this.ws = null;
                // Don't connect immediately - wait for successful manifest fetch
            }

            connectAfterManifest() {
                // Only attempt connection after successful manifest fetch (GADS compliant)
                try {
                    const wsPort = window.location.port || 8080; // Use same port as HTTP
                    const wsUrl = `ws://${window.location.hostname}:${wsPort}/ws`;
                    console.log(`[DEBUG] Factory available, attempting WebSocket connection to: ${wsUrl}`);
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('[DEBUG] WebSocket connected after manifest success');
                    };

                    this.ws.onerror = (error) => {
                        console.log('[DEBUG] WebSocket error (non-fatal):', error);
                    };

                    this.ws.onclose = () => {
                        console.log('[DEBUG] WebSocket disconnected');
                    };
                } catch (error) {
                    console.log('[DEBUG] WebSocket connection failed (non-fatal):', error);
                }
            }

            connect() {
                // Legacy method - should not be called in GADS compliant flow
                console.warn('[WARN] connect() called - should use connectAfterManifest() per GADS specification');
                this.connectAfterManifest();
            }

            sendTrace(prefix, message) {
                // Always log to console, send to WebSocket if available
                console.log(`${prefix} ${message}`);

                // Send to WebSocket if connected
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    try {
                        this.ws.send(JSON.stringify({
                            type: 'trace',
                            message: `${prefix} ${message}`
                        }));
                    } catch (error) {
                        // WebSocket error is not critical
                        console.log(`[WS-ERROR] Failed to send trace: ${error}`);
                    }
                }
            }

            sendDebugOutput(debugType, content, fromCommit, toCommit, sourceFiles) {
                // Consolidated debug output sender for all 8-phase debug artifacts
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    try {
                        const timestamp = new Date().toISOString().replace(/[-:]/g, '').replace(/\..+/, '');
                        const fromHash = fromCommit ? fromCommit.hash.substring(0, 12) : 'unknown';
                        const toHash = toCommit ? toCommit.hash.substring(0, 12) : 'unknown';
                        
                        // Determine file extension based on debug type
                        const fileExtension = debugType.includes('dft') ? 'json' : 'html';
                        const filename = `debug-${debugType}-${fromHash}-${toHash}-${timestamp}.${fileExtension}`;
                        
                        this.ws.send(JSON.stringify({
                            type: 'debug_output',
                            debug_type: debugType,
                            content: content,
                            filename_pattern: filename,
                            source_files: sourceFiles || []
                        }));
                        console.log(`[DEBUG-OUTPUT] Sent ${debugType} debug data to Factory for ${filename} creation`);
                    } catch (error) {
                        console.log(`[WS-ERROR] Failed to send ${debugType} debug output: ${error}`);
                    }
                }
                // Silent if WebSocket not available - this is optional functionality
            }

            // Legacy method for backwards compatibility
            sendRenderedContent(htmlContent, fromCommit, toCommit, sourceFiles) {
                this.sendDebugOutput('rendered', htmlContent, fromCommit, toCommit, sourceFiles);
            }

            // Legacy method for backwards compatibility  
            sendAnnotatedDOM(htmlContent, fromCommit, toCommit, sourceFiles) {
                this.sendDebugOutput('annotated', htmlContent, fromCommit, toCommit, sourceFiles);
            }
        }

        const wsTraceHandler = new WebSocketTraceHandler();

        // GAD Inspector implementation
        class GadInspector {
            constructor() {
                this.manifest = null;
                this.currentChanges = [];
                this.currentChangeIndex = 0;

                console.log('[DEBUG] GadInspector constructor called');
                this.initializeElements();
                this.setupEventListeners();
                this.loadManifest();
            }

            initializeElements() {
                console.log('[DEBUG] Initializing DOM elements');
                this.elements = {
                    comparisonHeader: document.getElementById('comparisonHeader'),
                    statusSection: document.getElementById('statusSection'),
                    fromRail: document.getElementById('fromRail'),
                    fromRailContent: document.getElementById('fromRailContent'),
                    toRail: document.getElementById('toRail'),
                    toRailContent: document.getElementById('toRailContent'),
                    swapButton: document.getElementById('swapButton'),
                    renderedPane: document.getElementById('renderedPane'),
                    commitPopover: document.getElementById('commitPopover'),
                    commitPopoverContent: document.getElementById('commitPopoverContent'),
                };

                // Initialize selections
                this.selectedFrom = null;
                this.selectedTo = null;

                // Check if all elements were found
                Object.entries(this.elements).forEach(([key, element]) => {
                    if (!element) {
                        console.log(`[ERROR] Failed to find DOM element: ${key}`);
                    }
                });
                console.log('[DEBUG] DOM elements initialized');
            }

            setupEventListeners() {
                this.elements.swapButton.addEventListener('click', () => this.onSwapClick());

                // Rail hover for popover display
                let hoverTimeout;
                let currentHoveredRow = null;

                [this.elements.fromRail, this.elements.toRail].forEach(rail => {
                    rail.addEventListener('mouseover', (e) => {
                        const railRow = e.target.closest('.rail-row');
                        if (!railRow) return;

                        // Clear any existing timeout
                        if (hoverTimeout) {
                            clearTimeout(hoverTimeout);
                        }

                        currentHoveredRow = railRow;

                        // Show popover after 200ms delay (GADS compliant)
                        hoverTimeout = setTimeout(() => {
                            this.showCommitPopover(e, railRow);
                        }, 200);
                    });

                    rail.addEventListener('mouseout', (e) => {
                        const railRow = e.target.closest('.rail-row');
                        if (!railRow) return;

                        // Clear timeout if mouse leaves before delay
                        if (hoverTimeout) {
                            clearTimeout(hoverTimeout);
                            hoverTimeout = null;
                        }

                        currentHoveredRow = null;

                        // Hide popover immediately (GADS compliant)
                        this.hideCommitPopover();
                    });
                });

                // Initialize URL state tracking
                this.suppressUrlUpdate = false;

                // Parse URL state on browser navigation (back/forward)
                window.addEventListener('popstate', () => this.parseUrlState());
            }

            async loadManifest() {
                wsTraceHandler.sendTrace('[DEBUG]', 'Starting manifest load');
                wsTraceHandler.sendTrace('[MANIFEST]', 'Loading start');

                try {
                    wsTraceHandler.sendTrace('[DEBUG]', 'Fetching manifest.json');
                    wsTraceHandler.sendTrace('[DEBUG]', `Fetch URL: ${window.location.origin}/manifest.json`);
                    const response = await fetch('manifest.json');
                    wsTraceHandler.sendTrace('[DEBUG]', `Fetch response status: ${response.status}`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    wsTraceHandler.sendTrace('[DEBUG]', 'Parsing manifest JSON');
                    this.manifest = await response.json();
                    wsTraceHandler.sendTrace('[DEBUG]', `Manifest loaded successfully with ${this.manifest.commits.length} commits`);
                    wsTraceHandler.sendTrace('[MANIFEST]', `Successful load with ${this.manifest.commits.length} commits`);

                    // Now that Factory is confirmed available, attempt WebSocket connection
                    wsTraceHandler.connectAfterManifest();

                    wsTraceHandler.sendTrace('[DEBUG]', 'Starting populateRails');
                    this.populateRails();
                    wsTraceHandler.sendTrace('[DEBUG]', 'populateRails completed');

                    wsTraceHandler.sendTrace('[DEBUG]', 'Starting parseUrlState');
                    this.parseUrlState();
                    wsTraceHandler.sendTrace('[DEBUG]', 'parseUrlState completed');

                } catch (error) {
                    wsTraceHandler.sendTrace('[DEBUG]', `Manifest load failed: ${error.message}`);
                    wsTraceHandler.sendTrace('[MANIFEST]', `Load failure: ${error.message}`);
                    this.elements.renderedPane.innerHTML = `
                        <div class="error">
                            <h3>Failed to load manifest.json</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            }

            populateRails() {
                wsTraceHandler.sendTrace('[DEBUG]', 'Clearing rail content');
                // Clear existing content
                this.elements.fromRailContent.innerHTML = '';
                this.elements.toRailContent.innerHTML = '';

                wsTraceHandler.sendTrace('[DEBUG]', 'Rails will be populated with commits only (no magic values)');

                wsTraceHandler.sendTrace('[DEBUG]', `Processing ${this.manifest.commits.length} commits for rails`);
                // Reverse commits first, then apply simple labeling like GADMRC
                const reversedCommits = [...this.manifest.commits].reverse();
                reversedCommits.forEach((commit, index) => {
                    wsTraceHandler.sendTrace('[DEBUG]', `Processing commit ${index + 1}: ${commit.hash.substring(0, 8)}`);
                    const isUnchanged = index > 0 &&
                        commit.html_sha256 === reversedCommits[index - 1].html_sha256;

                    // GADMRC-compliant labeling: H for index 0, -1, -2, etc. for rest
                    const position = index === 0 ? 'H' : `-${index}`;

                    // Use position as the value, store commit data in dataset (no hash display)
                    this.addRailRow(this.elements.fromRailContent, position, position, 'from', null, isUnchanged, commit);
                    this.addRailRow(this.elements.toRailContent, position, position, 'to', null, isUnchanged, commit);
                });
                wsTraceHandler.sendTrace('[DEBUG]', 'Rail population completed');
                
                // Set default selections per GADS spec: From = -1, To = H
                this.setDefaultSelections();
            }
            
            setDefaultSelections() {
                // Only set defaults if no current selections AND no URL params present
                const searchParams = new URLSearchParams(window.location.search);
                const hasUrlParams = searchParams.get('from') || searchParams.get('to');
                
                if (!this.selectedFrom && !this.selectedTo && !hasUrlParams) {
                    wsTraceHandler.sendTrace('[DEBUG]', 'No selections and no URL params - setting default selections: From = -1, To = H');
                    this.setRailSelection('from', '-1', true);  // Skip diff on first
                    this.setRailSelection('to', 'H', false);    // Perform diff on second
                } else {
                    wsTraceHandler.sendTrace('[DEBUG]', `Skipping defaults - selections: from=${this.selectedFrom}, to=${this.selectedTo}, urlParams=${hasUrlParams}`);
                }
            }

            addRailRow(railContent, value, label, railType, hashText = null, isUnchanged = false, commit = null) {
                const row = document.createElement('div');
                row.className = 'rail-row' + (isUnchanged ? ' unchanged-rail-row' : '');
                row.dataset.value = value;
                row.dataset.railType = railType;
                
                // Store commit data for position resolution
                if (commit) {
                    row.dataset.commitHash = commit.hash;
                    row.dataset.commitData = JSON.stringify(commit);
                }

                const labelElement = document.createElement('div');
                labelElement.className = 'rail-label';
                labelElement.textContent = label;

                const commitInfo = document.createElement('div');
                commitInfo.className = 'rail-commit-info';
                
                // GADMRC-compliant: show only position labels, no hash text in rails
                if (hashText) {
                    const hashElement = document.createElement('div');
                    hashElement.className = 'rail-hash';
                    hashElement.textContent = hashText;
                    commitInfo.appendChild(hashElement);
                } else {
                    // Empty info div - position label is sufficient
                    commitInfo.style.display = 'none';
                }

                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = railType + 'Selection';
                radio.className = 'rail-radio';
                radio.value = value;

                // Add click handler for selection
                row.addEventListener('click', () => {
                    this.selectRailRow(row, railType);
                });

                radio.addEventListener('change', () => {
                    if (radio.checked) {
                        this.selectRailRow(row, railType);
                    }
                });

                row.appendChild(labelElement);
                row.appendChild(commitInfo);
                row.appendChild(radio);

                railContent.appendChild(row);
            }

            selectRailRow(row, railType, skipDiff = false) {
                const value = row.dataset.value;
                
                // Clear previous selection in this rail
                const railContent = railType === 'from' ? this.elements.fromRailContent : this.elements.toRailContent;
                railContent.querySelectorAll('.rail-row').forEach(r => r.classList.remove('selected'));
                
                // Set new selection
                row.classList.add('selected');
                const radio = row.querySelector('.rail-radio');
                if (radio) radio.checked = true;

                // Store selection
                const previousValue = railType === 'from' ? this.selectedFrom : this.selectedTo;
                if (railType === 'from') {
                    this.selectedFrom = value;
                } else {
                    this.selectedTo = value;
                }

                wsTraceHandler.sendTrace('[SELECTION]', `${railType} rail selected: ${value}`);
                
                // Only update URL and perform diff if selection changed, not skipped, and not suppressed
                if (previousValue !== value && !skipDiff && !this.suppressUrlUpdate) {
                    this.writeUrlState();
                    this.performDiff();
                }
            }

            setRailSelection(railType, value, skipDiff = false) {
                const railContent = railType === 'from' ? this.elements.fromRailContent : this.elements.toRailContent;
                const targetRow = railContent.querySelector(`[data-value="${value}"]`);
                
                if (targetRow) {
                    this.selectRailRow(targetRow, railType, skipDiff);
                } else {
                    wsTraceHandler.sendTrace('[DEBUG]', `Rail row not found for value: ${value} in ${railType} rail`);
                }
            }

            parseHashParams() {
                // Fix: Parse hash fragment as URL parameters per GADS spec
                const hash = window.location.hash;
                if (!hash || hash === '#') {
                    return new Map();
                }
                
                const paramString = hash.substring(1); // Remove leading #
                const params = new Map();
                
                if (paramString) {
                    const pairs = paramString.split('&');
                    for (const pair of pairs) {
                        const [key, value] = pair.split('=');
                        if (key && value) {
                            params.set(decodeURIComponent(key), decodeURIComponent(value));
                        }
                    }
                }
                
                return params;
            }
            
            parseUrlState() {
                wsTraceHandler.sendTrace('[DEBUG]', `parseUrlState called with search: "${window.location.search}"`);
                
                // Only interpret from/to parameters as commit hashes
                const searchParams = new URLSearchParams(window.location.search);
                const fromHash = searchParams.get('from');
                const toHash = searchParams.get('to');

                wsTraceHandler.sendTrace('[DEBUG]', `Parsed URL params - from: "${fromHash}", to: "${toHash}"`);

                // Only proceed if we have URL parameters to process
                if (!fromHash && !toHash) {
                    wsTraceHandler.sendTrace('[DEBUG]', 'No URL params present, not overriding current selections');
                    return;
                }

                // Convert commit hashes to position values for rail selection
                let fromSet = false;
                let toSet = false;

                if (fromHash) {
                    const fromPosition = this.hashToPosition(fromHash);
                    if (fromPosition) {
                        wsTraceHandler.sendTrace('[DEBUG]', `Setting from rail to position: ${fromPosition} (from hash: ${fromHash})`);
                        this.setRailSelection('from', fromPosition, true); // Skip diff on first selection
                        fromSet = true;
                    } else {
                        wsTraceHandler.sendTrace('[DEBUG]', `Failed to resolve from hash: ${fromHash} - ignoring`);
                    }
                }

                if (toHash) {
                    const toPosition = this.hashToPosition(toHash);
                    if (toPosition) {
                        wsTraceHandler.sendTrace('[DEBUG]', `Setting to rail to position: ${toPosition} (from hash: ${toHash})`);
                        this.setRailSelection('to', toPosition, false); // Perform diff on second selection
                        toSet = true;
                    } else {
                        wsTraceHandler.sendTrace('[DEBUG]', `Failed to resolve to hash: ${toHash} - ignoring`);
                    }
                }

                // If only from was set and resolved, trigger diff
                if (fromSet && !toSet) {
                    wsTraceHandler.sendTrace('[DEBUG]', 'Only from position set from URL, calling performDiff');
                    this.performDiff();
                }
            }

            hashToPosition(commitHash) {
                if (!commitHash || !this.manifest || !this.manifest.commits) {
                    return null;
                }

                // Find the commit by hash
                const commitIndex = this.manifest.commits.findIndex(c => c.hash === commitHash);
                if (commitIndex === -1) {
                    return null;
                }

                // Convert index to position value (H for head, -1, -2, etc.)
                if (commitIndex === this.manifest.commits.length - 1) {
                    return 'H';
                } else {
                    const offset = this.manifest.commits.length - 1 - commitIndex;
                    return `-${offset}`;
                }
            }

            onSwapClick() {
                const fromValue = this.selectedFrom;
                const toValue = this.selectedTo;

                wsTraceHandler.sendTrace('[SWAP]', `Transposing rail positions: ${fromValue} <-> ${toValue}`);

                // Guard against URL updates during transpose
                this.suppressUrlUpdate = true;

                // Transpose the column positions by exchanging selections
                // Skip diff on both selections during transpose
                this.setRailSelection('from', toValue, true);  // Skip diff
                this.setRailSelection('to', fromValue, true);  // Skip diff - we'll do single diff at end

                // Clear the guard flag
                this.suppressUrlUpdate = false;

                // Update URL with resolved commit hashes and perform single diff
                this.writeUrlState();
                this.performDiff();
            }

            writeUrlState() {
                // Fix: Use hash fragment instead of query params per GADS spec
                const fromCommit = this.resolveCommit(this.selectedFrom);
                const toCommit = this.resolveCommit(this.selectedTo);

                if (fromCommit && toCommit) {
                    const newHash = `#from=${encodeURIComponent(fromCommit.hash)}&to=${encodeURIComponent(toCommit.hash)}`;
                    const newUrl = window.location.protocol + '//' + window.location.host + window.location.pathname + window.location.search + newHash;
                    window.history.replaceState(null, '', newUrl);
                    wsTraceHandler.sendTrace('[URL]', `Updated hash state: from=${fromCommit.hash.substring(0,8)} to=${toCommit.hash.substring(0,8)}`);
                }
            }

            async performDiff() {
                const fromValue = this.selectedFrom;
                const toValue = this.selectedTo;

                if (!fromValue || !toValue) return;

                try {
                    wsTraceHandler.sendTrace('[RESOLVE]', 'Magic value resolution start');

                    const fromCommit = this.resolveCommit(fromValue);
                    const toCommit = this.resolveCommit(toValue);

                    if (!fromCommit || !toCommit) {
                        wsTraceHandler.sendTrace('[ERROR]', 'Invalid magic values or missing commits in manifest');
                        throw new Error('Failed to resolve commits');
                    }

                    wsTraceHandler.sendTrace('[RESOLVE]', `Resolved from: ${fromCommit.hash.substring(0, 8)}, to: ${toCommit.hash.substring(0, 8)}`);

                    // Update comparison header
                    this.elements.comparisonHeader.textContent =
                        `${fromCommit.hash.substring(0, 8)} → ${toCommit.hash.substring(0, 8)}`;

                    // Check for identical SHA256
                    if (fromCommit.html_sha256 === toCommit.html_sha256) {
                        wsTraceHandler.sendTrace('[SHA256]', 'Detection of identical html_sha256 values between selected commits');
                        this.showStatusMessage('These commits have identical rendered content');
                    } else {
                        wsTraceHandler.sendTrace('[SHA256]', 'Detection of different html_sha256 values between selected commits');
                        this.hideStatusMessage();
                    }

                    await this.fetchAndDiff(fromCommit, toCommit);

                } catch (error) {
                    wsTraceHandler.sendTrace('[ERROR]', `Diff error: ${error.message}`);
                    this.elements.renderedPane.innerHTML = `
                        <div class="error">
                            <h3>Diff Error</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            }

            resolveCommit(positionValue) {
                // First check: direct hash lookup
                const commitByHash = this.manifest.commits.find(c => c.hash === positionValue);
                if (commitByHash) {
                    return commitByHash;
                }

                // Second check: position value handling
                if (positionValue === 'H') {
                    return this.manifest.commits[this.manifest.commits.length - 1];
                } else if (positionValue.startsWith('-')) {
                    const offset = parseInt(positionValue.substring(1));
                    const index = this.manifest.commits.length - 1 - offset;
                    return index >= 0 ? this.manifest.commits[index] : null;
                }

                return null;
            }

            async fetchAndDiff(fromCommit, toCommit) {
                wsTraceHandler.sendTrace('[FETCH]', `HTML fetch start for ${fromCommit.html_file} and ${toCommit.html_file}`);

                try {
                    const [fromResponse, toResponse] = await Promise.all([
                        fetch(`/output/${fromCommit.html_file}`),
                        fetch(`/output/${toCommit.html_file}`)
                    ]);

                    if (!fromResponse.ok || !toResponse.ok) {
                        throw new Error('Failed to fetch HTML files');
                    }

                    const [fromHtml, toHtml] = await Promise.all([
                        fromResponse.text(),
                        toResponse.text()
                    ]);

                    wsTraceHandler.sendTrace('[FETCH]', 'Successful fetch completion');
                    wsTraceHandler.sendTrace('[DIFF]', 'Diff computation start');

                    // Prepare source file information for gadfd_rendered_capture
                    const sourceFiles = [
                        `From: /output/${fromCommit.html_file}`,
                        `To: /output/${toCommit.html_file}`
                    ];

                    // Use diff-dom library
                    const styledDiff = this.styleDiff(fromHtml, toHtml, fromCommit, toCommit, sourceFiles);

                    this.elements.renderedPane.innerHTML = styledDiff;

                    // Send rendered content to Factory via WebSocket for raw diff file creation
                    wsTraceHandler.sendTrace('[RAW-DIFF]', `Creating raw diff file for ${fromCommit.hash.substring(0, 8)} → ${toCommit.hash.substring(0, 8)}`);
                    wsTraceHandler.sendRenderedContent(styledDiff, fromCommit, toCommit, sourceFiles);

                    // Enhanced logging for Factory debugging
                    const changeTypeBreakdown = {
                        insertions: this.elements.renderedPane.querySelectorAll('.diff-insertion').length,
                        moves: this.elements.renderedPane.querySelectorAll('.diff-moved').length,
                        deletions: this.elements.renderedPane.querySelectorAll('.diff-deletion').length,
                        modifications: this.elements.renderedPane.querySelectorAll('.diff-modification').length
                    };

                    const totalChanges = changeTypeBreakdown.insertions + changeTypeBreakdown.moves + 
                                       changeTypeBreakdown.deletions + changeTypeBreakdown.modifications;

                    // Debug trace for change counting
                    wsTraceHandler.sendTrace('[COUNT]', `Found ${totalChanges} total changes in rendered output`);
                    wsTraceHandler.sendTrace('[COUNT]', `Breakdown: ${changeTypeBreakdown.insertions} insertions, ${changeTypeBreakdown.moves} moves, ${changeTypeBreakdown.deletions} deletions, ${changeTypeBreakdown.modifications} modifications`);

                    wsTraceHandler.sendTrace('[DIFF]', `Completion with ${totalChanges} total changes`);
                    wsTraceHandler.sendTrace('[DIFF]', `Change breakdown: ${JSON.stringify(changeTypeBreakdown)}`);

                } catch (error) {
                    // Enhanced error reporting for Factory debugging
                    if (error.message.includes('diff-dom')) {
                        wsTraceHandler.sendTrace('[ERROR]', `diff-dom library failure: ${error.message}`);
                    } else if (error.message.includes('fetch') || error.message.includes('HTTP')) {
                        wsTraceHandler.sendTrace('[FETCH]', `Fetch failure: ${error.message}`);
                    } else {
                        wsTraceHandler.sendTrace('[ERROR]', `GADS processing failure: ${error.message}`);
                    }

                    // Additional debugging context
                    wsTraceHandler.sendTrace('[DEBUG]', `Error occurred during diff processing for commits: ${fromCommit?.hash?.substring(0,8)} → ${toCommit?.hash?.substring(0,8)}`);
                    throw error;
                }
            }

            styleDiff(fromHtml, toHtml, fromCommit, toCommit, sourceFiles) {
                const startTime = performance.now();
                wsTraceHandler.sendTrace('[DIFF]', 'Starting GADS-compliant 8-phase diff processing');
                wsTraceHandler.sendTrace('[DEBUG]', `Input sizes: fromHtml=${fromHtml.length} chars, toHtml=${toHtml.length} chars`);
                wsTraceHandler.sendTrace('[DEBUG]', `diff-dom type at diff time: ${typeof window.diffDom}`);

                if (typeof window.diffDom === 'undefined' || typeof window.diffDom.DiffDOM === 'undefined') {
                    throw new Error('diff-dom library not available - required for diff processing');
                }

                try {
                    // Phase 1: Immutable Input - Establish immutable source DOM trees
                    wsTraceHandler.sendTrace('[PHASE-1]', 'Immutable Input: Creating immutable source DOM trees');
                    const immutableFromDOM = this.createDOMFromHTML(fromHtml);
                    const immutableToDOM = this.createDOMFromHTML(toHtml);
                    wsTraceHandler.sendTrace('[PHASE-1]', 'Immutable Input: Immutable DOM trees established and preserved throughout processing');

                    // Phase 2: Detached Working - Create Detached Working DOM with Semantic Anchors
                    wsTraceHandler.sendTrace('[PHASE-2]', 'Detached Working: Creating Detached Working DOM with Semantic Anchors');
                    const detachedWorkingDOM = this.createDetachedWorkingDOM(immutableToDOM);
                    const semanticAnchors = this.establishSemanticAnchors(detachedWorkingDOM);
                    wsTraceHandler.sendTrace('[PHASE-2]', `Detached Working: Created independent processing environment with ${Object.keys(semanticAnchors).length} semantic anchors`);

                    // Phase 3: Deletion Fact Capture - Generate Deletion Fact Keys (DFK)
                    wsTraceHandler.sendTrace('[PHASE-3]', 'Deletion Fact Capture: Generating Deletion Fact Keys (DFK)');
                    const deletionFactTable = this.createDeletionFactTable(immutableFromDOM);
                    const phase3Debug = { deletionFactCount: Object.keys(deletionFactTable).length, sampleKeys: Object.keys(deletionFactTable).slice(0, 5) };
                    wsTraceHandler.sendDebugOutput('phase3_dft', JSON.stringify(phase3Debug, null, 2), fromCommit, toCommit, sourceFiles);
                    wsTraceHandler.sendTrace('[PHASE-3]', `Deletion Fact Capture: Created DFK mapping for ${Object.keys(deletionFactTable).length} potential deletions`);

                    // Phase 4: Diff Operations - Generate structured diff operations
                    wsTraceHandler.sendTrace('[PHASE-4]', 'Diff Operations: Initializing diff-dom and generating operations');
                    const diffDOM = new window.diffDom.DiffDOM({
                        debug: true,
                        diffcap: 500  // Allow more granular detection
                    });
                    const diffOperations = diffDOM.diff(immutableFromDOM, immutableToDOM);
                    this.enhanceOperationsWithDFK(diffOperations, deletionFactTable);
                    wsTraceHandler.sendTrace('[PHASE-4]', `Diff Operations: Generated ${diffOperations.length} enhanced diff operations`);

                    // Phase 5: Annotated Assembly - Construct semantically annotated output DOM
                    wsTraceHandler.sendTrace('[PHASE-5]', 'Annotated Assembly: Processing diff operations in Detached Working environment');
                    const assembledDOM = this.assembleAnnotatedDOM(detachedWorkingDOM, diffOperations, semanticAnchors);
                    const assembledHTML = assembledDOM.innerHTML;
                    wsTraceHandler.sendDebugOutput('phase5_annotated', assembledHTML, fromCommit, toCommit, sourceFiles);
                    wsTraceHandler.sendTrace('[PHASE-5]', 'Annotated Assembly: Semantic annotation construction completed');

                    // Phase 6: Deletion Placement - Position deletion blocks using DFK and Semantic Anchors
                    wsTraceHandler.sendTrace('[PHASE-6]', 'Deletion Placement: Positioning deletion blocks with DFK mappings');
                    const deletionPlacedDOM = this.placeDeletionBlocks(assembledDOM, diffOperations, deletionFactTable, semanticAnchors);
                    const deletionPlacedHTML = deletionPlacedDOM.innerHTML;
                    wsTraceHandler.sendDebugOutput('phase6_deletions', deletionPlacedHTML, fromCommit, toCommit, sourceFiles);
                    wsTraceHandler.sendTrace('[PHASE-6]', 'Deletion Placement: Structured deletion blocks positioned accurately');

                    // Phase 7: Uniform Classing - Merge consecutive same-nature elements
                    wsTraceHandler.sendTrace('[PHASE-7]', 'Uniform Classing: Merging consecutive same-nature elements into consolidated runs');
                    const coalescedDOM = this.mergeAdjacentSameNature(deletionPlacedDOM);
                    const coalescedHTML = coalescedDOM.innerHTML;
                    wsTraceHandler.sendDebugOutput('phase7_coalesced', coalescedHTML, fromCommit, toCommit, sourceFiles);
                    wsTraceHandler.sendTrace('[PHASE-7]', 'Uniform Classing: Single-element consolidated runs created');

                    // Phase 8: Serialize - Generate final rendered output
                    wsTraceHandler.sendTrace('[PHASE-8]', 'Serialize: Generating final styled diff HTML');
                    const finalHTML = this.serializeFinalOutput(coalescedDOM);
                    wsTraceHandler.sendDebugOutput('phase8_final', finalHTML, fromCommit, toCommit, sourceFiles);
                    wsTraceHandler.sendTrace('[PHASE-8]', 'Serialize: Final rendered HTML ready for display');

                    // Performance logging for Factory debugging
                    const endTime = performance.now();
                    const totalTime = Math.round(endTime - startTime);
                    wsTraceHandler.sendTrace('[PERF]', `GADS 8-phase diff processing completed in ${totalTime}ms`);
                    wsTraceHandler.sendTrace('[ARCH]', 'Complete processing isolation maintained - input DOMs never modified');

                    return finalHTML;

                } catch (error) {
                    wsTraceHandler.sendTrace('[ERROR]', `GADS 8-phase diff processing failed: ${error.message}`);
                    throw error;
                }
            }

            // Phase 1: Block Identification - GADS compliant implementation
            identifyBlocks(html, source) {
                wsTraceHandler.sendTrace('[DEBUG]', `Block identification starting for ${source}`);

                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const blocks = [];

                // Target block-level elements per GADS specification
                const blockElements = ['P', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6',
                                      'LI', 'TD', 'TH', 'BLOCKQUOTE', 'PRE', 'SECTION', 'ARTICLE',
                                      'HEADER', 'FOOTER', 'NAV', 'ASIDE', 'MAIN'];

                const walker = doc.createTreeWalker(
                    doc.body || doc.documentElement,
                    NodeFilter.SHOW_ELEMENT,
                    {
                        acceptNode: function(node) {
                            return blockElements.includes(node.tagName) ?
                                NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
                        }
                    }
                );

                let node;
                let blockIndex = 0;
                while (node = walker.nextNode()) {
                    // Generate unique identifier based on element type, DOM path, and content
                    const domPath = this.getDomPath(node);
                    const textContent = node.textContent.trim();
                    const blockId = `${node.tagName}-${blockIndex}-${this.hashString(domPath + textContent)}`;

                    blocks.push({
                        id: blockId,
                        source: source,  // Track source separately
                        element: node,
                        tagName: node.tagName,
                        domPath: domPath,
                        textContent: textContent,
                        innerHTML: node.innerHTML,
                        index: blockIndex
                    });

                    blockIndex++;
                }

                wsTraceHandler.sendTrace('[DEBUG]', `Block identification completed for ${source}: ${blocks.length} blocks`);
                return blocks;
            }

            getDomPath(element) {
                const path = [];
                let current = element;
                while (current && current.nodeType === Node.ELEMENT_NODE) {
                    let selector = current.tagName.toLowerCase();
                    if (current.id) {
                        selector += '#' + current.id;
                    } else if (current.className) {
                        selector += '.' + current.className.split(/\s+/).join('.');
                    }
                    path.unshift(selector);
                    current = current.parentElement;
                }
                return path.join(' > ');
            }

            hashString(str) {
                // Simple hash function for unique identifiers
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash).toString(16);
            }

            linearizeBlocks(blocks) {
                wsTraceHandler.sendTrace('[DEBUG]', `Linearizing ${blocks.length} blocks`);

                // Create text linearization preserving block boundaries with identical separator markers
                const BLOCK_START = '⟨BLOCK⟩';
                const BLOCK_END = '⟨/BLOCK⟩';
                const linearized = blocks.map(block => {
                    return `${BLOCK_START}${block.textContent}${BLOCK_END}`;
                }).join('\n');

                wsTraceHandler.sendTrace('[DEBUG]', `Linearization completed, length: ${linearized.length}`);
                return linearized;
            }

            // Helper method for creating DOM from HTML strings
            createDOMFromHTML(html) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                return doc.body;
            }

            findElementByRoute(dom, route) {
                let element = dom;
                for (let i = 0; i < route.length; i++) {
                    const index = route[i];
                    if (element.childNodes && element.childNodes[index]) {
                        element = element.childNodes[index];
                    } else {
                        const availableCount = element.childNodes ? element.childNodes.length : 0;
                        
                        // Fix: Remove "best-effort" fallback - if route index is OOB, abort operation
                        wsTraceHandler.sendTrace('[ROUTE-ERROR]', `Route traversal failed at index ${index} for route [${route.join(',')}]`);
                        wsTraceHandler.sendTrace('[ROUTE-ERROR]', `Parent has ${availableCount} children, requested index ${index}`);
                        wsTraceHandler.sendTrace('[ROUTE-ERROR]', `Failed at route position ${i}, partial route was [${route.slice(0, i).join(',')}]`);
                        return null; // Fix: Fail fast instead of retargeting
                    }
                }
                return element;
            }

            escapeHtml(unsafe) {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            extractTextFromHtml(htmlString) {
                try {
                    // Create a temporary element to parse HTML and extract text content
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlString;
                    return tempDiv.textContent || tempDiv.innerText || '';
                } catch (e) {
                    // Fallback: basic tag stripping
                    return htmlString.replace(/<[^>]*>/g, '').trim();
                }
            }

            generateOutputDOM(immutableToDOM, diffOperations, routeElementMap) {
                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Generating clean output DOM from ${diffOperations.length} operations`);

                // Create completely new output DOM structure - never modify inputs
                const outputDOM = document.createElement('div');

                // Deep clone the immutable "to" DOM structure as foundation
                this.deepCloneElement(immutableToDOM, outputDOM);
                wsTraceHandler.sendTrace('[OUTPUT-GEN]', 'Created output DOM foundation from immutable toDOM');

                // Apply diff annotations to output DOM with deduplication
                let insertions = 0, deletions = 0, moves = 0, modifications = 0;
                const processedDeletions = new Set(); // Track processed deletion routes to prevent duplicates

                // Process operations in reverse order (GADS Phase 3) to prevent route invalidation
                for (let i = diffOperations.length - 1; i >= 0; i--) {
                    const op = diffOperations[i];
                    wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Processing operation ${i} (reverse order): ${op.action} at route [${op.route.join(',')}]`);
                    switch (op.action) {
                        case 'addElement':
                        case 'addTextElement':
                            this.applyInsertionAnnotation(outputDOM, op);
                            insertions++;
                            break;
                        case 'removeElement':
                        case 'removeTextElement':
                            const routeKey = op.route.join(',');
                            if (!processedDeletions.has(routeKey)) {
                                this.generateDeletionInline(outputDOM, op);
                                processedDeletions.add(routeKey);
                                deletions++;
                                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Processed unique deletion at route [${routeKey}]`);
                            } else {
                                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Skipped duplicate deletion at route [${routeKey}]`);
                            }
                            break;
                        case 'relocateNode':
                            this.applyMoveAnnotation(outputDOM, op);
                            moves++;
                            break;
                        case 'modifyTextElement':
                            // Handle text modifications as deletion + insertion pairs
                            this.handleTextModification(outputDOM, op, routeElementMap);
                            modifications++;
                            break;
                        case 'modifyAttribute':
                            // Only apply modification styling for attributes, don't double-annotate as insertion
                            this.applyModificationAnnotation(outputDOM, op);
                            modifications++;
                            break;
                        default:
                            wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Unknown operation type: ${op.action}`);
                    }
                }

                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Applied annotations: ${insertions} insertions, ${deletions} deletions (${processedDeletions.size} unique), ${moves} moves, ${modifications} modifications`);
                wsTraceHandler.sendTrace('[OUTPUT-GEN]', 'Output DOM generation completed with all annotations applied');

                return outputDOM;
            }

            mergeAdjacentSameNature(annotatedDOM) {
                // Phase 5: Visual coalescing - preserve semantic structure with presentation wrappers only
                wsTraceHandler.sendTrace('[COALESCE]', 'Starting Phase 5: Visual coalescing with presentation wrappers');
                
                // Create a new DOM to avoid modifying the annotated DOM
                const coalescedDOM = annotatedDOM.cloneNode(true);
                
                // Apply visual coalescing by adding presentation wrappers around adjacent same-nature elements
                this.addVisualRunWrappers(coalescedDOM);
                
                wsTraceHandler.sendTrace('[COALESCE]', 'Phase 5 complete - semantic structure fully preserved');
                return coalescedDOM;
            }

            addVisualRunWrappers(dom) {
                // Find adjacent same-nature diff elements and replace them with single consolidated elements
                const diffTypes = ['diff-insertion', 'diff-moved', 'diff-deletion-inline', 'diff-modification'];
                let runCounter = 0;
                
                for (const diffType of diffTypes) {
                    runCounter += this.wrapAdjacentSameType(dom, diffType, runCounter);
                }
                
                wsTraceHandler.sendTrace('[VISUAL-CONSOLIDATE]', `Created ${runCounter} consolidated diff elements`);
            }
            
            wrapAdjacentSameType(dom, className, startRunId) {
                const elements = Array.from(dom.querySelectorAll(`.${className}`));
                if (elements.length < 2) return 0;
                
                let runId = startRunId;
                let runsCreated = 0;
                let i = 0;
                
                while (i < elements.length) {
                    const currentElement = elements[i];
                    const adjacentRun = [currentElement];
                    
                    // Collect adjacent siblings of the same type
                    let j = i + 1;
                    while (j < elements.length && this.areConsecutiveSiblings(elements[j-1], elements[j])) {
                        adjacentRun.push(elements[j]);
                        j++;
                    }
                    
                    // Fix: Only coalesce when (tagName, diff-class) match exactly
                    if (adjacentRun.length >= 2 && this.canSafelyCoalesce(adjacentRun, className)) {
                        this.replaceRunWithSingleElement(adjacentRun, className);
                        runsCreated++;
                        wsTraceHandler.sendTrace('[VISUAL-REPLACE]', `Replaced ${adjacentRun.length} adjacent ${className} elements with single consolidated element`);
                    } else if (adjacentRun.length >= 2) {
                        wsTraceHandler.sendTrace('[COALESCE-SKIP]', `Skipped coalescing ${adjacentRun.length} ${className} elements - mixed types not coalesceable`);
                    }
                    
                    i = j;
                }
                
                return runsCreated;
            }
            
            canSafelyCoalesce(elements, className) {
                // Fix: Never merge an <a> into a <span> - preserve element types 
                if (elements.length < 2) return false;
                
                const firstTag = elements[0].tagName;
                const firstDiffClass = this.extractDiffClass(elements[0], className);
                
                // All elements must have same tagName and same diff class
                for (const element of elements) {
                    if (element.tagName !== firstTag) {
                        return false; // Different tag names cannot be coalesced
                    }
                    if (this.extractDiffClass(element, className) !== firstDiffClass) {
                        return false; // Different diff classes cannot be coalesced
                    }
                }
                
                return true;
            }
            
            extractDiffClass(element, expectedClassName) {
                // Extract the specific diff class from element's classList
                const classList = Array.from(element.classList);
                return classList.find(cls => cls.startsWith('diff-')) || expectedClassName;
            }
            
            areConsecutiveSiblings(elem1, elem2) {
                // Check if elem2 immediately follows elem1 in the DOM
                return elem1.parentElement === elem2.parentElement && 
                       elem1.nextElementSibling === elem2;
            }
            
            replaceRunWithSingleElement(runElements, className) {
                if (runElements.length < 2) return;
                
                // Fix: Preserve anchors exactly - only coalesce identical anchor elements
                const allAnchors = runElements.every(el => el.tagName === 'A');
                if (allAnchors) {
                    const firstHref = runElements[0].getAttribute('href');
                    const sameHref = runElements.every(el => el.getAttribute('href') === firstHref);
                    
                    if (sameHref) {
                        // Create single consolidated anchor preserving all attributes
                        const consolidatedAnchor = document.createElement('a');
                        
                        // Copy all attributes from first element
                        for (const attr of runElements[0].attributes) {
                            consolidatedAnchor.setAttribute(attr.name, attr.value);
                        }
                        
                        // Ensure diff class is preserved
                        if (!consolidatedAnchor.classList.contains(className)) {
                            consolidatedAnchor.classList.add(className);
                        }
                        
                        // Combine all anchor text content
                        let combinedText = '';
                        for (const anchor of runElements) {
                            combinedText += anchor.textContent;
                        }
                        consolidatedAnchor.textContent = combinedText;
                        
                        // Replace all anchors with single consolidated anchor
                        const parent = runElements[0].parentElement;
                        if (parent) {
                            parent.insertBefore(consolidatedAnchor, runElements[0]);
                            for (const element of runElements) {
                                if (element.parentElement) {
                                    element.parentElement.removeChild(element);
                                }
                            }
                        }
                        return;
                    }
                }
                
                // Fix: Use sibling wrappers for presentation instead of merging different element types
                // This preserves links and prevents structural damage
                const runContainer = document.createElement('span');
                runContainer.className = `${className}-coalesced-run`;
                runContainer.style.display = 'inline';
                
                // Insert container before first element
                const parent = runElements[0].parentElement;
                if (parent) {
                    parent.insertBefore(runContainer, runElements[0]);
                    
                    // Move all elements into container without modifying their structure
                    for (const element of runElements) {
                        if (element.parentElement) {
                            runContainer.appendChild(element);
                        }
                    }
                    
                    // Add visual styling to container instead of individual elements
                    this.applyCoalescedStyling(runContainer, className);
                }
            }
            
            applyCoalescedStyling(container, className) {
                // Apply visual styling that indicates coalesced content without breaking structure
                switch (className) {
                    case 'diff-insertion':
                        container.style.backgroundColor = 'rgba(212, 237, 218, 0.5)';
                        container.style.borderLeft = '2px solid #28a745';
                        container.style.paddingLeft = '2px';
                        break;
                    case 'diff-deletion-inline':
                        container.style.backgroundColor = 'rgba(248, 215, 218, 0.5)';
                        container.style.borderLeft = '2px solid #dc3545';
                        container.style.paddingLeft = '2px';
                        break;
                    case 'diff-moved':
                        container.style.backgroundColor = 'rgba(255, 243, 205, 0.5)';
                        container.style.borderLeft = '2px solid #ffc107';
                        container.style.paddingLeft = '2px';
                        break;
                    case 'diff-modification':
                        container.style.backgroundColor = 'rgba(209, 236, 241, 0.5)';
                        container.style.borderLeft = '2px solid #17a2b8';
                        container.style.paddingLeft = '2px';
                        break;
                }
            }

            // LEGACY METHOD REMOVED - coalesceInlineChanges disabled to preserve semantic DOM structure

            // LEGACY METHOD REMOVED - coalesceBlockChanges disabled to preserve semantic DOM structure

            // LEGACY METHODS REMOVED - All structural merging disabled to preserve semantic DOM integrity
            // Phase 5 now uses only visual presentation wrappers without DOM modification


            isInlineElement(element) {
                const inlineElements = new Set(['A', 'SPAN', 'EM', 'STRONG', 'B', 'I', 'U', 'CODE', 'MARK', 'SMALL', 'SUP', 'SUB']);
                return inlineElements.has(element.tagName);
            }

            deepCloneElement(sourceElement, targetParent) {
                if (!sourceElement || !sourceElement.childNodes) return;

                // Clone all child nodes recursively
                for (let i = 0; i < sourceElement.childNodes.length; i++) {
                    const sourceChild = sourceElement.childNodes[i];
                    let clonedChild;

                    if (sourceChild.nodeType === Node.ELEMENT_NODE) {
                        // Create element with all attributes
                        clonedChild = document.createElement(sourceChild.tagName.toLowerCase());
                        for (let j = 0; j < sourceChild.attributes.length; j++) {
                            const attr = sourceChild.attributes[j];
                            clonedChild.setAttribute(attr.name, attr.value);
                        }
                        // Recursively clone children
                        this.deepCloneElement(sourceChild, clonedChild);
                    } else if (sourceChild.nodeType === Node.TEXT_NODE) {
                        clonedChild = document.createTextNode(sourceChild.textContent);
                    } else {
                        // Other node types (comments, etc.)
                        clonedChild = sourceChild.cloneNode(false);
                    }

                    if (clonedChild) {
                        targetParent.appendChild(clonedChild);
                    }
                }
            }

            applyInsertionAnnotation(outputDOM, operation) {
                const element = this.findElementByRoute(outputDOM, operation.route);
                if (element && element.nodeType === Node.ELEMENT_NODE) {
                    // For inline elements (A, SPAN, etc.) use inline highlighting
                    if (this.isInlineElement(element)) {
                        element.style.backgroundColor = '#d4edda';
                        element.style.padding = '2px';
                        element.style.borderRadius = '2px';
                        element.classList.add('diff-insertion');
                        wsTraceHandler.sendTrace('[INSERTION]', `Applied inline insertion annotation at route [${operation.route.join(',')}]`);
                    } else {
                        // For block elements, use full block styling
                        element.classList.add('diff-insertion');
                        element.style.backgroundColor = '#d4edda';
                        element.style.borderLeft = '4px solid #28a745';
                        element.style.padding = '4px';
                        wsTraceHandler.sendTrace('[INSERTION]', `Applied block insertion annotation at route [${operation.route.join(',')}]`);
                    }
                } else if (element && element.nodeType === Node.TEXT_NODE && element.parentElement) {
                    // For text insertions, create inline highlighting
                    const parent = element.parentElement;
                    const span = document.createElement('span');
                    span.classList.add('diff-insertion');
                    span.style.backgroundColor = '#d4edda';
                    span.style.padding = '2px';
                    span.style.borderRadius = '2px';

                    parent.insertBefore(span, element);
                    span.appendChild(element);

                    wsTraceHandler.sendTrace('[INSERTION]', `Applied insertion annotation with span wrapper at route [${operation.route.join(',')}]`);
                } else {
                    wsTraceHandler.sendTrace('[INSERTION]', `Could not find element for insertion annotation at route [${operation.route.join(',')}]`);
                }
            }

            applyMoveAnnotation(outputDOM, operation) {
                const element = this.findElementByRoute(outputDOM, operation.route);
                if (element && element.nodeType === Node.ELEMENT_NODE) {
                    element.classList.add('diff-moved');
                    element.style.backgroundColor = '#fff3cd';
                    element.style.borderLeft = '4px solid #ffc107';
                    wsTraceHandler.sendTrace('[MOVE]', `Applied move annotation at route [${operation.route.join(',')}]`);
                } else {
                    wsTraceHandler.sendTrace('[MOVE]', `Could not find element for move annotation at route [${operation.route.join(',')}]`);
                }
            }

            applyModificationAnnotation(outputDOM, operation) {
                // Don't apply modification styling to parent containers that have child insertions
                // This prevents the entire paragraph from being marked as modified when only parts changed
                wsTraceHandler.sendTrace('[MODIFICATION]', `Skipping broad modification annotation at route [${operation.route.join(',')}] - let child insertions handle specific changes`);
            }

            handleTextModification(outputDOM, operation, routeElementMap) {
                wsTraceHandler.sendTrace('[TEXT-MODIFY]', `Processing text modification at route [${operation.route.join(',')}]: "${operation.oldValue}" → "${operation.newValue}"`);

                // GADS Phase 3: Element Lookup - Traverse route to locate target element
                const element = this.findElementByRoute(outputDOM, operation.route);
                if (!element) {
                    const routeDetails = `Route traversal failed: Could not locate element at route [${operation.route.join(',')}] in output DOM. DOM structure may have changed during processing. Output DOM root: ${outputDOM.tagName || 'unknown'}`;
                    wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', routeDetails);
                    this.insertSingleErrorMarker(outputDOM, operation);
                    return;
                }

                // Create inline deletion for old value if it exists and differs from new value
                if (operation.oldValue && operation.oldValue !== operation.newValue) {
                    const contentMatches = this.validateElementContent(element, operation.newValue);
                    
                    if (contentMatches) {
                        // Create simple inline deletion span
                        const deletionSpan = document.createElement('span');
                        deletionSpan.className = 'diff-deletion';
                        deletionSpan.textContent = operation.oldValue;

                        // Insert before the target element
                        if (element.parentNode) {
                            element.parentNode.insertBefore(deletionSpan, element);
                        }
                        wsTraceHandler.sendTrace('[TEXT-MODIFY]', `Applied inline deletion for: "${operation.oldValue}"`);
                    } else {
                        wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', `Content mismatch - expected "${operation.newValue}", found "${element.textContent}"`);
                    }
                }

                // Apply insertion styling to new value
                if (operation.newValue) {
                    const insertionSuccess = this.applyInsertionStyling(element, operation.newValue);
                    if (insertionSuccess) {
                        wsTraceHandler.sendTrace('[TEXT-MODIFY]', `Applied insertion styling to: "${operation.newValue}"`);
                    } else {
                        wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', `Failed to apply insertion styling to: "${operation.newValue}"`);
                        this.insertSingleErrorMarker(outputDOM, operation);
                    }
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }


            // GADS Phase 3: Content Validation - Verify element content matches expected value
            validateElementContent(element, expectedContent) {
                if (element.nodeType === Node.TEXT_NODE) {
                    return element.textContent === expectedContent;
                } else if (element.nodeType === Node.ELEMENT_NODE) {
                    return element.textContent === expectedContent;
                } else {
                    return false;
                }
            }


            // GADS Phase 3: Apply insertion styling to new content
            applyInsertionStyling(element, newContent) {
                try {
                    if (element.nodeType === Node.TEXT_NODE) {
                        // For text nodes, wrap in a span
                        const span = document.createElement('span');
                        span.className = 'diff-insertion';
                        span.style.backgroundColor = 'rgb(212, 237, 218)';
                        span.style.padding = '2px';
                        span.style.borderRadius = '2px';
                        span.textContent = newContent;

                        // Replace the text node with our highlighted span
                        if (element.parentNode) {
                            element.parentNode.replaceChild(span, element);
                            return true;
                        }
                    } else if (element.nodeType === Node.ELEMENT_NODE) {
                        // For element nodes, add insertion class
                        element.classList.add('diff-insertion');
                        element.style.backgroundColor = 'rgb(212, 237, 218)';
                        element.style.padding = '2px';
                        element.style.borderRadius = '2px';
                        return true;
                    }
                    return false;
                } catch (error) {
                    wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', `Exception during insertion styling: ${error.message}`);
                    return false;
                }
            }

            // GADS Phase 3: Failure Handling - Insert error marker for diagnostic purposes
            insertProcessingErrorMarker(outputDOM, route, errorMessage, operation, detailedError) {
                const errorSpan = document.createElement('span');
                errorSpan.className = 'diff-processing-error';
                errorSpan.style.backgroundColor = 'magenta';
                errorSpan.style.color = 'white';
                errorSpan.style.padding = '2px 4px';
                errorSpan.style.fontSize = '0.8em';
                errorSpan.style.fontWeight = 'bold';
                errorSpan.style.borderRadius = '2px';
                errorSpan.style.margin = '0 2px';
                errorSpan.style.cursor = 'help';
                errorSpan.textContent = '⚠️ DIFF-ERROR';
                
                // Create detailed tooltip with all diagnostic information
                const tooltipContent = [
                    `ERROR: ${errorMessage}`,
                    `ROUTE: [${route.join(',')}]`,
                    `OPERATION: "${operation.oldValue || 'N/A'}" → "${operation.newValue || 'N/A'}"`,
                    detailedError ? `DETAILS: ${detailedError}` : '',
                    `TIMESTAMP: ${new Date().toISOString()}`
                ].filter(Boolean).join(' | ');
                
                errorSpan.title = tooltipContent;

                // Try to insert near the problem location
                try {
                    const approximateElement = this.findApproximateElementByRoute(outputDOM, route);
                    if (approximateElement && approximateElement.parentNode) {
                        approximateElement.parentNode.insertBefore(errorSpan, approximateElement);
                        wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', `Inserted error marker near route [${route.join(',')}]`);
                    } else {
                        // Fallback: append to document body or first available container
                        const fallbackContainer = outputDOM.querySelector('body') || outputDOM.querySelector('div') || outputDOM;
                        if (fallbackContainer) {
                            fallbackContainer.appendChild(errorSpan);
                            wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', `Inserted error marker in fallback container (${fallbackContainer.tagName || 'unknown'})`);
                        }
                    }
                } catch (fallbackError) {
                    wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', `Failed to insert error marker: ${fallbackError.message}`);
                }
            }

            insertSingleErrorMarker(outputDOM, operation) {
                // Fix: One-op, one-marker error policy - single, non-intrusive marker per failed op
                const errorSpan = document.createElement('span');
                errorSpan.className = 'diff-processing-error';
                errorSpan.style.backgroundColor = '#ff6b6b';
                errorSpan.style.color = 'white';
                errorSpan.style.padding = '1px 3px';
                errorSpan.style.fontSize = '0.7em';
                errorSpan.style.fontWeight = 'bold';
                errorSpan.style.borderRadius = '2px';
                errorSpan.style.margin = '0 1px';
                errorSpan.style.cursor = 'help';
                errorSpan.style.display = 'inline-block';
                errorSpan.textContent = '⚠️';
                
                // Create detailed tooltip with diagnostic information
                const tooltipContent = [
                    `ERROR: ${operation.errorReason || 'Processing failed'}`,
                    `ROUTE: [${operation.route.join(',')}]`,
                    `OPERATION: "${operation.oldValue || ''}" → "${operation.newValue || ''}"`,
                    `TIMESTAMP: ${new Date().toISOString()}`
                ].filter(Boolean).join(' | ');
                
                errorSpan.title = tooltipContent;
                
                // Insert as sibling/overlay, not as nested child that alters order
                try {
                    const insertionPoint = this.findSemanticAnchor(outputDOM, operation.route);
                    if (insertionPoint && insertionPoint.parentNode) {
                        insertionPoint.parentNode.insertBefore(errorSpan, insertionPoint.nextSibling);
                        wsTraceHandler.sendTrace('[ERROR-MARKER]', `Inserted single error marker for route [${operation.route.join(',')}]`);
                    } else {
                        // Fallback: append to root without nesting
                        outputDOM.appendChild(errorSpan);
                    }
                } catch (e) {
                    wsTraceHandler.sendTrace('[ERROR-MARKER-FAIL]', `Failed to insert error marker: ${e.message}`);
                }
            }
            
            findSemanticAnchor(dom, route) {
                // Find nearest stable block/id/href in the target tree for error marker placement
                let element = dom;
                let lastValidElement = element;
                
                for (let i = 0; i < route.length; i++) {
                    const index = route[i];
                    if (element.childNodes && element.childNodes[index]) {
                        element = element.childNodes[index];
                        // Prefer elements with stable identifiers
                        if (element.nodeType === Node.ELEMENT_NODE && 
                            (element.id || element.href || element.className)) {
                            lastValidElement = element;
                        }
                    } else {
                        break; // Stop at first invalid route segment
                    }
                }
                
                return lastValidElement;
            }

            // Helper: Find approximate element when exact route fails
            findApproximateElementByRoute(dom, route) {
                let element = dom;
                // Try to traverse as far as possible through the route
                for (let i = 0; i < route.length && element; i++) {
                    if (element.childNodes && element.childNodes[route[i]]) {
                        element = element.childNodes[route[i]];
                    } else {
                        // Return the deepest element we could reach
                        break;
                    }
                }
                return element;
            }

            // Helper: Get route array for an element (reverse of findElementByRoute)
            getElementRoute(element) {
                const route = [];
                let current = element;
                while (current && current.parentNode) {
                    const parent = current.parentNode;
                    for (let i = 0; i < parent.childNodes.length; i++) {
                        if (parent.childNodes[i] === current) {
                            route.unshift(i);
                            break;
                        }
                    }
                    current = parent;
                }
                return route;
            }

            generateDeletionInline(outputDOM, operation) {
                // Legacy method - redirect to new deterministic deletion placement
                wsTraceHandler.sendTrace('[DELETION-INLINE-LEGACY]', `Redirecting inline deletion for ${operation.action} to deterministic placement`);
                
                const anchorElement = this.findStableSemanticAnchor(outputDOM, operation.route);
                if (anchorElement) {
                    this.placeSingleDeletionBlock(outputDOM, operation, anchorElement);
                } else {
                    wsTraceHandler.sendTrace('[DELETION-INLINE-FAIL]', `Could not find semantic anchor for route [${operation.route.join(',')}]`);
                }
            }
            
            generateDeletionInlineLegacy(outputDOM, operation) {
                wsTraceHandler.sendTrace('[DELETION-INLINE]', `Generating inline deletion for ${operation.action} at route [${operation.route.join(',')}]`);

                // Find insertion point in the DOM
                const insertPoint = this.findInlineDeletionInsertionPoint(outputDOM, operation.route);
                if (!insertPoint) {
                    wsTraceHandler.sendTrace('[DELETION-INLINE]', `Could not find insertion point for route [${operation.route.join(',')}]`);
                    return;
                }

                // Create inline deletion element based on captured content
                if (operation.capturedContent) {
                    let deletionElement;
                    
                    if (operation.capturedType === 'element') {
                        // Check if the deleted element was a link
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = operation.capturedContent;
                        const linkElement = tempDiv.querySelector('a');
                        
                        if (linkElement) {
                            // Keep as link but strike through the text content
                            deletionElement = document.createElement('a');
                            deletionElement.href = linkElement.href;
                            deletionElement.className = 'diff-deletion';
                            deletionElement.textContent = linkElement.textContent;
                        } else {
                            // Non-link element - extract text and create span
                            deletionElement = document.createElement('span');
                            deletionElement.className = 'diff-deletion';
                            deletionElement.textContent = this.extractTextFromHtml(operation.capturedContent);
                        }
                    } else {
                        // Text deletion - create span
                        deletionElement = document.createElement('span');
                        deletionElement.className = 'diff-deletion';
                        deletionElement.textContent = operation.capturedContent;
                    }

                    // Insert the deletion element
                    if (insertPoint.container && deletionElement) {
                        if (insertPoint.insertBefore) {
                            insertPoint.container.insertBefore(deletionElement, insertPoint.insertBefore);
                        } else {
                            insertPoint.container.appendChild(deletionElement);
                        }
                        wsTraceHandler.sendTrace('[DELETION-INLINE]', `Inserted inline deletion: "${deletionElement.textContent}"`);
                    }
                }
            }

            findInlineDeletionInsertionPoint(outputDOM, route) {
                wsTraceHandler.sendTrace('[DELETION-INSERT]', `Finding inline insertion point for route [${route.join(',')}]`);

                if (route.length === 0) {
                    wsTraceHandler.sendTrace('[DELETION-INSERT]', 'Empty route, using output DOM start');
                    return { container: outputDOM, insertBefore: outputDOM.firstChild };
                }

                // Traverse route to find the approximate location
                let element = outputDOM;
                let parentElement = outputDOM;
                let targetIndex = 0;

                for (let i = 0; i < route.length; i++) {
                    if (element.childNodes && element.childNodes[route[i]]) {
                        parentElement = element;
                        targetIndex = route[i];
                        element = element.childNodes[route[i]];
                    } else {
                        // Route traversal failed, use last valid parent
                        break;
                    }
                }

                // Find the best inline insertion point
                if (parentElement && parentElement.childNodes) {
                    const insertBefore = parentElement.childNodes[targetIndex] || null;
                    return { container: parentElement, insertBefore: insertBefore };
                }

                return { container: outputDOM, insertBefore: null };
            }


            createRouteElementMap(dom) {
                wsTraceHandler.sendTrace('[ROUTE-MAP]', 'Building route-to-element mapping for deletion capture');
                const routeMap = {};

                const mapElement = (element, route) => {
                    if (!element) return;

                    const routeKey = route.join(',');
                    routeMap[routeKey] = {
                        element: element,
                        nodeType: element.nodeType,
                        outerHTML: element.nodeType === Node.ELEMENT_NODE ? element.outerHTML : null,
                        textContent: element.textContent || '',
                        nodeName: element.nodeName || ''
                    };

                    // Recursively map child nodes
                    if (element.childNodes) {
                        for (let i = 0; i < element.childNodes.length; i++) {
                            const childRoute = [...route, i];
                            mapElement(element.childNodes[i], childRoute);
                        }
                    }
                };

                // Start mapping from root with empty route
                mapElement(dom, []);

                wsTraceHandler.sendTrace('[ROUTE-MAP]', `Created mapping for ${Object.keys(routeMap).length} DOM nodes`);
                return routeMap;
            }

            enhanceOperationsWithCapturedContent(diffOperations, routeElementMap) {
                wsTraceHandler.sendTrace('[ENHANCE]', `Enhancing ${diffOperations.length} operations with pre-captured content`);

                let deletionsFound = 0;
                let deletionsEnhanced = 0;

                for (const op of diffOperations) {
                    if (op.action === 'removeElement' || op.action === 'removeTextElement') {
                        deletionsFound++;
                        const routeKey = op.route.join(',');
                        wsTraceHandler.sendTrace('[ENHANCE]', `Enhancing deletion ${deletionsFound}: ${op.action} at route [${routeKey}]`);

                        const mappedElement = routeElementMap[routeKey];
                        if (mappedElement) {
                            if (mappedElement.nodeType === Node.TEXT_NODE) {
                                op.capturedContent = mappedElement.textContent;
                                op.capturedType = 'text';
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with captured text: "${mappedElement.textContent}"`);
                            } else if (mappedElement.nodeType === Node.ELEMENT_NODE) {
                                op.capturedContent = mappedElement.outerHTML;
                                op.capturedType = 'element';
                                const preview = mappedElement.outerHTML.substring(0, 100);
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with captured element: ${preview}${mappedElement.outerHTML.length > 100 ? '...' : ''}`);
                            } else {
                                op.capturedContent = mappedElement.textContent || `Unknown node: ${mappedElement.nodeName}`;
                                op.capturedType = 'unknown';
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with captured unknown node: ${op.capturedContent}`);
                            }
                            deletionsEnhanced++;
                        } else {
                            wsTraceHandler.sendTrace('[ENHANCE]', `No mapping found for deletion route [${routeKey}]`);
                            // Fallback to operation text if available
                            if (op.text) {
                                op.capturedContent = op.text;
                                op.capturedType = 'fallback-text';
                                deletionsEnhanced++;
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with fallback text: "${op.text}"`);
                            }
                        }
                    }
                }

                wsTraceHandler.sendTrace('[ENHANCE]', `Operation enhancement complete: ${deletionsEnhanced}/${deletionsFound} deletions enhanced`);
            }

            // ===== 8-PHASE HELPER METHODS =====

            // Phase 2: Create Detached Working DOM with Semantic Anchors
            createDetachedWorkingDOM(immutableToDOM) {
                wsTraceHandler.sendTrace('[DETACHED-WORKING]', 'Creating independent processing environment');
                const detachedDOM = document.createElement('div');
                this.deepCloneElement(immutableToDOM, detachedDOM);
                wsTraceHandler.sendTrace('[DETACHED-WORKING]', 'Detached Working DOM created from immutable input');
                return detachedDOM;
            }

            establishSemanticAnchors(detachedWorkingDOM) {
                wsTraceHandler.sendTrace('[SEMANTIC-ANCHORS]', 'Establishing fixed reference points for route resolution');
                const anchors = {};
                const walker = document.createTreeWalker(
                    detachedWorkingDOM,
                    NodeFilter.SHOW_ELEMENT,
                    null,
                    false
                );
                
                let node;
                let anchorIndex = 0;
                while (node = walker.nextNode()) {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const route = this.getElementRoute(node);
                        const anchorId = `anchor_${anchorIndex++}`;
                        anchors[anchorId] = {
                            element: node,
                            route: route,
                            tagName: node.tagName,
                            textContent: node.textContent.substring(0, 50) // Preview for debugging
                        };
                    }
                }
                
                wsTraceHandler.sendTrace('[SEMANTIC-ANCHORS]', `Established ${Object.keys(anchors).length} semantic anchors`);
                return anchors;
            }

            // Phase 3: Create Deletion Fact Table (DFK mapping)
            createDeletionFactTable(immutableFromDOM) {
                wsTraceHandler.sendTrace('[DFK]', 'Creating Deletion Fact Key mapping for stable fragment preservation');
                const deletionFactTable = {};
                
                const mapElementForDeletion = (element, route) => {
                    if (!element) return;
                    
                    const routeKey = route.join(',');
                    // Fix: Ensure DFK keys are never empty - use 'root' for empty routes
                    const dfk = routeKey === '' ? 'dfk_root' : `dfk_${routeKey.replace(/,/g, '_')}`;
                    
                    // Fix: Skip/reject empty DFK keys 
                    if (!dfk || dfk === 'dfk_') {
                        wsTraceHandler.sendTrace('[DFK-ERROR]', `Skipping invalid DFK key for route [${route.join(',')}]`);
                        return;
                    }
                    
                    deletionFactTable[dfk] = {
                        route: [...route], // Fix: Use spread to ensure immutable route copy
                        nodeType: element.nodeType,
                        outerHTML: element.nodeType === Node.ELEMENT_NODE ? element.outerHTML : null,
                        textContent: element.textContent || '',
                        nodeName: element.nodeName || '',
                        routeKey: routeKey
                    };
                    
                    // Recursively map child nodes with proper route spreading
                    if (element.childNodes) {
                        for (let i = 0; i < element.childNodes.length; i++) {
                            const childRoute = [...route, i]; // Fix: Proper route spreading
                            mapElementForDeletion(element.childNodes[i], childRoute);
                        }
                    }
                };
                
                // Fix: Rebuild DFT from pristine immutableFromDOM before any mutations
                mapElementForDeletion(immutableFromDOM, []);
                wsTraceHandler.sendTrace('[DFK]', `Created DFK mapping for ${Object.keys(deletionFactTable).length} potential deletions`);
                return deletionFactTable;
            }

            // Phase 4: Enhance operations with DFK
            enhanceOperationsWithDFK(diffOperations, deletionFactTable) {
                wsTraceHandler.sendTrace('[DFK-ENHANCE]', `Enhancing ${diffOperations.length} operations with DFK mappings`);
                
                for (const op of diffOperations) {
                    if (op.action === 'removeElement' || op.action === 'removeTextElement') {
                        const routeKey = op.route.join(',');
                        // Find matching DFK entry
                        const dfkEntry = Object.values(deletionFactTable).find(entry => entry.routeKey === routeKey);
                        if (dfkEntry) {
                            op.dfk = Object.keys(deletionFactTable).find(key => deletionFactTable[key] === dfkEntry);
                            op.capturedContent = dfkEntry.outerHTML || dfkEntry.textContent;
                            op.capturedType = dfkEntry.nodeType === Node.ELEMENT_NODE ? 'element' : 'text';
                            wsTraceHandler.sendTrace('[DFK-ENHANCE]', `Enhanced operation with DFK: ${op.dfk}`);
                        }
                    }
                }
                
                wsTraceHandler.sendTrace('[DFK-ENHANCE]', 'DFK enhancement completed');
            }

            // Phase 5: Assemble Annotated DOM
            assembleAnnotatedDOM(detachedWorkingDOM, diffOperations, semanticAnchors) {
                wsTraceHandler.sendTrace('[ASSEMBLY]', 'Processing diff operations in Detached Working environment using two-phase approach');
                
                // Phase A: Resolve all diff-op routes to concrete node references (no DOM writes)
                wsTraceHandler.sendTrace('[ASSEMBLY-RESOLVE]', `Resolving routes for ${diffOperations.length} operations`);
                const resolvedOperations = [];
                const preResolutionSnapshot = []; // Fix: Debug snapshot for route resolution
                
                for (const op of diffOperations) {
                    const resolvedOp = { ...op }; // Shallow copy operation
                    const targetElement = this.findElementByRoute(detachedWorkingDOM, op.route);
                    
                    // Fix: Record pre-resolution state
                    preResolutionSnapshot.push({
                        action: op.action,
                        route: [...op.route],
                        routeString: op.route.join(','),
                        resolved: !!targetElement,
                        targetNodeType: targetElement ? targetElement.nodeType : null,
                        targetTag: targetElement && targetElement.tagName ? targetElement.tagName : null
                    });
                    
                    if (targetElement) {
                        resolvedOp.resolvedElement = targetElement;
                        resolvedOp.resolved = true;
                        resolvedOperations.push(resolvedOp);
                    } else {
                        // If route fails, record single marker but continue with next op
                        resolvedOp.resolved = false;
                        resolvedOp.errorReason = 'Route traversal failed';
                        resolvedOperations.push(resolvedOp);
                        wsTraceHandler.sendTrace('[ASSEMBLY-RESOLVE-ERROR]', `Failed to resolve route [${op.route.join(',')}] for ${op.action}`);
                    }
                }
                
                // Fix: Emit phase5_routes_resolved debug snapshot
                const routesResolvedPayload = {
                    totalOperations: diffOperations.length,
                    resolvedCount: preResolutionSnapshot.filter(op => op.resolved).length,
                    failedCount: preResolutionSnapshot.filter(op => !op.resolved).length,
                    operations: preResolutionSnapshot
                };
                const timestamp = new Date().toISOString().replace(/[:.]/g, '').slice(0, -4);
                wsTraceHandler.sendDebugOutput('phase5_routes_resolved', JSON.stringify(routesResolvedPayload, null, 2), '', '', []);
                
                // Phase B: Apply annotations using resolved references only
                wsTraceHandler.sendTrace('[ASSEMBLY-APPLY]', `Applying annotations for ${resolvedOperations.filter(op => op.resolved).length} resolved operations`);
                const applyResult = this.applyAnnotationsFromResolved(detachedWorkingDOM, resolvedOperations);
                const assembledDOM = applyResult.outputDOM;
                
                // Fix: Emit phase5_apply_report debug snapshot
                const applyReportPayload = {
                    totalOperations: resolvedOperations.length,
                    appliedCount: applyResult.appliedCount,
                    skippedCount: applyResult.skippedCount,
                    errorCount: applyResult.errorCount,
                    appliedOperations: applyResult.appliedOperations,
                    skippedOperations: applyResult.skippedOperations,
                    errorOperations: applyResult.errorOperations
                };
                wsTraceHandler.sendDebugOutput('phase5_apply_report', JSON.stringify(applyReportPayload, null, 2), '', '', []);
                
                wsTraceHandler.sendTrace('[ASSEMBLY]', 'Two-phase semantic annotation assembly completed');
                return assembledDOM;
            }
            
            applyAnnotationsFromResolved(workingDOM, resolvedOperations) {
                wsTraceHandler.sendTrace('[ASSEMBLY-APPLY]', 'Applying annotations using pre-resolved node references');
                
                // Clone working DOM to avoid mutation during application
                const outputDOM = workingDOM.cloneNode(true);
                
                let insertions = 0, deletions = 0, moves = 0, modifications = 0, errors = 0;
                const processedDeletions = new Set();
                const appliedOperations = [];
                const skippedOperations = [];
                const errorOperations = [];
                
                // Process resolved operations in reverse order
                for (let i = resolvedOperations.length - 1; i >= 0; i--) {
                    const op = resolvedOperations[i];
                    
                    if (!op.resolved) {
                        // Insert single, non-intrusive error marker
                        this.insertSingleErrorMarker(outputDOM, op);
                        errorOperations.push({
                            action: op.action,
                            route: op.route.join(','),
                            reason: op.errorReason
                        });
                        errors++;
                        continue;
                    }
                    
                    // Apply annotation using resolved element reference
                    let applied = false;
                    switch (op.action) {
                        case 'addElement':
                        case 'addTextElement':
                            this.applyInsertionAnnotation(outputDOM, op);
                            insertions++;
                            applied = true;
                            break;
                        case 'removeElement':
                        case 'removeTextElement':
                            const routeKey = op.route.join(',');
                            if (!processedDeletions.has(routeKey)) {
                                this.generateDeletionInline(outputDOM, op);
                                processedDeletions.add(routeKey);
                                deletions++;
                                applied = true;
                            } else {
                                skippedOperations.push({
                                    action: op.action,
                                    route: routeKey,
                                    reason: 'Duplicate deletion'
                                });
                            }
                            break;
                        case 'relocateNode':
                            this.applyMoveAnnotation(outputDOM, op);
                            moves++;
                            applied = true;
                            break;
                        case 'modifyTextElement':
                            this.handleTextModification(outputDOM, op, {});
                            modifications++;
                            applied = true;
                            break;
                        case 'modifyAttribute':
                            this.applyModificationAnnotation(outputDOM, op);
                            modifications++;
                            applied = true;
                            break;
                    }
                    
                    if (applied) {
                        appliedOperations.push({
                            action: op.action,
                            route: op.route.join(','),
                            type: op.action.startsWith('add') ? 'insertion' : 
                                  op.action.startsWith('remove') ? 'deletion' :
                                  op.action.startsWith('relocate') ? 'move' : 'modification'
                        });
                    }
                }
                
                wsTraceHandler.sendTrace('[ASSEMBLY-APPLY]', `Applied: ${insertions} insertions, ${deletions} deletions, ${moves} moves, ${modifications} modifications, ${errors} errors`);
                
                return {
                    outputDOM,
                    appliedCount: insertions + deletions + moves + modifications,
                    skippedCount: skippedOperations.length,
                    errorCount: errors,
                    appliedOperations,
                    skippedOperations,
                    errorOperations
                };
            }

            // Phase 6: Place Deletion Blocks using DFK and Semantic Anchors
            placeDeletionBlocks(assembledDOM, diffOperations, deletionFactTable, semanticAnchors) {
                wsTraceHandler.sendTrace('[DELETION-PLACEMENT]', 'Positioning deletion blocks using DFK mappings and Semantic Anchors');
                
                // Clone the assembled DOM to avoid modifying input
                const deletionPlacedDOM = assembledDOM.cloneNode(true);
                
                // Fix: Track placed deletions to enforce "one logical deletion → one visual block"
                const placedDeletions = new Set();
                
                // Process deletion operations with correct DFK keys
                const deletionOps = diffOperations.filter(op => 
                    op.action === 'removeElement' || op.action === 'removeTextElement'
                ).reverse();
                
                for (const op of deletionOps) {
                    if (op.dfk && deletionFactTable[op.dfk]) {
                        // Fix: Check if this logical deletion was already placed
                        const routeKey = op.route.join(',');
                        if (placedDeletions.has(routeKey)) {
                            wsTraceHandler.sendTrace('[DELETION-SKIP]', `Skipped duplicate deletion for route [${routeKey}]`);
                            continue;
                        }
                        
                        // Fix: Find semantic anchor in "to" tree and attach as sibling/overlay
                        const insertPoint = this.findStableSemanticAnchor(deletionPlacedDOM, op.route);
                        if (insertPoint) {
                            this.placeSingleDeletionBlock(deletionPlacedDOM, op, insertPoint);
                            placedDeletions.add(routeKey);
                        }
                    }
                }
                
                wsTraceHandler.sendTrace('[DELETION-PLACEMENT]', `Positioned ${placedDeletions.size} unique deletion blocks`);
                return deletionPlacedDOM;
            }
            
            findStableSemanticAnchor(toDOM, route) {
                // Fix: Find semantic anchor (nearest stable block/id/href) in the "to" tree
                let bestAnchor = toDOM;
                let element = toDOM;
                
                // Traverse as far as possible to find stable anchor
                for (let i = 0; i < route.length; i++) {
                    const index = route[i];
                    if (element.childNodes && element.childNodes[index]) {
                        element = element.childNodes[index];
                        
                        // Prefer elements with stable identifiers as anchors
                        if (element.nodeType === Node.ELEMENT_NODE) {
                            if (element.id || element.className || element.tagName.match(/^(H[1-6]|P|DIV|SECTION|ARTICLE)$/)) {
                                bestAnchor = element;
                            }
                        }
                    } else {
                        break; // Stop at first invalid route segment
                    }
                }
                
                return bestAnchor;
            }
            
            placeSingleDeletionBlock(toDOM, operation, anchorElement) {
                // Fix: Attach single deletion block as sibling/overlay, not as new child
                const deletionBlock = document.createElement('span');
                deletionBlock.className = 'diff-deletion-block';
                deletionBlock.style.backgroundColor = '#f8d7da';
                deletionBlock.style.border = '1px solid #f5c6cb';
                deletionBlock.style.borderRadius = '3px';
                deletionBlock.style.padding = '2px 4px';
                deletionBlock.style.margin = '0 2px';
                deletionBlock.style.fontSize = '0.9em';
                deletionBlock.style.color = '#721c24';
                deletionBlock.style.display = 'inline-block';
                deletionBlock.textContent = `[DELETED: ${operation.capturedContent ? operation.capturedContent.substring(0, 50) : 'content'}...]`;
                
                // Insert as sibling to anchor element
                if (anchorElement.parentNode) {
                    anchorElement.parentNode.insertBefore(deletionBlock, anchorElement.nextSibling);
                    wsTraceHandler.sendTrace('[DELETION-BLOCK]', `Placed deletion block as sibling to ${anchorElement.tagName}`);
                } else {
                    // Fallback: append to DOM root
                    toDOM.appendChild(deletionBlock);
                    wsTraceHandler.sendTrace('[DELETION-BLOCK]', 'Placed deletion block at DOM root (fallback)');
                }
            }

            // Phase 8: Serialize Final Output
            serializeFinalOutput(coalescedDOM) {
                wsTraceHandler.sendTrace('[SERIALIZE]', 'Generating final styled diff HTML ready for display');
                
                // Final validation and cleanup
                const finalHTML = coalescedDOM.innerHTML;
                
                // Validate output integrity
                const parser = new DOMParser();
                const testDoc = parser.parseFromString(finalHTML, 'text/html');
                if (testDoc.querySelector('parsererror')) {
                    wsTraceHandler.sendTrace('[SERIALIZE-ERROR]', 'Final HTML contains parser errors');
                } else {
                    wsTraceHandler.sendTrace('[SERIALIZE]', 'Final HTML validated successfully');
                }
                
                return finalHTML;
            }




            showStatusMessage(message) {
                this.elements.statusSection.textContent = message;
                this.elements.statusSection.style.display = 'block';
            }

            hideStatusMessage() {
                this.elements.statusSection.style.display = 'none';
            }

            showCommitPopover(event, railRow) {
                const value = railRow.dataset.value;
                const commit = this.resolveCommit(value);
                if (!commit) return;

                // Position popover in upper-left of render pane (GADS compliant)
                this.positionPopoverInRenderPane();

                // Update popover content
                this.updateCommitPopoverContent(value, commit);

                // Show the popover
                this.elements.commitPopover.style.display = 'block';
            }

            updateCommitPopoverContent(value, commit) {
                // Determine status for GADMRC memo compliance
                const isHead = value === 'H';
                const isUnchanged = commit && this.manifest.commits.length > 1 &&
                    this.manifest.commits.some((c, i) => 
                        i > 0 && c.hash === commit.hash && 
                        c.html_sha256 === this.manifest.commits[i-1].html_sha256
                    );
                
                const status = isHead ? "HEAD" : (isUnchanged ? "No substantive change" : "Changed");

                this.elements.commitPopoverContent.innerHTML = `
                    <div class="popover-field">
                        <div class="popover-label">Position:</div>
                        <div class="popover-value">${value}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Hash:</div>
                        <div class="popover-value">${commit.hash}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Date:</div>
                        <div class="popover-value">${new Date(commit.timestamp ? 
                            commit.timestamp.replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, '$1-$2-$3T$4:$5:$6Z')
                            : commit.date || 'Unknown').toLocaleString()}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Message:</div>
                        <div class="popover-value">${commit.message}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">html_sha256:</div>
                        <div class="popover-value">${commit.html_sha256}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Status:</div>
                        <div class="popover-value">${status}</div>
                    </div>
                `;
            }

            hideCommitPopover() {
                this.elements.commitPopover.style.display = 'none';
            }

            positionPopoverInRenderPane() {
                // Position in upper-left of render pane as per GADS specification
                const renderPaneRect = this.elements.renderedPane.getBoundingClientRect();
                const popover = this.elements.commitPopover;

                popover.style.left = (renderPaneRect.left + 20) + 'px';
                popover.style.top = (renderPaneRect.top + 20) + 'px';
            }


        }

        // Initialize inspector when DOM and diff-dom are ready (GADS compliant initialization)
        let domReady = false;
        let diffDomReady = false;

        function checkInitialization() {
            if (domReady && diffDomReady) {
                console.log('[DEBUG] DOM and diff-dom ready, initializing inspector');
                console.log('[DEBUG]', `diff-dom available: ${typeof window.diffDom !== 'undefined'}`);
                if (typeof window.diffDom !== 'undefined') {
                    console.log('[DEBUG] diff-dom ESM loaded successfully');
                }
                window.gadInspector = new GadInspector();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log('[DEBUG] DOM loaded, waiting for diff-dom ESM');
            domReady = true;
            checkInitialization();
        });

        window.addEventListener('diff-dom-ready', () => {
            console.log('[DEBUG] diff-dom ESM ready');
            diffDomReady = true;
            checkInitialization();
        });
    </script>
</body>
</html>
