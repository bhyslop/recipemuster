<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GAD Inspector</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }


        .status-section {
            background: #e8f4fd;
            border: 1px solid #b3d9ff;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
            display: none;
        }

        .workspace {
            display: grid;
            grid-template-columns: auto auto 1fr;
            grid-template-rows: auto 1fr;
            grid-template-areas: 
                "railheader railheader renderheader"
                "from to render";
            gap: 0px;
            height: calc(100vh - 100px);
            margin-top: 20px;
        }

        .rail-header {
            grid-area: railheader;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: white;
            border-radius: 8px 8px 0 0;
            padding: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-bottom: 1px solid #eee;
            border-right: 1px solid #eee;
            font-weight: bold;
            color: #666;
        }

        .render-header {
            grid-area: renderheader;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border-radius: 8px 8px 0 0;
            padding: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-bottom: 1px solid #eee;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            color: #333;
        }

        .rail {
            background: white;
            border-radius: 0 0 8px 8px;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-y: auto;
            max-height: 100%;
        }

        .rail.from {
            grid-area: from;
            border-top-left-radius: 0;
            border-right: 1px solid #eee;
        }

        .rail.to {
            grid-area: to;
            border-top-right-radius: 0;
        }

        .rail-row {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 2px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .rail-row:hover {
            background-color: #f8f9fa;
        }

        .rail-row.selected {
            background-color: #e3f2fd;
            border: 1px solid #2196f3;
        }

        .rail-label {
            min-width: 30px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            font-weight: bold;
            color: #666;
            text-align: center;
        }

        .rail-radio {
            margin-left: auto;
        }

        .rail-commit-info {
            flex: 1;
            margin-left: 10px;
        }

        .rail-hash {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            color: #333;
        }

        .unchanged-rail-row {
            opacity: 0.6;
        }

        .unchanged-rail-row .rail-hash::after {
            content: " ≡";
            color: #888;
        }

        .rendered-pane {
            grid-area: render;
            background: white;
            border-radius: 0 0 8px 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-y: auto;
            max-height: 100%;
            line-height: 1.6;
        }

        .popover {
            position: fixed;
            background: white;
            border: 2px solid #007acc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 15px;
            z-index: 1000;
            display: none;
            max-width: 400px;
            min-width: 300px;
            font-size: 13px;
        }

        .popover-header {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        .popover-field {
            margin-bottom: 8px;
        }

        .popover-label {
            font-weight: bold;
            color: #555;
            font-size: 11px;
        }

        .popover-value {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: #f6f8fa;
            padding: 4px 6px;
            border-radius: 3px;
            border: 1px solid #e1e4e8;
            margin-top: 3px;
            word-break: break-all;
            font-size: 10px;
        }

        .swap-button {
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            margin: 0 6px;
        }

        .swap-button:hover {
            background: #005a9e;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .swap-button:active {
            transform: scale(0.95);
        }




        .unchanged-commit {
            opacity: 0.6;
        }

        .unchanged-commit::after {
            content: " ≡";
            color: #888;
        }

        /* Diff styling - Block-level annotations with GADS-compliant deletions */
        .diff-deletion {
            background-color: #ffeef0;
            color: #d73a49;
            text-decoration: line-through;
            display: inline; /* Inline display for deletions */
            border: 1px solid #f97583;
            border-radius: 2px;
            padding: 1px 3px;
            margin: 0 2px;
        }

        .gad-deleted {
            background-color: #ffeef0;
            color: #d73a49;
            text-decoration: line-through;
            border: 1px solid #f97583;
            border-radius: 3px;
            padding: 8px 12px;
            margin: 8px 0;
            display: block;
            font-style: italic;
        }

        .gad-deleted::before {
            content: "[DELETED] ";
            font-weight: bold;
        }

        .diff-insertion {
            background-color: #f0fff4;
            border: 1px solid #28a745;
            border-radius: 3px;
            /* Block-level background highlighting */
            padding: 4px;
        }

        .diff-moved {
            background-color: #fff3cd;
            border: 1px solid #856404;
            border-radius: 3px;
            /* Block-level background highlighting */
            padding: 4px;
        }

        .diff-modification {
            background-color: #e2e3e5;
            border: 1px solid #6c757d;
            border-radius: 3px;
            /* Block-level background highlighting for text changes */
            padding: 4px;
        }

        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .error {
            color: #d73a49;
            background: #ffeef0;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #f97583;
        }
    </style>
</head>
<body>
    <div class="status-section" id="statusSection"></div>

    <div class="workspace">
        <div class="rail-header">
            F <button class="swap-button" id="swapButton" title="Transpose rail positions">⇄</button> T
        </div>

        <div class="render-header" id="comparisonHeader">
            <!-- Commit comparison will be displayed here -->
        </div>

        <div class="rail from" id="fromRail">
            <div id="fromRailContent">
                <div class="loading">Loading...</div>
            </div>
        </div>

        <div class="rail to" id="toRail">
            <div id="toRailContent">
                <div class="loading">Loading...</div>
            </div>
        </div>

        <div class="rendered-pane" id="renderedPane">
            <div class="loading">Loading manifest...</div>
        </div>
    </div>

    <div class="popover" id="commitPopover">
        <div class="popover-header">Commit Details</div>
        <div id="commitPopoverContent">
        </div>
    </div>

    <script type="module">
        // Use ESM import for modern diff-dom
        import { DiffDOM } from 'https://cdn.skypack.dev/diff-dom@5.2.0';
        window.diffDom = { DiffDOM };
        console.log('[DEBUG] diff-dom loaded via ESM:', typeof DiffDOM);
        // Trigger initialization if DOM is already ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => window.dispatchEvent(new Event('diff-dom-ready')));
        } else {
            window.dispatchEvent(new Event('diff-dom-ready'));
        }
    </script>
    <script>
        // Trace buffer implementation per GADS specification
        class TraceBuffer {
            constructor() {
                this.maxEntries = 1000;
                this.storageKey = 'gad_trace_buffer';
                this.loadBuffer();
            }

            loadBuffer() {
                try {
                    const stored = sessionStorage.getItem(this.storageKey);
                    this.entries = stored ? JSON.parse(stored) : [];
                } catch (e) {
                    this.entries = [];
                }
            }

            saveBuffer() {
                try {
                    sessionStorage.setItem(this.storageKey, JSON.stringify(this.entries));
                } catch (e) {
                    console.warn('Failed to save trace buffer to sessionStorage');
                }
            }

            append(prefix, message) {
                const timestamp = new Date().toISOString();
                const entry = `${timestamp} ${prefix} ${message}`;
                this.entries.push(entry);

                // Maintain rolling buffer
                if (this.entries.length > this.maxEntries) {
                    this.entries = this.entries.slice(-this.maxEntries);
                }

                this.saveBuffer();
                console.log(entry);
            }

            getContents() {
                return this.entries.join('\n');
            }
        }

        const traceBuffer = new TraceBuffer();

        // WebSocket trace handler for GADS compliance
        class WebSocketTraceHandler {
            constructor() {
                this.ws = null;
                // Don't connect immediately - wait for successful manifest fetch
            }

            connectAfterManifest() {
                // Only attempt connection after successful manifest fetch (GADS compliant)
                try {
                    const wsPort = window.location.port || 8080; // Use same port as HTTP
                    const wsUrl = `ws://${window.location.hostname}:${wsPort}/ws`;
                    console.log(`[DEBUG] Factory available, attempting WebSocket connection to: ${wsUrl}`);
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('[DEBUG] WebSocket connected after manifest success');
                    };

                    this.ws.onerror = (error) => {
                        console.log('[DEBUG] WebSocket error (non-fatal):', error);
                    };

                    this.ws.onclose = () => {
                        console.log('[DEBUG] WebSocket disconnected');
                    };
                } catch (error) {
                    console.log('[DEBUG] WebSocket connection failed (non-fatal):', error);
                }
            }

            connect() {
                // Legacy method - should not be called in GADS compliant flow
                console.warn('[WARN] connect() called - should use connectAfterManifest() per GADS specification');
                this.connectAfterManifest();
            }

            sendTrace(prefix, message) {
                // Always log to console, send to WebSocket if available
                console.log(`${prefix} ${message}`);

                // Send to WebSocket if connected
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    try {
                        this.ws.send(JSON.stringify({
                            type: 'trace',
                            message: `${prefix} ${message}`
                        }));
                    } catch (error) {
                        // WebSocket error is not critical
                        console.log(`[WS-ERROR] Failed to send trace: ${error}`);
                    }
                }
            }

            sendRenderedContent(htmlContent, fromCommit, toCommit, sourceFiles) {
                // Send rendered content to Factory for gadfd_rendered_capture creation if WebSocket available
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    try {
                        const timestamp = new Date().toISOString().replace(/[-:]/g, '').replace(/\..+/, '');
                        const fromHash = fromCommit ? fromCommit.hash.substring(0, 12) : 'unknown';
                        const toHash = toCommit ? toCommit.hash.substring(0, 12) : 'unknown';
                        
                        this.ws.send(JSON.stringify({
                            type: 'rendered_content',
                            content: htmlContent,
                            filename_pattern: `debug-rendered-${fromHash}-${toHash}-${timestamp}.html`,
                            source_files: sourceFiles || []
                        }));
                        console.log('[RENDERED-CONTENT] Sent to Factory for gadfd_rendered_capture creation');
                    } catch (error) {
                        console.log(`[WS-ERROR] Failed to send rendered content: ${error}`);
                    }
                }
                // Silent if WebSocket not available - this is optional functionality
            }
        }

        const wsTraceHandler = new WebSocketTraceHandler();

        // GAD Inspector implementation
        class GadInspector {
            constructor() {
                this.manifest = null;
                this.currentChanges = [];
                this.currentChangeIndex = 0;

                console.log('[DEBUG] GadInspector constructor called');
                this.initializeElements();
                this.setupEventListeners();
                this.loadManifest();
            }

            initializeElements() {
                console.log('[DEBUG] Initializing DOM elements');
                this.elements = {
                    comparisonHeader: document.getElementById('comparisonHeader'),
                    statusSection: document.getElementById('statusSection'),
                    fromRail: document.getElementById('fromRail'),
                    fromRailContent: document.getElementById('fromRailContent'),
                    toRail: document.getElementById('toRail'),
                    toRailContent: document.getElementById('toRailContent'),
                    swapButton: document.getElementById('swapButton'),
                    renderedPane: document.getElementById('renderedPane'),
                    commitPopover: document.getElementById('commitPopover'),
                    commitPopoverContent: document.getElementById('commitPopoverContent'),
                };

                // Initialize selections
                this.selectedFrom = null;
                this.selectedTo = null;

                // Check if all elements were found
                Object.entries(this.elements).forEach(([key, element]) => {
                    if (!element) {
                        console.log(`[ERROR] Failed to find DOM element: ${key}`);
                    }
                });
                console.log('[DEBUG] DOM elements initialized');
            }

            setupEventListeners() {
                this.elements.swapButton.addEventListener('click', () => this.onSwapClick());

                // Rail hover for popover display
                let hoverTimeout;
                let currentHoveredRow = null;

                [this.elements.fromRail, this.elements.toRail].forEach(rail => {
                    rail.addEventListener('mouseover', (e) => {
                        const railRow = e.target.closest('.rail-row');
                        if (!railRow) return;

                        // Clear any existing timeout
                        if (hoverTimeout) {
                            clearTimeout(hoverTimeout);
                        }

                        currentHoveredRow = railRow;

                        // Show popover after 200ms delay (GADS compliant)
                        hoverTimeout = setTimeout(() => {
                            this.showCommitPopover(e, railRow);
                        }, 200);
                    });

                    rail.addEventListener('mouseout', (e) => {
                        const railRow = e.target.closest('.rail-row');
                        if (!railRow) return;

                        // Clear timeout if mouse leaves before delay
                        if (hoverTimeout) {
                            clearTimeout(hoverTimeout);
                            hoverTimeout = null;
                        }

                        currentHoveredRow = null;

                        // Hide popover immediately (GADS compliant)
                        this.hideCommitPopover();
                    });
                });

                // Parse URL hash on load
                window.addEventListener('load', () => this.parseUrlHash());
                window.addEventListener('hashchange', () => this.parseUrlHash());
            }

            async loadManifest() {
                wsTraceHandler.sendTrace('[DEBUG]', 'Starting manifest load');
                wsTraceHandler.sendTrace('[MANIFEST]', 'Loading start');

                try {
                    wsTraceHandler.sendTrace('[DEBUG]', 'Fetching manifest.json');
                    wsTraceHandler.sendTrace('[DEBUG]', `Fetch URL: ${window.location.origin}/manifest.json`);
                    const response = await fetch('manifest.json');
                    wsTraceHandler.sendTrace('[DEBUG]', `Fetch response status: ${response.status}`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    wsTraceHandler.sendTrace('[DEBUG]', 'Parsing manifest JSON');
                    this.manifest = await response.json();
                    wsTraceHandler.sendTrace('[DEBUG]', `Manifest loaded successfully with ${this.manifest.commits.length} commits`);
                    wsTraceHandler.sendTrace('[MANIFEST]', `Successful load with ${this.manifest.commits.length} commits`);

                    // Now that Factory is confirmed available, attempt WebSocket connection
                    wsTraceHandler.connectAfterManifest();

                    wsTraceHandler.sendTrace('[DEBUG]', 'Starting populateRails');
                    this.populateRails();
                    wsTraceHandler.sendTrace('[DEBUG]', 'populateRails completed');

                    wsTraceHandler.sendTrace('[DEBUG]', 'Starting parseUrlHash');
                    this.parseUrlHash();
                    wsTraceHandler.sendTrace('[DEBUG]', 'parseUrlHash completed');

                } catch (error) {
                    wsTraceHandler.sendTrace('[DEBUG]', `Manifest load failed: ${error.message}`);
                    wsTraceHandler.sendTrace('[MANIFEST]', `Load failure: ${error.message}`);
                    this.elements.renderedPane.innerHTML = `
                        <div class="error">
                            <h3>Failed to load manifest.json</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            }

            populateRails() {
                wsTraceHandler.sendTrace('[DEBUG]', 'Clearing rail content');
                // Clear existing content
                this.elements.fromRailContent.innerHTML = '';
                this.elements.toRailContent.innerHTML = '';

                wsTraceHandler.sendTrace('[DEBUG]', 'Rails will be populated with commits only (no magic values)');

                wsTraceHandler.sendTrace('[DEBUG]', `Processing ${this.manifest.commits.length} commits for rails`);
                // Reverse commits first, then apply simple labeling like GADMRC
                const reversedCommits = [...this.manifest.commits].reverse();
                reversedCommits.forEach((commit, index) => {
                    wsTraceHandler.sendTrace('[DEBUG]', `Processing commit ${index + 1}: ${commit.hash.substring(0, 8)}`);
                    const isUnchanged = index > 0 &&
                        commit.html_sha256 === reversedCommits[index - 1].html_sha256;

                    // GADMRC-compliant labeling: H for index 0, -1, -2, etc. for rest
                    const position = index === 0 ? 'H' : `-${index}`;

                    // Use position as the value, store commit data in dataset (no hash display)
                    this.addRailRow(this.elements.fromRailContent, position, position, 'from', null, isUnchanged, commit);
                    this.addRailRow(this.elements.toRailContent, position, position, 'to', null, isUnchanged, commit);
                });
                wsTraceHandler.sendTrace('[DEBUG]', 'Rail population completed');
                
                // Set default selections per GADS spec: From = -1, To = H
                this.setDefaultSelections();
            }
            
            setDefaultSelections() {
                // Only set defaults if no current selections
                if (!this.selectedFrom && !this.selectedTo) {
                    wsTraceHandler.sendTrace('[DEBUG]', 'Setting default selections: From = -1, To = H');
                    this.setRailSelection('from', '-1', true);  // Skip diff on first
                    this.setRailSelection('to', 'H', false);    // Perform diff on second
                }
            }

            addRailRow(railContent, value, label, railType, hashText = null, isUnchanged = false, commit = null) {
                const row = document.createElement('div');
                row.className = 'rail-row' + (isUnchanged ? ' unchanged-rail-row' : '');
                row.dataset.value = value;
                row.dataset.railType = railType;
                
                // Store commit data for position resolution
                if (commit) {
                    row.dataset.commitHash = commit.hash;
                    row.dataset.commitData = JSON.stringify(commit);
                }

                const labelElement = document.createElement('div');
                labelElement.className = 'rail-label';
                labelElement.textContent = label;

                const commitInfo = document.createElement('div');
                commitInfo.className = 'rail-commit-info';
                
                // GADMRC-compliant: show only position labels, no hash text in rails
                if (hashText) {
                    const hashElement = document.createElement('div');
                    hashElement.className = 'rail-hash';
                    hashElement.textContent = hashText;
                    commitInfo.appendChild(hashElement);
                } else {
                    // Empty info div - position label is sufficient
                    commitInfo.style.display = 'none';
                }

                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = railType + 'Selection';
                radio.className = 'rail-radio';
                radio.value = value;

                // Add click handler for selection
                row.addEventListener('click', () => {
                    this.selectRailRow(row, railType);
                });

                radio.addEventListener('change', () => {
                    if (radio.checked) {
                        this.selectRailRow(row, railType);
                    }
                });

                row.appendChild(labelElement);
                row.appendChild(commitInfo);
                row.appendChild(radio);

                railContent.appendChild(row);
            }

            selectRailRow(row, railType, skipDiff = false) {
                const value = row.dataset.value;
                
                // Clear previous selection in this rail
                const railContent = railType === 'from' ? this.elements.fromRailContent : this.elements.toRailContent;
                railContent.querySelectorAll('.rail-row').forEach(r => r.classList.remove('selected'));
                
                // Set new selection
                row.classList.add('selected');
                const radio = row.querySelector('.rail-radio');
                if (radio) radio.checked = true;

                // Store selection
                const previousValue = railType === 'from' ? this.selectedFrom : this.selectedTo;
                if (railType === 'from') {
                    this.selectedFrom = value;
                } else {
                    this.selectedTo = value;
                }

                wsTraceHandler.sendTrace('[SELECTION]', `${railType} rail selected: ${value}`);
                
                // Only perform diff if selection actually changed and not skipped
                if (previousValue !== value && !skipDiff) {
                    this.updateUrlHash();
                    this.performDiff();
                }
            }

            setRailSelection(railType, value, skipDiff = false) {
                const railContent = railType === 'from' ? this.elements.fromRailContent : this.elements.toRailContent;
                const targetRow = railContent.querySelector(`[data-value="${value}"]`);
                
                if (targetRow) {
                    this.selectRailRow(targetRow, railType, skipDiff);
                } else {
                    wsTraceHandler.sendTrace('[DEBUG]', `Rail row not found for value: ${value} in ${railType} rail`);
                }
            }

            parseUrlHash() {
                wsTraceHandler.sendTrace('[DEBUG]', `parseUrlHash called with hash: "${window.location.hash}"`);
                const hash = window.location.hash.substring(1);
                const params = new URLSearchParams(hash);

                const fromHash = params.get('from');
                const toHash = params.get('to');
                wsTraceHandler.sendTrace('[DEBUG]', `Parsed URL params - from: "${fromHash}", to: "${toHash}"`);

                // Convert commit hashes to position values for rail selection
                let fromPosition = null;
                let toPosition = null;

                if (fromHash) {
                    fromPosition = this.hashToPosition(fromHash);
                    if (fromPosition) {
                        wsTraceHandler.sendTrace('[DEBUG]', `Setting from rail to position: ${fromPosition} (from hash: ${fromHash})`);
                        this.setRailSelection('from', fromPosition);
                    } else {
                        wsTraceHandler.sendTrace('[DEBUG]', `Failed to resolve from hash: ${fromHash}`);
                    }
                }

                if (toHash) {
                    toPosition = this.hashToPosition(toHash);
                    if (toPosition) {
                        wsTraceHandler.sendTrace('[DEBUG]', `Setting to rail to position: ${toPosition} (from hash: ${toHash})`);
                        this.setRailSelection('to', toPosition);
                    } else {
                        wsTraceHandler.sendTrace('[DEBUG]', `Failed to resolve to hash: ${toHash}`);
                    }
                }

                if (fromPosition || toPosition) {
                    wsTraceHandler.sendTrace('[DEBUG]', 'URL params found, calling performDiff');
                    this.performDiff();
                } else {
                    wsTraceHandler.sendTrace('[DEBUG]', 'No URL params found, not calling performDiff');
                }
            }

            hashToPosition(commitHash) {
                if (!commitHash || !this.manifest || !this.manifest.commits) {
                    return null;
                }

                // Find the commit by hash
                const commitIndex = this.manifest.commits.findIndex(c => c.hash === commitHash);
                if (commitIndex === -1) {
                    return null;
                }

                // Convert index to position value (H for head, -1, -2, etc.)
                if (commitIndex === this.manifest.commits.length - 1) {
                    return 'H';
                } else {
                    const offset = this.manifest.commits.length - 1 - commitIndex;
                    return `-${offset}`;
                }
            }

            onSwapClick() {
                const fromValue = this.selectedFrom;
                const toValue = this.selectedTo;

                wsTraceHandler.sendTrace('[SWAP]', `Transposing rail positions: ${fromValue} <-> ${toValue}`);

                // Transpose the column positions by exchanging selections
                // Skip diff on first selection, perform only on second
                this.setRailSelection('from', toValue, true);  // Skip diff
                this.setRailSelection('to', fromValue, false); // Perform diff

                // Update URL hash after both selections are set
                this.updateUrlHash();
            }

            updateUrlHash() {
                const fromCommit = this.resolveCommit(this.selectedFrom);
                const toCommit = this.resolveCommit(this.selectedTo);

                if (fromCommit && toCommit) {
                    window.location.hash = `from=${encodeURIComponent(fromCommit.hash)}&to=${encodeURIComponent(toCommit.hash)}`;
                }
            }

            async performDiff() {
                const fromValue = this.selectedFrom;
                const toValue = this.selectedTo;

                if (!fromValue || !toValue) return;

                try {
                    wsTraceHandler.sendTrace('[RESOLVE]', 'Magic value resolution start');

                    const fromCommit = this.resolveCommit(fromValue);
                    const toCommit = this.resolveCommit(toValue);

                    if (!fromCommit || !toCommit) {
                        wsTraceHandler.sendTrace('[ERROR]', 'Invalid magic values or missing commits in manifest');
                        throw new Error('Failed to resolve commits');
                    }

                    wsTraceHandler.sendTrace('[RESOLVE]', `Resolved from: ${fromCommit.hash.substring(0, 8)}, to: ${toCommit.hash.substring(0, 8)}`);

                    // Update comparison header
                    this.elements.comparisonHeader.textContent =
                        `${fromCommit.hash.substring(0, 8)} → ${toCommit.hash.substring(0, 8)}`;

                    // Check for identical SHA256
                    if (fromCommit.html_sha256 === toCommit.html_sha256) {
                        wsTraceHandler.sendTrace('[SHA256]', 'Detection of identical html_sha256 values between selected commits');
                        this.showStatusMessage('These commits have identical rendered content');
                    } else {
                        wsTraceHandler.sendTrace('[SHA256]', 'Detection of different html_sha256 values between selected commits');
                        this.hideStatusMessage();
                    }

                    await this.fetchAndDiff(fromCommit, toCommit);

                } catch (error) {
                    wsTraceHandler.sendTrace('[ERROR]', `Diff error: ${error.message}`);
                    this.elements.renderedPane.innerHTML = `
                        <div class="error">
                            <h3>Diff Error</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            }

            resolveCommit(positionValue) {
                // First check: direct hash lookup
                const commitByHash = this.manifest.commits.find(c => c.hash === positionValue);
                if (commitByHash) {
                    return commitByHash;
                }

                // Second check: position value handling
                if (positionValue === 'H') {
                    return this.manifest.commits[this.manifest.commits.length - 1];
                } else if (positionValue.startsWith('-')) {
                    const offset = parseInt(positionValue.substring(1));
                    const index = this.manifest.commits.length - 1 - offset;
                    return index >= 0 ? this.manifest.commits[index] : null;
                }

                return null;
            }

            async fetchAndDiff(fromCommit, toCommit) {
                wsTraceHandler.sendTrace('[FETCH]', `HTML fetch start for ${fromCommit.html_file} and ${toCommit.html_file}`);

                try {
                    const [fromResponse, toResponse] = await Promise.all([
                        fetch(`/output/${fromCommit.html_file}`),
                        fetch(`/output/${toCommit.html_file}`)
                    ]);

                    if (!fromResponse.ok || !toResponse.ok) {
                        throw new Error('Failed to fetch HTML files');
                    }

                    const [fromHtml, toHtml] = await Promise.all([
                        fromResponse.text(),
                        toResponse.text()
                    ]);

                    wsTraceHandler.sendTrace('[FETCH]', 'Successful fetch completion');
                    wsTraceHandler.sendTrace('[DIFF]', 'Diff computation start');

                    // Use diff-dom library
                    const styledDiff = this.styleDiff(fromHtml, toHtml);

                    this.elements.renderedPane.innerHTML = styledDiff;

                    // Prepare source file information for gadfd_rendered_capture
                    const sourceFiles = [
                        `From: /output/${fromCommit.html_file}`,
                        `To: /output/${toCommit.html_file}`
                    ];

                    // Send rendered content to Factory via WebSocket for gadfd_rendered_capture
                    wsTraceHandler.sendRenderedContent(styledDiff, fromCommit, toCommit, sourceFiles);

                    // Enhanced logging for Factory debugging
                    const changeTypeBreakdown = {
                        insertions: this.elements.renderedPane.querySelectorAll('.diff-insertion').length,
                        moves: this.elements.renderedPane.querySelectorAll('.diff-moved').length,
                        deletions: this.elements.renderedPane.querySelectorAll('.diff-deletion').length,
                        modifications: this.elements.renderedPane.querySelectorAll('.diff-modification').length
                    };

                    const totalChanges = changeTypeBreakdown.insertions + changeTypeBreakdown.moves + 
                                       changeTypeBreakdown.deletions + changeTypeBreakdown.modifications;

                    // Debug trace for change counting
                    wsTraceHandler.sendTrace('[COUNT]', `Found ${totalChanges} total changes in rendered output`);
                    wsTraceHandler.sendTrace('[COUNT]', `Breakdown: ${changeTypeBreakdown.insertions} insertions, ${changeTypeBreakdown.moves} moves, ${changeTypeBreakdown.deletions} deletions, ${changeTypeBreakdown.modifications} modifications`);

                    wsTraceHandler.sendTrace('[DIFF]', `Completion with ${totalChanges} total changes`);
                    wsTraceHandler.sendTrace('[DIFF]', `Change breakdown: ${JSON.stringify(changeTypeBreakdown)}`);

                } catch (error) {
                    // Enhanced error reporting for Factory debugging
                    if (error.message.includes('diff-dom')) {
                        wsTraceHandler.sendTrace('[ERROR]', `diff-dom library failure: ${error.message}`);
                    } else if (error.message.includes('fetch') || error.message.includes('HTTP')) {
                        wsTraceHandler.sendTrace('[FETCH]', `Fetch failure: ${error.message}`);
                    } else {
                        wsTraceHandler.sendTrace('[ERROR]', `GADS processing failure: ${error.message}`);
                    }

                    // Additional debugging context
                    wsTraceHandler.sendTrace('[DEBUG]', `Error occurred during diff processing for commits: ${fromCommit?.hash?.substring(0,8)} → ${toCommit?.hash?.substring(0,8)}`);
                    throw error;
                }
            }

            styleDiff(fromHtml, toHtml) {
                const startTime = performance.now();
                wsTraceHandler.sendTrace('[DIFF]', 'Starting GADS-compliant immutable diff processing');
                wsTraceHandler.sendTrace('[DEBUG]', `Input sizes: fromHtml=${fromHtml.length} chars, toHtml=${toHtml.length} chars`);
                wsTraceHandler.sendTrace('[DEBUG]', `diff-dom type at diff time: ${typeof window.diffDom}`);

                if (typeof window.diffDom === 'undefined' || typeof window.diffDom.DiffDOM === 'undefined') {
                    throw new Error('diff-dom library not available - required for diff processing');
                }

                try {
                    // Phase 1: Create Immutable Input DOMs (never modify these)
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 1: Creating immutable input DOM trees');
                    const immutableFromDOM = this.createDOMFromHTML(fromHtml);
                    const immutableToDOM = this.createDOMFromHTML(toHtml);
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 1: Immutable DOM trees created and preserved');

                    // Phase 2: Pre-capture Deletion Content
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 2: Pre-capturing deletion content from immutable fromDOM');
                    const routeElementMap = this.createRouteElementMap(immutableFromDOM);
                    wsTraceHandler.sendTrace('[DEBUG]', `Pre-captured ${Object.keys(routeElementMap).length} elements for deletion handling`);


                    // Phase 3: Generate Diff Operations
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 3: Generating diff operations via diff-dom');
                    const diffDOM = new window.diffDom.DiffDOM({
                        debug: true,
                        diffcap: 500  // Allow more granular detection
                    });
                    const diffOperations = diffDOM.diff(immutableFromDOM, immutableToDOM);

                    // Enhanced operation logging for debugging
                    wsTraceHandler.sendTrace('[DIFF-OPS]', `Generated ${diffOperations.length} operations`);
                    diffOperations.forEach((op, index) => {
                        wsTraceHandler.sendTrace('[DIFF-OP]', `${index}: ${op.action} at route [${op.route.join(',')}]${op.oldValue ? ` oldValue: "${op.oldValue}"` : ''}${op.newValue ? ` newValue: "${op.newValue}"` : ''}`);
                    });

                    // Enhance operations with pre-captured content
                    this.enhanceOperationsWithCapturedContent(diffOperations, routeElementMap);

                    wsTraceHandler.sendTrace('[DIFF]', `Phase 3: Generated ${diffOperations.length} diff operations`);

                    // Phase 4: Generate Clean Output DOM
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 4: Generating clean output DOM from immutable inputs');
                    const outputDOM = this.generateOutputDOM(immutableToDOM, diffOperations, routeElementMap);
                    wsTraceHandler.sendTrace('[DIFF]', 'Phase 4: Clean output DOM generation completed');

                    // Performance logging for Factory debugging
                    const endTime = performance.now();
                    const totalTime = Math.round(endTime - startTime);
                    wsTraceHandler.sendTrace('[PERF]', `GADS immutable diff processing completed in ${totalTime}ms`);
                    wsTraceHandler.sendTrace('[ARCH]', 'Input DOMs remain completely unmodified throughout processing');

                    return outputDOM.innerHTML;

                } catch (error) {
                    wsTraceHandler.sendTrace('[ERROR]', `GADS immutable diff processing failed: ${error.message}`);
                    throw error;
                }
            }

            // Phase 1: Block Identification - GADS compliant implementation
            identifyBlocks(html, source) {
                wsTraceHandler.sendTrace('[DEBUG]', `Block identification starting for ${source}`);

                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const blocks = [];

                // Target block-level elements per GADS specification
                const blockElements = ['P', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6',
                                      'LI', 'TD', 'TH', 'BLOCKQUOTE', 'PRE', 'SECTION', 'ARTICLE',
                                      'HEADER', 'FOOTER', 'NAV', 'ASIDE', 'MAIN'];

                const walker = doc.createTreeWalker(
                    doc.body || doc.documentElement,
                    NodeFilter.SHOW_ELEMENT,
                    {
                        acceptNode: function(node) {
                            return blockElements.includes(node.tagName) ?
                                NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
                        }
                    }
                );

                let node;
                let blockIndex = 0;
                while (node = walker.nextNode()) {
                    // Generate unique identifier based on element type, DOM path, and content
                    const domPath = this.getDomPath(node);
                    const textContent = node.textContent.trim();
                    const blockId = `${node.tagName}-${blockIndex}-${this.hashString(domPath + textContent)}`;

                    blocks.push({
                        id: blockId,
                        source: source,  // Track source separately
                        element: node,
                        tagName: node.tagName,
                        domPath: domPath,
                        textContent: textContent,
                        innerHTML: node.innerHTML,
                        index: blockIndex
                    });

                    blockIndex++;
                }

                wsTraceHandler.sendTrace('[DEBUG]', `Block identification completed for ${source}: ${blocks.length} blocks`);
                return blocks;
            }

            getDomPath(element) {
                const path = [];
                let current = element;
                while (current && current.nodeType === Node.ELEMENT_NODE) {
                    let selector = current.tagName.toLowerCase();
                    if (current.id) {
                        selector += '#' + current.id;
                    } else if (current.className) {
                        selector += '.' + current.className.split(/\s+/).join('.');
                    }
                    path.unshift(selector);
                    current = current.parentElement;
                }
                return path.join(' > ');
            }

            hashString(str) {
                // Simple hash function for unique identifiers
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash).toString(16);
            }

            linearizeBlocks(blocks) {
                wsTraceHandler.sendTrace('[DEBUG]', `Linearizing ${blocks.length} blocks`);

                // Create text linearization preserving block boundaries with identical separator markers
                const BLOCK_START = '⟨BLOCK⟩';
                const BLOCK_END = '⟨/BLOCK⟩';
                const linearized = blocks.map(block => {
                    return `${BLOCK_START}${block.textContent}${BLOCK_END}`;
                }).join('\n');

                wsTraceHandler.sendTrace('[DEBUG]', `Linearization completed, length: ${linearized.length}`);
                return linearized;
            }

            // Helper method for creating DOM from HTML strings
            createDOMFromHTML(html) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                return doc.body;
            }

            findElementByRoute(dom, route) {
                let element = dom;
                for (let i = 0; i < route.length; i++) {
                    const index = route[i];
                    if (element.childNodes && element.childNodes[index]) {
                        element = element.childNodes[index];
                    } else {
                        const availableCount = element.childNodes ? element.childNodes.length : 0;

                        // Simple fix for diff-dom off-by-one indexing: try the last valid child
                        if (availableCount > 0 && index >= availableCount) {
                            const correctedIndex = availableCount - 1;
                            wsTraceHandler.sendTrace('[DEBUG]', `Route index ${index} out of bounds (${availableCount} children), trying last child at index ${correctedIndex}`);
                            element = element.childNodes[correctedIndex];
                        } else {
                            wsTraceHandler.sendTrace('[DEBUG]', `Route traversal failed at index ${index} for route [${route.join(',')}]`);
                            wsTraceHandler.sendTrace('[DEBUG]', `Parent has ${availableCount} children, requested index ${index}`);
                            wsTraceHandler.sendTrace('[DEBUG]', `Failed at route position ${i}, partial route was [${route.slice(0, i).join(',')}]`);
                            return null;
                        }
                    }
                }
                return element;
            }

            escapeHtml(unsafe) {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            extractTextFromHtml(htmlString) {
                try {
                    // Create a temporary element to parse HTML and extract text content
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlString;
                    return tempDiv.textContent || tempDiv.innerText || '';
                } catch (e) {
                    // Fallback: basic tag stripping
                    return htmlString.replace(/<[^>]*>/g, '').trim();
                }
            }

            generateOutputDOM(immutableToDOM, diffOperations, routeElementMap) {
                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Generating clean output DOM from ${diffOperations.length} operations`);

                // Create completely new output DOM structure - never modify inputs
                const outputDOM = document.createElement('div');

                // Deep clone the immutable "to" DOM structure as foundation
                this.deepCloneElement(immutableToDOM, outputDOM);
                wsTraceHandler.sendTrace('[OUTPUT-GEN]', 'Created output DOM foundation from immutable toDOM');

                // Apply diff annotations to output DOM with deduplication
                let insertions = 0, deletions = 0, moves = 0, modifications = 0;
                const processedDeletions = new Set(); // Track processed deletion routes to prevent duplicates

                // Process operations to generate annotations
                for (const op of diffOperations) {
                    switch (op.action) {
                        case 'addElement':
                        case 'addTextElement':
                            this.applyInsertionAnnotation(outputDOM, op);
                            insertions++;
                            break;
                        case 'removeElement':
                        case 'removeTextElement':
                            const routeKey = op.route.join(',');
                            if (!processedDeletions.has(routeKey)) {
                                this.generateDeletionBlock(outputDOM, op);
                                processedDeletions.add(routeKey);
                                deletions++;
                                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Processed unique deletion at route [${routeKey}]`);
                            } else {
                                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Skipped duplicate deletion at route [${routeKey}]`);
                            }
                            break;
                        case 'relocateNode':
                            this.applyMoveAnnotation(outputDOM, op);
                            moves++;
                            break;
                        case 'modifyTextElement':
                            // Handle text modifications as deletion + insertion pairs
                            this.handleTextModification(outputDOM, op, routeElementMap);
                            modifications++;
                            break;
                        case 'modifyAttribute':
                            // Only apply modification styling for attributes, don't double-annotate as insertion
                            this.applyModificationAnnotation(outputDOM, op);
                            modifications++;
                            break;
                        default:
                            wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Unknown operation type: ${op.action}`);
                    }
                }

                wsTraceHandler.sendTrace('[OUTPUT-GEN]', `Applied annotations: ${insertions} insertions, ${deletions} deletions (${processedDeletions.size} unique), ${moves} moves, ${modifications} modifications`);
                wsTraceHandler.sendTrace('[OUTPUT-GEN]', 'Output DOM generation completed with all annotations applied');

                return outputDOM;
            }

            isInlineElement(element) {
                const inlineElements = new Set(['A', 'SPAN', 'EM', 'STRONG', 'B', 'I', 'U', 'CODE', 'MARK', 'SMALL', 'SUP', 'SUB']);
                return inlineElements.has(element.tagName);
            }

            deepCloneElement(sourceElement, targetParent) {
                if (!sourceElement || !sourceElement.childNodes) return;

                // Clone all child nodes recursively
                for (let i = 0; i < sourceElement.childNodes.length; i++) {
                    const sourceChild = sourceElement.childNodes[i];
                    let clonedChild;

                    if (sourceChild.nodeType === Node.ELEMENT_NODE) {
                        // Create element with all attributes
                        clonedChild = document.createElement(sourceChild.tagName.toLowerCase());
                        for (let j = 0; j < sourceChild.attributes.length; j++) {
                            const attr = sourceChild.attributes[j];
                            clonedChild.setAttribute(attr.name, attr.value);
                        }
                        // Recursively clone children
                        this.deepCloneElement(sourceChild, clonedChild);
                    } else if (sourceChild.nodeType === Node.TEXT_NODE) {
                        clonedChild = document.createTextNode(sourceChild.textContent);
                    } else {
                        // Other node types (comments, etc.)
                        clonedChild = sourceChild.cloneNode(false);
                    }

                    if (clonedChild) {
                        targetParent.appendChild(clonedChild);
                    }
                }
            }

            applyInsertionAnnotation(outputDOM, operation) {
                const element = this.findElementByRoute(outputDOM, operation.route);
                if (element && element.nodeType === Node.ELEMENT_NODE) {
                    // For inline elements (A, SPAN, etc.) use inline highlighting
                    if (this.isInlineElement(element)) {
                        element.style.backgroundColor = '#d4edda';
                        element.style.padding = '2px';
                        element.style.borderRadius = '2px';
                        element.classList.add('diff-insertion');
                        wsTraceHandler.sendTrace('[INSERTION]', `Applied inline insertion annotation at route [${operation.route.join(',')}]`);
                    } else {
                        // For block elements, use full block styling
                        element.classList.add('diff-insertion');
                        element.style.backgroundColor = '#d4edda';
                        element.style.borderLeft = '4px solid #28a745';
                        element.style.padding = '4px';
                        wsTraceHandler.sendTrace('[INSERTION]', `Applied block insertion annotation at route [${operation.route.join(',')}]`);
                    }
                } else if (element && element.nodeType === Node.TEXT_NODE && element.parentElement) {
                    // For text insertions, create inline highlighting
                    const parent = element.parentElement;
                    const span = document.createElement('span');
                    span.classList.add('diff-insertion');
                    span.style.backgroundColor = '#d4edda';
                    span.style.padding = '2px';
                    span.style.borderRadius = '2px';

                    parent.insertBefore(span, element);
                    span.appendChild(element);

                    wsTraceHandler.sendTrace('[INSERTION]', `Applied insertion annotation with span wrapper at route [${operation.route.join(',')}]`);
                } else {
                    wsTraceHandler.sendTrace('[INSERTION]', `Could not find element for insertion annotation at route [${operation.route.join(',')}]`);
                }
            }

            applyMoveAnnotation(outputDOM, operation) {
                const element = this.findElementByRoute(outputDOM, operation.route);
                if (element && element.nodeType === Node.ELEMENT_NODE) {
                    element.classList.add('diff-moved');
                    element.style.backgroundColor = '#fff3cd';
                    element.style.borderLeft = '4px solid #ffc107';
                    wsTraceHandler.sendTrace('[MOVE]', `Applied move annotation at route [${operation.route.join(',')}]`);
                } else {
                    wsTraceHandler.sendTrace('[MOVE]', `Could not find element for move annotation at route [${operation.route.join(',')}]`);
                }
            }

            applyModificationAnnotation(outputDOM, operation) {
                // Don't apply modification styling to parent containers that have child insertions
                // This prevents the entire paragraph from being marked as modified when only parts changed
                wsTraceHandler.sendTrace('[MODIFICATION]', `Skipping broad modification annotation at route [${operation.route.join(',')}] - let child insertions handle specific changes`);
            }

            handleTextModification(outputDOM, operation, routeElementMap) {
                wsTraceHandler.sendTrace('[TEXT-MODIFY]', `Processing text modification at route [${operation.route.join(',')}]: "${operation.oldValue}" → "${operation.newValue}"`);

                // GADS Phase 3: Element Lookup - Traverse route to locate target element
                const element = this.findElementByRoute(outputDOM, operation.route);
                if (!element) {
                    const routeDetails = `Route traversal failed: Could not locate element at route [${operation.route.join(',')}] in output DOM. DOM structure may have changed during processing. Output DOM root: ${outputDOM.tagName || 'unknown'}`;
                    wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', routeDetails);
                    this.insertProcessingErrorMarker(outputDOM, operation.route, 'Route traversal failed', operation, routeDetails);
                    return;
                }

                // GADS Phase 3: Context Detection - Examine parent element type for deletion strategy
                const deletionStrategy = this.determineTextDeletionStrategy(element);
                wsTraceHandler.sendTrace('[TEXT-MODIFY]', `Deletion strategy: ${deletionStrategy.type} (parent: ${deletionStrategy.parentTag || 'none'})`);

                // GADS Phase 3: Content Validation - Verify target element content matches newValue (output DOM has new content)
                if (operation.oldValue && operation.oldValue !== operation.newValue) {
                    const contentMatches = this.validateElementContent(element, operation.newValue);
                    
                    if (contentMatches) {
                        // Apply deletion element using determined strategy - show what was deleted (oldValue)
                        this.applyDeletionElement(element, operation.oldValue, deletionStrategy);
                        wsTraceHandler.sendTrace('[TEXT-MODIFY]', `Applied ${deletionStrategy.type} deletion for: "${operation.oldValue}"`);
                    } else {
                        // GADS Phase 3: Failure Handling - Content mismatch detected
                        const errorDetails = `Route [${operation.route.join(',')}]: Expected target element to contain newValue "${operation.newValue}" but found "${element.textContent}". Operation: "${operation.oldValue}" → "${operation.newValue}". Parent: ${deletionStrategy.parentTag || 'unknown'}. Element type: ${element.nodeType === Node.TEXT_NODE ? 'TEXT_NODE' : element.nodeType === Node.ELEMENT_NODE ? element.tagName : 'unknown'}`;
                        wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', errorDetails);
                        this.insertProcessingErrorMarker(outputDOM, operation.route, 'Target element content validation failed', operation, errorDetails);
                    }
                }

                // Apply insertion styling to new value
                if (operation.newValue) {
                    const insertionSuccess = this.applyInsertionStyling(element, operation.newValue);
                    if (insertionSuccess) {
                        wsTraceHandler.sendTrace('[TEXT-MODIFY]', `Applied insertion styling to: "${operation.newValue}"`);
                    } else {
                        wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', `Failed to apply insertion styling to: "${operation.newValue}"`);
                        this.insertProcessingErrorMarker(outputDOM, operation.route, 'Insertion styling failed', operation, `Failed to apply insertion styling to element containing "${element.textContent}" for newValue "${operation.newValue}"`);
                    }
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // GADS Phase 3: Context Detection - Determine deletion strategy based on parent element
            determineTextDeletionStrategy(element) {
                let current = element;
                
                // GADS specification: Check for specific parent element types
                const inlineContextTags = new Set(['P', 'TD', 'TH', 'LI', 'DD']);
                
                while (current && current.parentNode) {
                    current = current.parentNode;
                    if (current.tagName && inlineContextTags.has(current.tagName)) {
                        return {
                            type: 'inline',
                            parentTag: current.tagName,
                            parentElement: current
                        };
                    }
                }
                
                return {
                    type: 'block',
                    parentTag: null,
                    parentElement: null
                };
            }

            // GADS Phase 3: Content Validation - Verify element content matches expected value
            validateElementContent(element, expectedContent) {
                if (element.nodeType === Node.TEXT_NODE) {
                    return element.textContent === expectedContent;
                } else if (element.nodeType === Node.ELEMENT_NODE) {
                    return element.textContent === expectedContent;
                } else {
                    return false;
                }
            }

            // GADS Phase 3: Apply deletion element using determined strategy
            applyDeletionElement(element, deletedContent, strategy) {
                if (strategy.type === 'inline') {
                    // Create inline deletion span per GADS specification
                    const deletionSpan = document.createElement('span');
                    deletionSpan.className = 'diff-deletion-inline';
                    deletionSpan.style.backgroundColor = 'rgb(248, 215, 218)';
                    deletionSpan.style.textDecoration = 'line-through';
                    deletionSpan.style.padding = '1px 2px';
                    deletionSpan.style.marginRight = '2px';
                    deletionSpan.textContent = deletedContent;

                    // Insert before the target element to maintain reading order
                    if (element.parentNode) {
                        element.parentNode.insertBefore(deletionSpan, element);
                    }
                } else {
                    // Create block deletion div for non-inline contexts
                    const deletionBlock = document.createElement('div');
                    deletionBlock.className = 'diff-deletion';
                    deletionBlock.style.backgroundColor = 'rgb(248, 215, 218)';
                    deletionBlock.style.borderLeft = '4px solid rgb(220, 53, 69)';
                    deletionBlock.style.padding = '4px';
                    deletionBlock.style.marginBottom = '4px';
                    deletionBlock.innerHTML = `<span style="text-decoration: line-through;">${this.escapeHtml(deletedContent)}</span>`;

                    // Use existing insertion point logic for block deletions
                    const insertionPoint = this.findDeletionInsertionPoint(element.ownerDocument, this.getElementRoute(element));
                    if (insertionPoint && insertionPoint.container) {
                        if (insertionPoint.insertBefore) {
                            insertionPoint.container.insertBefore(deletionBlock, insertionPoint.insertBefore);
                        } else {
                            insertionPoint.container.appendChild(deletionBlock);
                        }
                    }
                }
            }

            // GADS Phase 3: Apply insertion styling to new content
            applyInsertionStyling(element, newContent) {
                try {
                    if (element.nodeType === Node.TEXT_NODE) {
                        // For text nodes, wrap in a span
                        const span = document.createElement('span');
                        span.className = 'diff-insertion';
                        span.style.backgroundColor = 'rgb(212, 237, 218)';
                        span.style.padding = '2px';
                        span.style.borderRadius = '2px';
                        span.textContent = newContent;

                        // Replace the text node with our highlighted span
                        if (element.parentNode) {
                            element.parentNode.replaceChild(span, element);
                            return true;
                        }
                    } else if (element.nodeType === Node.ELEMENT_NODE) {
                        // For element nodes, add insertion class
                        element.classList.add('diff-insertion');
                        element.style.backgroundColor = 'rgb(212, 237, 218)';
                        element.style.padding = '2px';
                        element.style.borderRadius = '2px';
                        return true;
                    }
                    return false;
                } catch (error) {
                    wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', `Exception during insertion styling: ${error.message}`);
                    return false;
                }
            }

            // GADS Phase 3: Failure Handling - Insert error marker for diagnostic purposes
            insertProcessingErrorMarker(outputDOM, route, errorMessage, operation, detailedError) {
                const errorSpan = document.createElement('span');
                errorSpan.className = 'diff-processing-error';
                errorSpan.style.backgroundColor = 'magenta';
                errorSpan.style.color = 'white';
                errorSpan.style.padding = '2px 4px';
                errorSpan.style.fontSize = '0.8em';
                errorSpan.style.fontWeight = 'bold';
                errorSpan.style.borderRadius = '2px';
                errorSpan.style.margin = '0 2px';
                errorSpan.style.cursor = 'help';
                errorSpan.textContent = '⚠️ DIFF-ERROR';
                
                // Create detailed tooltip with all diagnostic information
                const tooltipContent = [
                    `ERROR: ${errorMessage}`,
                    `ROUTE: [${route.join(',')}]`,
                    `OPERATION: "${operation.oldValue || 'N/A'}" → "${operation.newValue || 'N/A'}"`,
                    detailedError ? `DETAILS: ${detailedError}` : '',
                    `TIMESTAMP: ${new Date().toISOString()}`
                ].filter(Boolean).join(' | ');
                
                errorSpan.title = tooltipContent;

                // Try to insert near the problem location
                try {
                    const approximateElement = this.findApproximateElementByRoute(outputDOM, route);
                    if (approximateElement && approximateElement.parentNode) {
                        approximateElement.parentNode.insertBefore(errorSpan, approximateElement);
                        wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', `Inserted error marker near route [${route.join(',')}]`);
                    } else {
                        // Fallback: append to document body or first available container
                        const fallbackContainer = outputDOM.querySelector('body') || outputDOM.querySelector('div') || outputDOM;
                        if (fallbackContainer) {
                            fallbackContainer.appendChild(errorSpan);
                            wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', `Inserted error marker in fallback container (${fallbackContainer.tagName || 'unknown'})`);
                        }
                    }
                } catch (fallbackError) {
                    wsTraceHandler.sendTrace('[TEXT-MODIFY-ERROR]', `Failed to insert error marker: ${fallbackError.message}`);
                }
            }

            // Helper: Find approximate element when exact route fails
            findApproximateElementByRoute(dom, route) {
                let element = dom;
                // Try to traverse as far as possible through the route
                for (let i = 0; i < route.length && element; i++) {
                    if (element.childNodes && element.childNodes[route[i]]) {
                        element = element.childNodes[route[i]];
                    } else {
                        // Return the deepest element we could reach
                        break;
                    }
                }
                return element;
            }

            // Helper: Get route array for an element (reverse of findElementByRoute)
            getElementRoute(element) {
                const route = [];
                let current = element;
                while (current && current.parentNode) {
                    const parent = current.parentNode;
                    for (let i = 0; i < parent.childNodes.length; i++) {
                        if (parent.childNodes[i] === current) {
                            route.unshift(i);
                            break;
                        }
                    }
                    current = parent;
                }
                return route;
            }

            generateDeletionBlock(outputDOM, operation) {
                wsTraceHandler.sendTrace('[DELETION-BLOCK]', `Generating deletion block for ${operation.action} at route [${operation.route.join(',')}]`);

                const deletionBlock = document.createElement('div');
                // Clean CSS classes - only diff-deletion, no mixing
                deletionBlock.className = 'diff-deletion';
                deletionBlock.style.backgroundColor = '#f8d7da';
                deletionBlock.style.borderLeft = '4px solid #dc3545';
                deletionBlock.style.padding = '8px';
                deletionBlock.style.margin = '4px 0';

                // Use pre-captured content with enhanced formatting
                if (operation.capturedContent) {
                    wsTraceHandler.sendTrace('[DELETION-BLOCK]', `Using pre-captured content (${operation.capturedType}): ${operation.capturedContent.substring(0, 50)}...`);

                    if (operation.capturedType === 'text' || operation.capturedType === 'fallback-text') {
                        deletionBlock.innerHTML = `<strong>Deleted text:</strong> <span style="font-style: italic; color: #721c24;">"${this.escapeHtml(operation.capturedContent)}"</span>`;
                    } else if (operation.capturedType === 'element') {
                        const textContent = this.extractTextFromHtml(operation.capturedContent);
                        if (textContent && textContent !== operation.capturedContent) {
                            deletionBlock.innerHTML = `<strong>Deleted element:</strong> <span style="font-style: italic; color: #721c24;">${this.escapeHtml(textContent)}</span><br><details style="margin-top: 4px;"><summary style="cursor: pointer; color: #6f42c1;">Show HTML</summary><code style="display: block; background: rgba(0,0,0,0.05); padding: 4px; margin-top: 4px; font-size: 12px;">${this.escapeHtml(operation.capturedContent)}</code></details>`;
                        } else {
                            deletionBlock.innerHTML = `<strong>Deleted element:</strong><br><code style="display: block; background: rgba(0,0,0,0.05); padding: 4px; font-size: 12px;">${this.escapeHtml(operation.capturedContent)}</code>`;
                        }
                    } else {
                        deletionBlock.innerHTML = `<strong>Deleted content:</strong> <span style="font-style: italic; color: #721c24;">"${this.escapeHtml(operation.capturedContent)}"</span>`;
                    }
                } else {
                    // Fallback when no captured content available
                    deletionBlock.innerHTML = `<strong>Deleted content</strong> <span style="color: #6a737d;">(content not captured)</span><br><em style="font-size: 12px; color: #6a737d;">Action: ${operation.action}, Route: [${operation.route.join(',')}]</em>`;
                    wsTraceHandler.sendTrace('[DELETION-BLOCK]', `No captured content available for deletion`);
                }

                // Insert deletion block in output DOM at block-level location
                const insertPoint = this.findDeletionInsertionPoint(outputDOM, operation.route);
                if (insertPoint && insertPoint.container) {
                    if (insertPoint.insertBefore) {
                        insertPoint.container.insertBefore(deletionBlock, insertPoint.insertBefore);
                        wsTraceHandler.sendTrace('[DELETION-BLOCK]', `Inserted deletion block before sibling in ${insertPoint.container.tagName || 'container'}`);
                    } else {
                        insertPoint.container.appendChild(deletionBlock);
                        wsTraceHandler.sendTrace('[DELETION-BLOCK]', `Appended deletion block to ${insertPoint.container.tagName || 'container'}`);
                    }
                } else {
                    // Fallback: append to output DOM root
                    outputDOM.appendChild(deletionBlock);
                    wsTraceHandler.sendTrace('[DELETION-BLOCK]', `Fallback: appended deletion block to output DOM root`);
                }
            }

            findDeletionInsertionPoint(outputDOM, route) {
                wsTraceHandler.sendTrace('[DELETION-INSERT]', `Finding block-level insertion point for route [${route.join(',')}]`);

                if (route.length === 0) {
                    wsTraceHandler.sendTrace('[DELETION-INSERT]', 'Empty route, using output DOM start');
                    return { container: outputDOM, insertBefore: outputDOM.firstChild };
                }

                // Traverse route to find the element that would be deleted
                let element = outputDOM;
                for (let i = 0; i < route.length; i++) {
                    if (element.childNodes && element.childNodes[route[i]]) {
                        element = element.childNodes[route[i]];
                    } else {
                        wsTraceHandler.sendTrace('[DELETION-INSERT]', `Route traversal failed at position ${i}, using parent container`);
                        return this.findBlockLevelContainer(element);
                    }
                }

                // Found the target element - now find appropriate block-level insertion point
                return this.findBlockLevelContainer(element);
            }

            findBlockLevelContainer(element) {
                if (!element) {
                    wsTraceHandler.sendTrace('[DELETION-INSERT]', 'No element provided, defaulting to document level');
                    return { container: document.body || document.documentElement, insertBefore: null };
                }

                // Walk up the DOM tree to find a suitable block-level container
                let current = element;
                let blockLevelTags = new Set(['DIV', 'P', 'SECTION', 'ARTICLE', 'HEADER', 'FOOTER', 'NAV', 'ASIDE', 'MAIN', 'BLOCKQUOTE', 'DL', 'DD', 'LI', 'TD', 'TH']);

                while (current && current.parentNode) {
                    const parent = current.parentNode;

                    // If parent is a block-level element, we can insert after current as a sibling
                    if (parent.tagName && blockLevelTags.has(parent.tagName)) {
                        wsTraceHandler.sendTrace('[DELETION-INSERT]', `Found block container: ${parent.tagName}, inserting after ${current.tagName || 'node'}`);
                        return { container: parent, insertBefore: current.nextSibling };
                    }

                    current = parent;
                }

                // Fallback: insert at document level
                wsTraceHandler.sendTrace('[DELETION-INSERT]', 'No suitable block container found, using document level');
                const documentRoot = current.ownerDocument ? current.ownerDocument.body || current.ownerDocument.documentElement : document.body;
                return { container: documentRoot, insertBefore: null };
            }

            createRouteElementMap(dom) {
                wsTraceHandler.sendTrace('[ROUTE-MAP]', 'Building route-to-element mapping for deletion capture');
                const routeMap = {};

                const mapElement = (element, route) => {
                    if (!element) return;

                    const routeKey = route.join(',');
                    routeMap[routeKey] = {
                        element: element,
                        nodeType: element.nodeType,
                        outerHTML: element.nodeType === Node.ELEMENT_NODE ? element.outerHTML : null,
                        textContent: element.textContent || '',
                        nodeName: element.nodeName || ''
                    };

                    // Recursively map child nodes
                    if (element.childNodes) {
                        for (let i = 0; i < element.childNodes.length; i++) {
                            const childRoute = [...route, i];
                            mapElement(element.childNodes[i], childRoute);
                        }
                    }
                };

                // Start mapping from root with empty route
                mapElement(dom, []);

                wsTraceHandler.sendTrace('[ROUTE-MAP]', `Created mapping for ${Object.keys(routeMap).length} DOM nodes`);
                return routeMap;
            }

            enhanceOperationsWithCapturedContent(diffOperations, routeElementMap) {
                wsTraceHandler.sendTrace('[ENHANCE]', `Enhancing ${diffOperations.length} operations with pre-captured content`);

                let deletionsFound = 0;
                let deletionsEnhanced = 0;

                for (const op of diffOperations) {
                    if (op.action === 'removeElement' || op.action === 'removeTextElement') {
                        deletionsFound++;
                        const routeKey = op.route.join(',');
                        wsTraceHandler.sendTrace('[ENHANCE]', `Enhancing deletion ${deletionsFound}: ${op.action} at route [${routeKey}]`);

                        const mappedElement = routeElementMap[routeKey];
                        if (mappedElement) {
                            if (mappedElement.nodeType === Node.TEXT_NODE) {
                                op.capturedContent = mappedElement.textContent;
                                op.capturedType = 'text';
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with captured text: "${mappedElement.textContent}"`);
                            } else if (mappedElement.nodeType === Node.ELEMENT_NODE) {
                                op.capturedContent = mappedElement.outerHTML;
                                op.capturedType = 'element';
                                const preview = mappedElement.outerHTML.substring(0, 100);
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with captured element: ${preview}${mappedElement.outerHTML.length > 100 ? '...' : ''}`);
                            } else {
                                op.capturedContent = mappedElement.textContent || `Unknown node: ${mappedElement.nodeName}`;
                                op.capturedType = 'unknown';
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with captured unknown node: ${op.capturedContent}`);
                            }
                            deletionsEnhanced++;
                        } else {
                            wsTraceHandler.sendTrace('[ENHANCE]', `No mapping found for deletion route [${routeKey}]`);
                            // Fallback to operation text if available
                            if (op.text) {
                                op.capturedContent = op.text;
                                op.capturedType = 'fallback-text';
                                deletionsEnhanced++;
                                wsTraceHandler.sendTrace('[ENHANCE]', `Enhanced with fallback text: "${op.text}"`);
                            }
                        }
                    }
                }

                wsTraceHandler.sendTrace('[ENHANCE]', `Operation enhancement complete: ${deletionsEnhanced}/${deletionsFound} deletions enhanced`);
            }




            showStatusMessage(message) {
                this.elements.statusSection.textContent = message;
                this.elements.statusSection.style.display = 'block';
            }

            hideStatusMessage() {
                this.elements.statusSection.style.display = 'none';
            }

            showCommitPopover(event, railRow) {
                const value = railRow.dataset.value;
                const commit = this.resolveCommit(value);
                if (!commit) return;

                // Position popover in upper-left of render pane (GADS compliant)
                this.positionPopoverInRenderPane();

                // Update popover content
                this.updateCommitPopoverContent(value, commit);

                // Show the popover
                this.elements.commitPopover.style.display = 'block';
            }

            updateCommitPopoverContent(value, commit) {
                // Determine status for GADMRC memo compliance
                const isHead = value === 'H';
                const isUnchanged = commit && this.manifest.commits.length > 1 &&
                    this.manifest.commits.some((c, i) => 
                        i > 0 && c.hash === commit.hash && 
                        c.html_sha256 === this.manifest.commits[i-1].html_sha256
                    );
                
                const status = isHead ? "HEAD" : (isUnchanged ? "No substantive change" : "Changed");

                this.elements.commitPopoverContent.innerHTML = `
                    <div class="popover-field">
                        <div class="popover-label">Position:</div>
                        <div class="popover-value">${value}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Hash:</div>
                        <div class="popover-value">${commit.hash}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Date:</div>
                        <div class="popover-value">${new Date(commit.timestamp ? 
                            commit.timestamp.replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, '$1-$2-$3T$4:$5:$6Z')
                            : commit.date || 'Unknown').toLocaleString()}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Message:</div>
                        <div class="popover-value">${commit.message}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">html_sha256:</div>
                        <div class="popover-value">${commit.html_sha256}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Status:</div>
                        <div class="popover-value">${status}</div>
                    </div>
                `;
            }

            hideCommitPopover() {
                this.elements.commitPopover.style.display = 'none';
            }

            positionPopoverInRenderPane() {
                // Position in upper-left of render pane as per GADS specification
                const renderPaneRect = this.elements.renderedPane.getBoundingClientRect();
                const popover = this.elements.commitPopover;

                popover.style.left = (renderPaneRect.left + 20) + 'px';
                popover.style.top = (renderPaneRect.top + 20) + 'px';
            }


        }

        // Initialize inspector when DOM and diff-dom are ready (GADS compliant initialization)
        let domReady = false;
        let diffDomReady = false;

        function checkInitialization() {
            if (domReady && diffDomReady) {
                console.log('[DEBUG] DOM and diff-dom ready, initializing inspector');
                console.log('[DEBUG]', `diff-dom available: ${typeof window.diffDom !== 'undefined'}`);
                if (typeof window.diffDom !== 'undefined') {
                    console.log('[DEBUG] diff-dom ESM loaded successfully');
                }
                window.gadInspector = new GadInspector();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log('[DEBUG] DOM loaded, waiting for diff-dom ESM');
            domReady = true;
            checkInitialization();
        });

        window.addEventListener('diff-dom-ready', () => {
            console.log('[DEBUG] diff-dom ESM ready');
            diffDomReady = true;
            checkInitialization();
        });
    </script>
</body>
</html>
