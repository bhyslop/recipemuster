<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GAD Inspector</title>
    <link rel="stylesheet" href="gadc.css">
</head>
<body>
    <div class="status-section" id="statusSection"></div>

    <div class="workspace">
        <div class="rail-header">
            F <button class="swap-button" id="swapButton" title="Transpose rail positions">⇄</button> T
        </div>

        <div class="render-header" id="comparisonHeader">
            <!-- Commit comparison will be displayed here -->
        </div>

        <div class="rail from" id="fromRail">
            <div id="fromRailContent">
                <div class="loading">Loading...</div>
            </div>
        </div>

        <div class="rail to" id="toRail">
            <div id="toRailContent">
                <div class="loading">Loading...</div>
            </div>
        </div>

        <div class="rendered-pane" id="renderedPane">
            <div class="loading">Loading manifest...</div>
        </div>
    </div>

    <div class="popover" id="commitPopover">
        <div class="popover-header">Commit Details</div>
        <div id="commitPopoverContent">
        </div>
    </div>

    <script type="module">
        // Use ESM import for modern diff-dom
        import { DiffDOM } from 'https://cdn.skypack.dev/diff-dom@5.2.0';
        window.diffDom = { DiffDOM };
        console.log('[DEBUG] diff-dom loaded via ESM:', typeof DiffDOM);
        // Trigger initialization if DOM is already ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => window.dispatchEvent(new Event('diff-dom-ready')));
        } else {
            window.dispatchEvent(new Event('diff-dom-ready'));
        }
    </script>
    <script>

        // Compact logger for token cost reduction
        const logger = {
            d(msg) { wsTraceHandler.sendTrace('D', msg); },
            e(msg) { wsTraceHandler.sendTrace('E', msg); },
            p(n, msg) { wsTraceHandler.sendTrace(`P${n}`, msg); }
        };

        // WebSocket trace handler for GADS compliance
        class WebSocketTraceHandler {
            constructor() {
                this.ws = null;
                // Don't connect immediately - wait for successful manifest fetch
            }

            connectAfterManifest() {
                // Only attempt connection after successful manifest fetch (GADS compliant)
                try {
                    const wsPort = window.location.port || 8080; // Use same port as HTTP
                    const wsUrl = `ws://${window.location.hostname}:${wsPort}/ws`;
                    console.log(`[DEBUG] Factory available, attempting WebSocket connection to: ${wsUrl}`);
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('[DEBUG] WebSocket connected after manifest success');
                    };

                    this.ws.onerror = (error) => {
                        console.log('[DEBUG] WebSocket error (non-fatal):', error);
                    };

                    this.ws.onclose = () => {
                        console.log('[DEBUG] WebSocket disconnected');
                    };
                } catch (error) {
                    console.log('[DEBUG] WebSocket connection failed (non-fatal):', error);
                }
            }


            sendTrace(prefix, message) {
                // Always log to console, send to WebSocket if available
                console.log(`${prefix} ${message}`);

                // Send to WebSocket if connected
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    try {
                        this.ws.send(JSON.stringify({
                            type: 'trace',
                            message: `${prefix} ${message}`
                        }));
                    } catch (error) {
                        // WebSocket error is not critical
                        console.log(`[WS-ERROR] Failed to send trace: ${error}`);
                    }
                }
            }

            sendDebugOutput(debugType, content, fromCommit, toCommit, sourceFiles) {
                // Consolidated debug output sender for all 8-phase debug artifacts
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    try {
                        const timestamp = new Date().toISOString().replace(/[-:]/g, '').replace(/\..+/, '');
                        const fromHash = fromCommit ? fromCommit.hash.substring(0, 12) : 'unknown';
                        const toHash = toCommit ? toCommit.hash.substring(0, 12) : 'unknown';
                        
                        // Determine file extension based on debug type
                        const fileExtension = debugType.includes('dft') ? 'json' : 'html';
                        const filename = `debug-${debugType}-${fromHash}-${toHash}-${timestamp}.${fileExtension}`;
                        
                        this.ws.send(JSON.stringify({
                            type: 'debug_output',
                            debug_type: debugType,
                            content: content,
                            filename_pattern: filename,
                            source_files: sourceFiles || []
                        }));
                        console.log(`[DEBUG-OUTPUT] Sent ${debugType} debug data to Factory for ${filename} creation`);
                    } catch (error) {
                        console.log(`[WS-ERROR] Failed to send ${debugType} debug output: ${error}`);
                    }
                }
                // Silent if WebSocket not available - this is optional functionality
            }

        }

        const wsTraceHandler = new WebSocketTraceHandler();

        // GAD Inspector implementation
        class GadInspector {
            constructor() {
                this.manifest = null;
                this.currentChanges = [];
                this.currentChangeIndex = 0;

                console.log('[DEBUG] GadInspector constructor called');
                this.initializeElements();
                this.setupEventListeners();
                this.loadManifest();
            }

            initializeElements() {
                console.log('[DEBUG] Initializing DOM elements');
                this.elements = {
                    comparisonHeader: document.getElementById('comparisonHeader'),
                    statusSection: document.getElementById('statusSection'),
                    fromRail: document.getElementById('fromRail'),
                    fromRailContent: document.getElementById('fromRailContent'),
                    toRail: document.getElementById('toRail'),
                    toRailContent: document.getElementById('toRailContent'),
                    swapButton: document.getElementById('swapButton'),
                    renderedPane: document.getElementById('renderedPane'),
                    commitPopover: document.getElementById('commitPopover'),
                    commitPopoverContent: document.getElementById('commitPopoverContent'),
                };

                // Initialize selections
                this.selectedFrom = null;
                this.selectedTo = null;

                // Check if all elements were found
                Object.entries(this.elements).forEach(([key, element]) => {
                    if (!element) {
                        console.log(`[ERROR] Failed to find DOM element: ${key}`);
                    }
                });
                console.log('[DEBUG] DOM elements initialized');
            }

            setupEventListeners() {
                this.elements.swapButton.addEventListener('click', () => this.onSwapClick());

                // Rail hover for popover display
                let hoverTimeout;
                let currentHoveredRow = null;

                [this.elements.fromRail, this.elements.toRail].forEach(rail => {
                    rail.addEventListener('mouseover', (e) => {
                        const railRow = e.target.closest('.rail-row');
                        if (!railRow) return;

                        // Clear any existing timeout
                        if (hoverTimeout) {
                            clearTimeout(hoverTimeout);
                        }

                        currentHoveredRow = railRow;

                        // Show popover after 200ms delay (GADS compliant)
                        hoverTimeout = setTimeout(() => {
                            this.showCommitPopover(e, railRow);
                        }, 200);
                    });

                    rail.addEventListener('mouseout', (e) => {
                        const railRow = e.target.closest('.rail-row');
                        if (!railRow) return;

                        // Clear timeout if mouse leaves before delay
                        if (hoverTimeout) {
                            clearTimeout(hoverTimeout);
                            hoverTimeout = null;
                        }

                        currentHoveredRow = null;

                        // Hide popover immediately (GADS compliant)
                        this.hideCommitPopover();
                    });
                });

                // Initialize URL state tracking
                this.suppressUrlUpdate = false;

                // Parse URL state on browser navigation (back/forward)
                window.addEventListener('popstate', () => this.parseUrlState());
            }

            async loadManifest() {
                logger.d( 'Starting manifest load');
                logger.d( 'Loading start');

                try {
                    logger.d( 'Fetching manifest.json');
                    logger.d( `Fetch URL: ${window.location.origin}/manifest.json`);
                    const response = await fetch('manifest.json');
                    logger.d( `Fetch response status: ${response.status}`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    logger.d( 'Parsing manifest JSON');
                    this.manifest = await response.json();
                    logger.d( `Manifest loaded successfully with ${this.manifest.commits.length} commits`);
                    logger.d( `Successful load with ${this.manifest.commits.length} commits`);

                    // Now that Factory is confirmed available, attempt WebSocket connection
                    wsTraceHandler.connectAfterManifest();

                    logger.d( 'Starting populateRails');
                    this.populateRails();
                    logger.d( 'populateRails completed');

                    logger.d( 'Starting parseUrlState');
                    this.parseUrlState();
                    logger.d( 'parseUrlState completed');

                } catch (error) {
                    logger.d( `Manifest load failed: ${error.message}`);
                    logger.d( `Load failure: ${error.message}`);
                    this.elements.renderedPane.innerHTML = `
                        <div class="error">
                            <h3>Failed to load manifest.json</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            }

            populateRails() {
                logger.d( 'Clearing rail content');
                // Clear existing content
                this.elements.fromRailContent.innerHTML = '';
                this.elements.toRailContent.innerHTML = '';

                logger.d( 'Rails will be populated with commits only (no magic values)');

                logger.d( `Processing ${this.manifest.commits.length} commits for rails`);
                // Reverse commits first, then apply simple labeling like GADMRC
                const reversedCommits = [...this.manifest.commits].reverse();
                reversedCommits.forEach((commit, index) => {
                    logger.d( `Processing commit ${index + 1}: ${commit.hash.substring(0, 8)}`);
                    const isUnchanged = index > 0 &&
                        commit.html_sha256 === reversedCommits[index - 1].html_sha256;

                    // GADMRC-compliant labeling: H for index 0, -1, -2, etc. for rest
                    const position = index === 0 ? 'H' : `-${index}`;

                    // Use position as the value, store commit data in dataset (no hash display)
                    this.addRailRow(this.elements.fromRailContent, position, position, 'from', null, isUnchanged, commit);
                    this.addRailRow(this.elements.toRailContent, position, position, 'to', null, isUnchanged, commit);
                });
                logger.d( 'Rail population completed');
                
                // Set default selections per GADS spec: From = -1, To = H
                this.setDefaultSelections();
            }
            
            setDefaultSelections() {
                // Only set defaults if no current selections AND no URL params present
                // Fix: Use only hash fragment, no search params
                const hashParams = this.parseHashParams();
                const hasHashParams = hashParams.get('from') || hashParams.get('to');
                
                if (!this.selectedFrom && !this.selectedTo && !hasHashParams) {
                    logger.d( 'No selections and no hash params - setting default selections: From = -1, To = H');
                    this.setRailSelection('from', '-1', true);  // Skip diff on first
                    this.setRailSelection('to', 'H', false);    // Perform diff on second
                } else {
                    logger.d( `Skipping defaults - selections: from=${this.selectedFrom}, to=${this.selectedTo}, hashParams=${hasHashParams}`);
                }
            }

            addRailRow(railContent, value, label, railType, hashText = null, isUnchanged = false, commit = null) {
                const row = document.createElement('div');
                row.className = 'rail-row' + (isUnchanged ? ' unchanged-rail-row' : '');
                row.dataset.value = value;
                row.dataset.railType = railType;
                
                // Store commit data for position resolution
                if (commit) {
                    row.dataset.commitHash = commit.hash;
                    row.dataset.commitData = JSON.stringify(commit);
                }

                const labelElement = document.createElement('div');
                labelElement.className = 'rail-label';
                labelElement.textContent = label;

                const commitInfo = document.createElement('div');
                commitInfo.className = 'rail-commit-info';
                
                // GADMRC-compliant: show only position labels, no hash text in rails
                if (hashText) {
                    const hashElement = document.createElement('div');
                    hashElement.className = 'rail-hash';
                    hashElement.textContent = hashText;
                    commitInfo.appendChild(hashElement);
                } else {
                    // Empty info div - position label is sufficient
                    commitInfo.style.display = 'none';
                }

                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = railType + 'Selection';
                radio.className = 'rail-radio';
                radio.value = value;

                // Add click handler for selection
                row.addEventListener('click', () => {
                    this.selectRailRow(row, railType);
                });

                radio.addEventListener('change', () => {
                    if (radio.checked) {
                        this.selectRailRow(row, railType);
                    }
                });

                row.appendChild(labelElement);
                row.appendChild(commitInfo);
                row.appendChild(radio);

                railContent.appendChild(row);
            }

            selectRailRow(row, railType, skipDiff = false) {
                const value = row.dataset.value;
                
                // Clear previous selection in this rail
                const railContent = railType === 'from' ? this.elements.fromRailContent : this.elements.toRailContent;
                railContent.querySelectorAll('.rail-row').forEach(r => r.classList.remove('selected'));
                
                // Set new selection
                row.classList.add('selected');
                const radio = row.querySelector('.rail-radio');
                if (radio) radio.checked = true;

                // Store selection
                const previousValue = railType === 'from' ? this.selectedFrom : this.selectedTo;
                if (railType === 'from') {
                    this.selectedFrom = value;
                } else {
                    this.selectedTo = value;
                }

                logger.d( `${railType} rail selected: ${value}`);
                
                // Only update URL and perform diff if selection changed, not skipped, and not suppressed
                if (previousValue !== value && !skipDiff && !this.suppressUrlUpdate) {
                    this.writeUrlState();
                    this.performDiff();
                }
            }

            setRailSelection(railType, value, skipDiff = false) {
                const railContent = railType === 'from' ? this.elements.fromRailContent : this.elements.toRailContent;
                const targetRow = railContent.querySelector(`[data-value="${value}"]`);
                
                if (targetRow) {
                    this.selectRailRow(targetRow, railType, skipDiff);
                } else {
                    logger.d( `Rail row not found for value: ${value} in ${railType} rail`);
                }
            }

            parseHashParams() {
                // Fix: Parse hash fragment as URL parameters per GADS spec
                const hash = window.location.hash;
                if (!hash || hash === '#') {
                    return new Map();
                }
                
                const paramString = hash.substring(1); // Remove leading #
                const params = new Map();
                
                if (paramString) {
                    const pairs = paramString.split('&');
                    for (const pair of pairs) {
                        const [key, value] = pair.split('=');
                        if (key && value) {
                            params.set(decodeURIComponent(key), decodeURIComponent(value));
                        }
                    }
                }
                
                return params;
            }
            
            parseUrlState() {
                logger.d( `parseUrlState called with hash: "${window.location.hash}"`);
                
                // Fix: Parse only from hash fragment, ignore search params completely
                const hashParams = this.parseHashParams();
                const fromHash = hashParams.get('from');
                const toHash = hashParams.get('to');

                logger.d( `Parsed hash params - from: "${fromHash}", to: "${toHash}"`);

                // Only proceed if we have hash parameters to process
                if (!fromHash && !toHash) {
                    logger.d( 'No hash params present, not overriding current selections');
                    return;
                }

                // Convert commit hashes to position values for rail selection
                let fromSet = false;
                let toSet = false;

                if (fromHash) {
                    const fromPosition = this.hashToPosition(fromHash);
                    if (fromPosition) {
                        logger.d( `Setting from rail to position: ${fromPosition} (from hash: ${fromHash})`);
                        this.setRailSelection('from', fromPosition, true); // Skip diff on first selection
                        fromSet = true;
                    } else {
                        logger.d( `Failed to resolve from hash: ${fromHash} - ignoring`);
                    }
                }

                if (toHash) {
                    const toPosition = this.hashToPosition(toHash);
                    if (toPosition) {
                        logger.d( `Setting to rail to position: ${toPosition} (from hash: ${toHash})`);
                        this.setRailSelection('to', toPosition, false); // Perform diff on second selection
                        toSet = true;
                    } else {
                        logger.d( `Failed to resolve to hash: ${toHash} - ignoring`);
                    }
                }

                // If only from was set and resolved, trigger diff
                if (fromSet && !toSet) {
                    logger.d( 'Only from position set from URL, calling performDiff');
                    this.performDiff();
                }
            }

            hashToPosition(commitHash) {
                if (!commitHash || !this.manifest || !this.manifest.commits) {
                    return null;
                }

                // Find the commit by hash
                const commitIndex = this.manifest.commits.findIndex(c => c.hash === commitHash);
                if (commitIndex === -1) {
                    return null;
                }

                // Convert index to position value (H for head, -1, -2, etc.)
                if (commitIndex === this.manifest.commits.length - 1) {
                    return 'H';
                } else {
                    const offset = this.manifest.commits.length - 1 - commitIndex;
                    return `-${offset}`;
                }
            }

            onSwapClick() {
                const fromValue = this.selectedFrom;
                const toValue = this.selectedTo;

                logger.d( `Transposing rail positions: ${fromValue} <-> ${toValue}`);

                // Guard against URL updates during transpose
                this.suppressUrlUpdate = true;

                // Transpose the column positions by exchanging selections
                // Skip diff on both selections during transpose
                this.setRailSelection('from', toValue, true);  // Skip diff
                this.setRailSelection('to', fromValue, true);  // Skip diff - we'll do single diff at end

                // Clear the guard flag
                this.suppressUrlUpdate = false;

                // Update URL with resolved commit hashes and perform single diff
                this.writeUrlState();
                this.performDiff();
            }

            writeUrlState() {
                // Fix: Use hash fragment instead of query params per GADS spec
                const fromCommit = this.resolveCommit(this.selectedFrom);
                const toCommit = this.resolveCommit(this.selectedTo);

                if (fromCommit && toCommit) {
                    const newHash = `#from=${encodeURIComponent(fromCommit.hash)}&to=${encodeURIComponent(toCommit.hash)}`;
                    const newUrl = window.location.protocol + '//' + window.location.host + window.location.pathname + newHash;
                    window.history.replaceState(null, '', newUrl);
                    logger.d( `Updated hash state: from=${fromCommit.hash.substring(0,8)} to=${toCommit.hash.substring(0,8)}`);
                }
            }

            async performDiff() {
                const fromValue = this.selectedFrom;
                const toValue = this.selectedTo;

                if (!fromValue || !toValue) return;

                try {
                    logger.d( 'Magic value resolution start');

                    const fromCommit = this.resolveCommit(fromValue);
                    const toCommit = this.resolveCommit(toValue);

                    if (!fromCommit || !toCommit) {
                        logger.e( 'Invalid magic values or missing commits in manifest');
                        throw new Error('Failed to resolve commits');
                    }

                    logger.d( `Resolved from: ${fromCommit.hash.substring(0, 8)}, to: ${toCommit.hash.substring(0, 8)}`);

                    // Update comparison header
                    this.elements.comparisonHeader.textContent =
                        `${fromCommit.hash.substring(0, 8)} → ${toCommit.hash.substring(0, 8)}`;

                    // Check for identical SHA256
                    if (fromCommit.html_sha256 === toCommit.html_sha256) {
                        logger.d( 'Detection of identical html_sha256 values between selected commits');
                        this.showStatusMessage('These commits have identical rendered content');
                    } else {
                        logger.d( 'Detection of different html_sha256 values between selected commits');
                        this.hideStatusMessage();
                    }

                    await this.fetchAndDiff(fromCommit, toCommit);

                } catch (error) {
                    logger.e( `Diff error: ${error.message}`);
                    this.elements.renderedPane.innerHTML = `
                        <div class="error">
                            <h3>Diff Error</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            }

            resolveCommit(positionValue) {
                // First check: direct hash lookup
                const commitByHash = this.manifest.commits.find(c => c.hash === positionValue);
                if (commitByHash) {
                    return commitByHash;
                }

                // Second check: position value handling
                if (positionValue === 'H') {
                    return this.manifest.commits[this.manifest.commits.length - 1];
                } else if (positionValue.startsWith('-')) {
                    const offset = parseInt(positionValue.substring(1));
                    const index = this.manifest.commits.length - 1 - offset;
                    return index >= 0 ? this.manifest.commits[index] : null;
                }

                return null;
            }

            async fetchAndDiff(fromCommit, toCommit) {
                logger.d( `HTML fetch start for ${fromCommit.html_file} and ${toCommit.html_file}`);

                try {
                    const [fromResponse, toResponse] = await Promise.all([
                        fetch(`/output/${fromCommit.html_file}`),
                        fetch(`/output/${toCommit.html_file}`)
                    ]);

                    if (!fromResponse.ok || !toResponse.ok) {
                        throw new Error('Failed to fetch HTML files');
                    }

                    const [fromHtml, toHtml] = await Promise.all([
                        fromResponse.text(),
                        toResponse.text()
                    ]);

                    logger.d( 'Successful fetch completion');
                    logger.d( 'Diff computation start');

                    // Prepare source file information for gadfd_rendered_capture
                    const sourceFiles = [
                        `From: /output/${fromCommit.html_file}`,
                        `To: /output/${toCommit.html_file}`
                    ];

                    // Use diff-dom library
                    const styledDiff = await this.styleDiff(fromHtml, toHtml, fromCommit, toCommit, sourceFiles);

                    this.elements.renderedPane.innerHTML = styledDiff;

                    // Send rendered content to Factory via WebSocket for raw diff file creation
                    logger.d( `Creating raw diff file for ${fromCommit.hash.substring(0, 8)} → ${toCommit.hash.substring(0, 8)}`);
                    wsTraceHandler.sendDebugOutput('rendered', styledDiff, fromCommit, toCommit, sourceFiles);

                    // Enhanced logging for Factory debugging
                    const changeTypeBreakdown = {
                        insertions: this.elements.renderedPane.querySelectorAll('.gad-inline-addition, .gad-block-addition').length,
                        moves: this.elements.renderedPane.querySelectorAll('.gad-structural-change').length,
                        deletions: this.elements.renderedPane.querySelectorAll('.gad-inline-removal, .gad-block-removal').length,
                        modifications: this.elements.renderedPane.querySelectorAll('.gad-inline-modification').length
                    };

                    const totalChanges = changeTypeBreakdown.insertions + changeTypeBreakdown.moves + 
                                       changeTypeBreakdown.deletions + changeTypeBreakdown.modifications;

                    // Debug trace for change counting
                    logger.d( `Found ${totalChanges} total changes in rendered output`);
                    logger.d( `Breakdown: ${changeTypeBreakdown.insertions} insertions, ${changeTypeBreakdown.moves} moves, ${changeTypeBreakdown.deletions} deletions, ${changeTypeBreakdown.modifications} modifications`);

                    logger.d( `Completion with ${totalChanges} total changes`);
                    logger.d( `Change breakdown: ${JSON.stringify(changeTypeBreakdown)}`);

                } catch (error) {
                    // Enhanced error reporting for Factory debugging
                    if (error.message.includes('diff-dom')) {
                        logger.e( `diff-dom library failure: ${error.message}`);
                    } else if (error.message.includes('fetch') || error.message.includes('HTTP')) {
                        logger.d( `Fetch failure: ${error.message}`);
                    } else {
                        logger.e( `GADS processing failure: ${error.message}`);
                    }

                    // Additional debugging context
                    logger.d( `Error occurred during diff processing for commits: ${fromCommit?.hash?.substring(0,8)} → ${toCommit?.hash?.substring(0,8)}`);
                    throw error;
                }
            }

            async styleDiff(fromHtml, toHtml, fromCommit, toCommit, sourceFiles) {
                const startTime = performance.now();
                logger.d( 'Starting GADS-compliant 8-phase diff processing');
                logger.d( `Input sizes: fromHtml=${fromHtml.length} chars, toHtml=${toHtml.length} chars`);
                logger.d( `diff-dom type at diff time: ${typeof window.diffDom}`);

                if (typeof window.diffDom === 'undefined' || typeof window.diffDom.DiffDOM === 'undefined') {
                    throw new Error('diff-dom library not available - required for diff processing');
                }

                try {
                    // Phase 1: Immutable Input - Establish immutable source DOM trees
                    logger.p(1, 'Immutable Input: Creating immutable source DOM trees');
                    const immutableFromDOM = this.createDOMFromHTML(fromHtml);
                    const immutableToDOM = this.createDOMFromHTML(toHtml);
                    logger.p(1, 'Immutable Input: Immutable DOM trees established and preserved throughout processing');

                    // Phase 2: Detached Working - Create Detached Working DOM with Semantic Anchors
                    logger.p(2, 'Detached Working: Creating Detached Working DOM with Semantic Anchors');
                    const detachedWorkingDOM = this.createDetachedWorkingDOM(immutableToDOM);
                    const semanticAnchors = this.establishSemanticAnchors(detachedWorkingDOM);
                    logger.p(2, `Detached Working: Created independent processing environment with ${Object.keys(semanticAnchors).length} semantic anchors`);

                    // Phase 3: Deletion Fact Capture - Generate Deletion Fact Keys (DFK)
                    logger.p(3, 'Deletion Fact Capture: Generating Deletion Fact Keys (DFK)');
                    const deletionFactTable = await this.createDeletionFactTable(immutableFromDOM);
                    const phase3Debug = { deletionFactCount: Object.keys(deletionFactTable).length, sampleKeys: Object.keys(deletionFactTable).slice(0, 5) };
                    wsTraceHandler.sendDebugOutput('phase3_dft', JSON.stringify(phase3Debug, null, 2), fromCommit, toCommit, sourceFiles);
                    logger.p(3, `Deletion Fact Capture: Created DFK mapping for ${Object.keys(deletionFactTable).length} potential deletions`);

                    // Phase 4: Diff Operations - Generate structured diff operations
                    logger.p(4, 'Diff Operations: Initializing diff-dom and generating operations');
                    const diffDOM = new window.diffDom.DiffDOM({
                        debug: true,
                        diffcap: 500  // Allow more granular detection
                    });
                    const diffOperations = diffDOM.diff(immutableFromDOM, immutableToDOM);
                    this.enhanceOperationsWithDFK(diffOperations, deletionFactTable);
                    logger.p(4, `Diff Operations: Generated ${diffOperations.length} enhanced diff operations`);

                    // Phase 4.5: Semantic Classification - Classify operations into semantic change types
                    logger.p('4.5', 'Semantic Classification: Analyzing operations for precise granular styling');
                    const classifiedOperations = this.classifySemanticChanges(diffOperations, immutableFromDOM, immutableToDOM);
                    
                    // Phase 4.5 Debug Output - Show enriched operations with semantic metadata
                    const phase45Debug = {
                        totalOperations: classifiedOperations.length,
                        semanticBreakdown: this.generateSemanticBreakdown(classifiedOperations),
                        sampleOperations: classifiedOperations.slice(0, 5).map(op => ({
                            action: op.action,
                            route: op.route,
                            semanticType: op.semanticType,
                            visualTreatment: op.visualTreatment
                        }))
                    };
                    wsTraceHandler.sendDebugOutput('phase4.5_classified', JSON.stringify(phase45Debug, null, 2), fromCommit, toCommit, sourceFiles);
                    logger.p('4.5', `Semantic Classification: Classified ${classifiedOperations.length} operations with semantic metadata`);

                    // Phase 5: Annotated Assembly - Construct semantically annotated output DOM
                    logger.p(5, 'Annotated Assembly: Processing classified operations in Detached Working environment');
                    const assemblyResult = this.assembleAnnotatedDOM(detachedWorkingDOM, classifiedOperations, semanticAnchors, fromCommit, toCommit);
                    const assembledDOM = assemblyResult.outputDOM;
                    const assembledHTML = assembledDOM.innerHTML;
                    wsTraceHandler.sendDebugOutput('phase5_annotated', assembledHTML, fromCommit, toCommit, sourceFiles);
                    logger.p(5, 'Annotated Assembly: Semantic annotation construction completed');

                    // Phase 6: Deletion Placement - Position deletion blocks using DFK and Semantic Anchors
                    logger.p(6, 'Deletion Placement: Positioning deletion blocks with DFK mappings');
                    const deletionPlacedDOM = this.placeDeletionBlocks(assembledDOM, assemblyResult.appliedOperations, deletionFactTable, semanticAnchors);
                    const deletionPlacedHTML = deletionPlacedDOM.innerHTML;
                    wsTraceHandler.sendDebugOutput('phase6_deletions', deletionPlacedHTML, fromCommit, toCommit, sourceFiles);
                    logger.p(6, 'Deletion Placement: Structured deletion blocks positioned accurately');

                    // Phase 7: Uniform Classing - Merge consecutive same-nature elements
                    logger.p(7, 'Uniform Classing: Merging consecutive same-nature elements into consolidated runs');
                    const coalescedDOM = this.mergeAdjacentSameNature(deletionPlacedDOM);
                    const coalescedHTML = coalescedDOM.innerHTML;
                    wsTraceHandler.sendDebugOutput('phase7_coalesced', coalescedHTML, fromCommit, toCommit, sourceFiles);
                    logger.p(7, 'Uniform Classing: Single-element consolidated runs created');

                    // Phase 8: Serialize - Generate final rendered output
                    logger.p(8, 'Serialize: Generating final styled diff HTML');
                    const finalHTML = this.serializeFinalOutput(coalescedDOM);
                    wsTraceHandler.sendDebugOutput('phase8_final', finalHTML, fromCommit, toCommit, sourceFiles);
                    logger.p(8, 'Serialize: Final rendered HTML ready for display');

                    // Performance logging for Factory debugging
                    const endTime = performance.now();
                    const totalTime = Math.round(endTime - startTime);
                    logger.d( `GADS 8-phase diff processing completed in ${totalTime}ms`);
                    logger.d( 'Complete processing isolation maintained - input DOMs never modified');

                    return finalHTML;

                } catch (error) {
                    logger.e( `GADS 8-phase diff processing failed: ${error.message}`);
                    throw error;
                }
            }


            // Helper method for creating DOM from HTML strings
            createDOMFromHTML(html) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                return doc.body;
            }

            findElementByRoute(dom, route) {
                let element = dom;
                for (let i = 0; i < route.length; i++) {
                    const index = route[i];
                    if (element.childNodes && element.childNodes[index]) {
                        element = element.childNodes[index];
                    } else {
                        const availableCount = element.childNodes ? element.childNodes.length : 0;
                        
                        // Fix: Remove "best-effort" fallback - if route index is OOB, abort operation
                        logger.e( `Route traversal failed at index ${index} for route [${route.join(',')}]`);
                        logger.e( `Parent has ${availableCount} children, requested index ${index}`);
                        logger.e( `Failed at route position ${i}, partial route was [${route.slice(0, i).join(',')}]`);
                        return null; // Fix: Fail fast instead of retargeting
                    }
                }
                return element;
            }

            escapeHtml(unsafe) {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            extractTextFromHtml(htmlString) {
                try {
                    // Create a temporary element to parse HTML and extract text content
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlString;
                    return tempDiv.textContent || tempDiv.innerText || '';
                } catch (e) {
                    // Fallback: basic tag stripping
                    return htmlString.replace(/<[^>]*>/g, '').trim();
                }
            }

            generateOutputDOM(immutableToDOM, diffOperations, routeElementMap) {
                logger.d( `Generating clean output DOM from ${diffOperations.length} operations`);

                // Create completely new output DOM structure - never modify inputs
                const outputDOM = document.createElement('div');

                // Deep clone the immutable "to" DOM structure as foundation
                this.deepCloneElement(immutableToDOM, outputDOM);
                logger.d( 'Created output DOM foundation from immutable toDOM');

                // Apply diff annotations to output DOM with deduplication
                let insertions = 0, deletions = 0, moves = 0, modifications = 0;
                const processedDeletions = new Set(); // Track processed deletion routes to prevent duplicates

                // Process operations in reverse order (GADS Phase 3) to prevent route invalidation
                for (let i = diffOperations.length - 1; i >= 0; i--) {
                    const op = diffOperations[i];
                    logger.d( `Processing operation ${i} (reverse order): ${op.action} at route [${op.route.join(',')}]`);
                    switch (op.action) {
                        case 'addElement':
                        case 'addTextElement':
                            this.applyInsertionAnnotation(outputDOM, op);
                            insertions++;
                            break;
                        case 'removeElement':
                        case 'removeTextElement':
                            const routeKey = op.route.join(',');
                            if (!processedDeletions.has(routeKey)) {
                                // NOTE: Deletion placement now handled in Phase-6 only - legacy path disabled
                                logger.d( `Legacy deletion placement bypassed for ${op.action} at route [${op.route.join(',')}]`);
                                processedDeletions.add(routeKey);
                                deletions++;
                                logger.d( `Processed unique deletion at route [${routeKey}] via semantic anchor`);
                            } else {
                                logger.d( `Skipped duplicate deletion at route [${routeKey}]`);
                            }
                            break;
                        case 'relocateNode':
                            this.applyMoveAnnotation(outputDOM, op);
                            moves++;
                            break;
                        case 'modifyTextElement':
                            // Handle text modifications as deletion + insertion pairs
                            this.handleTextModification(outputDOM, op, routeElementMap);
                            modifications++;
                            break;
                        case 'modifyAttribute':
                            // Only apply modification styling for attributes, don't double-annotate as insertion
                            this.applyModificationAnnotation(outputDOM, op);
                            modifications++;
                            break;
                        default:
                            logger.d( `Unknown operation type: ${op.action}`);
                    }
                }

                logger.d( `Applied annotations: ${insertions} insertions, ${deletions} deletions (${processedDeletions.size} unique), ${moves} moves, ${modifications} modifications`);
                logger.d( 'Output DOM generation completed with all annotations applied');

                return outputDOM;
            }

            mergeAdjacentSameNature(annotatedDOM) {
                // Phase 7: Visual coalescing - preserve semantic structure with presentation wrappers only
                logger.d( 'Starting Phase 7: Visual coalescing with presentation wrappers');
                
                // Create a new DOM to avoid modifying the annotated DOM
                const coalescedDOM = annotatedDOM.cloneNode(true);
                
                // Apply visual coalescing by adding presentation wrappers around adjacent same-nature elements
                this.addVisualRunWrappers(coalescedDOM);
                
                logger.d( 'Phase 5 complete - semantic structure fully preserved');
                return coalescedDOM;
            }

            addVisualRunWrappers(dom) {
                // Find adjacent same-nature elements using GADS semantic classes
                const diffTypes = ['gad-inline-addition', 'gad-structural-change', 'gad-inline-removal', 'gad-inline-modification'];
                let runCounter = 0;
                
                // Initialize coalescing telemetry
                this.initializeCoalescingTelemetry();
                
                for (const diffType of diffTypes) {
                    runCounter += this.wrapAdjacentSameType(dom, diffType, runCounter);
                }
                
                // Report final telemetry
                this.reportCoalescingTelemetry(runCounter);
                logger.d( `Created ${runCounter} consolidated diff elements`);
            }
            
            wrapAdjacentSameType(dom, className, startRunId) {
                const elements = Array.from(dom.querySelectorAll(`.${className}`));
                if (elements.length < 2) return 0;
                
                let runId = startRunId;
                let runsCreated = 0;
                let i = 0;
                
                while (i < elements.length) {
                    const currentElement = elements[i];
                    const adjacentRun = [currentElement];
                    
                    // Collect adjacent siblings of the same type
                    let j = i + 1;
                    while (j < elements.length && this.areConsecutiveSiblings(elements[j-1], elements[j])) {
                        adjacentRun.push(elements[j]);
                        j++;
                    }
                    
                    // Fix: Only coalesce when (tagName, diff-class) match exactly
                    if (adjacentRun.length >= 2 && this.canSafelyCoalesce(adjacentRun, className)) {
                        this.replaceRunWithSingleElement(adjacentRun, className);
                        runsCreated++;
                        this.updateCoalescingTelemetry('elements_merged', adjacentRun.length);
                        logger.d( `COALESCE-SUCCESS: Merged ${adjacentRun.length} adjacent ${className} elements - reason: SAFE_TO_MERGE`);
                    } else if (adjacentRun.length >= 2) {
                        this.updateCoalescingTelemetry('coalescing_skipped', adjacentRun.length);
                        logger.d( `COALESCE-SKIP: ${adjacentRun.length} ${className} elements - reason: MIXED_TYPES_OR_UNSAFE`);
                    }
                    
                    i = j;
                }
                
                return runsCreated;
            }
            
            canSafelyCoalesce(elements, className) {
                // GADS Anchor Coalescing Rules - prevent anchor corruption
                if (elements.length < 2) {
                    logger.d( `COALESCE-BLOCK: Insufficient elements (${elements.length}) - reason: MIN_ELEMENTS`);
                    return false;
                }
                
                // IMMEDIATE ANCHOR BLOCK - Check for ANY anchor elements first
                for (const element of elements) {
                    if (element.tagName === 'A') {
                        logger.d( `COALESCE-BLOCK: Anchor element detected - reason: PRESERVE_LINK_SEMANTICS - elements: ${elements.length}`);
                        this.updateCoalescingTelemetry('anchor_wrapper_needed', elements.length);
                        return false;
                    }
                }
                
                const firstTag = elements[0].tagName;
                const firstDiffClass = this.extractDiffClass(elements[0], className);
                
                // Do-Not-Merge Constraints for Interactive Elements
                for (const element of elements) {
                    // Never merge interactive elements (buttons, inputs, etc.)
                    const interactiveTags = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'];
                    if (interactiveTags.includes(element.tagName)) {
                        logger.d( `COALESCE-BLOCK: Interactive ${element.tagName} element - reason: PRESERVE_INTERACTION_TARGETS`);
                        this.updateCoalescingTelemetry('interactive_wrapper_needed', elements.length);
                        return false;
                    }
                    
                    // Never merge elements containing interactive children
                    if (element.querySelector('a, button, input, select, textarea')) {
                        logger.d( `COALESCE-BLOCK: Contains interactive children - reason: PRESERVE_NESTED_INTERACTIONS`);
                        this.updateCoalescingTelemetry('nested_interactive_wrapper_needed', elements.length);
                        return false;
                    }
                }
                
                // Tag and Attribute Consistency Requirements
                const firstElement = elements[0];
                for (const element of elements) {
                    // Same parent requirement - no intervening non-whitespace nodes
                    if (element.parentElement !== firstElement.parentElement) {
                        logger.d( `Blocked coalescing: elements have different parents`);
                        return false;
                    }
                    
                    // Same diff class AND same HTML tag requirement
                    if (element.tagName !== firstTag) {
                        return false;
                    }
                    if (this.extractDiffClass(element, className) !== firstDiffClass) {
                        return false;
                    }
                    
                    // Attribute reconciliation - must be byte-for-byte identical
                    if (!this.attributesMatch(firstElement, element)) {
                        logger.d( `Blocked coalescing: attributes differ between elements`);
                        return false;
                    }
                }
                
                return true;
            }
            
            attributesMatch(elem1, elem2) {
                // Helper method for byte-for-byte attribute matching
                const attrs1 = Array.from(elem1.attributes || []).sort((a, b) => a.name.localeCompare(b.name));
                const attrs2 = Array.from(elem2.attributes || []).sort((a, b) => a.name.localeCompare(b.name));
                
                if (attrs1.length !== attrs2.length) return false;
                
                for (let i = 0; i < attrs1.length; i++) {
                    if (attrs1[i].name !== attrs2[i].name || attrs1[i].value !== attrs2[i].value) {
                        return false;
                    }
                }
                
                return true;
            }
            
            extractDiffClass(element, expectedClassName) {
                // Extract the specific GADS semantic class from element's classList
                const classList = Array.from(element.classList);
                return classList.find(cls => cls.startsWith('gad-')) || expectedClassName;
            }
            
            areConsecutiveSiblings(elem1, elem2) {
                // Check if elem2 immediately follows elem1 in the DOM
                return elem1.parentElement === elem2.parentElement && 
                       elem1.nextElementSibling === elem2;
            }
            
            replaceRunWithSingleElement(runElements, className) {
                if (runElements.length < 2) return;
                
                // GADS Visual Consolidation Strategy: WRAPPER-ONLY APPROACH
                // NEVER merge element contents - only provide visual container
                // Each child element maintains separate DOM identity and click targets
                
                const runContainer = document.createElement('span');
                runContainer.className = `${className}-coalesced-run`;
                runContainer.style.display = 'inline';
                
                // Verify NO anchors are being processed (should be caught earlier)
                const hasAnchors = runElements.some(el => el.tagName === 'A');
                if (hasAnchors) {
                    logger.e( `COALESCE-ERROR: Anchor elements reached replaceRunWithSingleElement - this should never happen`);
                    this.updateCoalescingTelemetry('anchor_merge_prevented', runElements.length);
                    return; // Abort wrapper creation for safety
                }
                
                // Insert container before first element
                const parent = runElements[0].parentElement;
                if (parent) {
                    parent.insertBefore(runContainer, runElements[0]);
                    
                    // Move all elements into container WITHOUT modifying their internal structure
                    // Each element retains its exact DOM structure, attributes, and event handlers
                    for (const element of runElements) {
                        if (element.parentElement) {
                            runContainer.appendChild(element);
                        }
                    }
                    
                    // Wrapper container styling: Keep neutral - children retain semantic classes
                    
                    logger.d( `WRAPPER-SUCCESS: Created wrapper for ${runElements.length} elements - preserved individual identity`);
                }
            }

            // LEGACY METHOD REMOVED - coalesceInlineChanges disabled to preserve semantic DOM structure

            // LEGACY METHOD REMOVED - coalesceBlockChanges disabled to preserve semantic DOM structure

            // LEGACY METHODS REMOVED - All structural merging disabled to preserve semantic DOM integrity
            // Phase 5 now uses only visual presentation wrappers without DOM modification


            isInlineElement(element) {
                const inlineElements = new Set(['A', 'SPAN', 'EM', 'STRONG', 'B', 'I', 'U', 'CODE', 'MARK', 'SMALL', 'SUP', 'SUB']);
                return inlineElements.has(element.tagName);
            }

            deepCloneElement(sourceElement, targetParent) {
                if (!sourceElement || !sourceElement.childNodes) return;

                // Clone all child nodes recursively
                for (let i = 0; i < sourceElement.childNodes.length; i++) {
                    const sourceChild = sourceElement.childNodes[i];
                    let clonedChild;

                    if (sourceChild.nodeType === Node.ELEMENT_NODE) {
                        // Create element with all attributes
                        clonedChild = document.createElement(sourceChild.tagName.toLowerCase());
                        for (let j = 0; j < sourceChild.attributes.length; j++) {
                            const attr = sourceChild.attributes[j];
                            clonedChild.setAttribute(attr.name, attr.value);
                        }
                        // Recursively clone children
                        this.deepCloneElement(sourceChild, clonedChild);
                    } else if (sourceChild.nodeType === Node.TEXT_NODE) {
                        clonedChild = document.createTextNode(sourceChild.textContent);
                    } else {
                        // Other node types (comments, etc.)
                        clonedChild = sourceChild.cloneNode(false);
                    }

                    if (clonedChild) {
                        targetParent.appendChild(clonedChild);
                    }
                }
            }

            applyInsertionAnnotation(outputDOM, operation) {
                const element = this.findElementByRoute(outputDOM, operation.route);
                
                // Strict semantic classification - no fallback to default classes
                if (!operation.visualTreatment?.cssClass) {
                    logger.e( `SEMANTIC-ERROR: Operation at route [${operation.route.join(',')}] lacks visualTreatment.cssClass - skipping annotation`);
                    return;
                }
                
                const cssClass = operation.visualTreatment.cssClass;
                
                if (element && element.nodeType === Node.ELEMENT_NODE) {
                    element.classList.add(cssClass);
                    logger.d( `Applied semantic insertion annotation (${cssClass}) at route [${operation.route.join(',')}]`);
                } else if (element && element.nodeType === Node.TEXT_NODE && element.parentElement) {
                    // For text insertions, create semantic highlighting 
                    const parent = element.parentElement;
                    const span = document.createElement('span');
                    span.classList.add(cssClass);

                    parent.insertBefore(span, element);
                    span.appendChild(element);

                    logger.d( `Applied inline-first text insertion annotation at route [${operation.route.join(',')}]`);
                } else {
                    logger.d( `Could not find element for insertion annotation at route [${operation.route.join(',')}]`);
                }
            }

            applyMoveAnnotation(outputDOM, operation) {
                const element = this.findElementByRoute(outputDOM, operation.route);
                
                // Strict semantic classification - no fallback to default classes
                if (!operation.visualTreatment?.cssClass) {
                    logger.e( `SEMANTIC-ERROR: Move operation at route [${operation.route.join(',')}] lacks visualTreatment.cssClass - skipping annotation`);
                    return;
                }
                
                const cssClass = operation.visualTreatment.cssClass;
                
                if (element && element.nodeType === Node.ELEMENT_NODE) {
                    element.classList.add(cssClass);
                    logger.d( `Applied semantic move annotation (${cssClass}) at route [${operation.route.join(',')}]`);
                } else {
                    logger.d( `Could not find element for move annotation at route [${operation.route.join(',')}]`);
                }
            }

            applyModificationAnnotation(outputDOM, operation) {
                // Strict semantic classification for modifications
                if (!operation.visualTreatment?.cssClass) {
                    logger.e( `SEMANTIC-ERROR: Modification operation at route [${operation.route.join(',')}] lacks visualTreatment.cssClass - skipping annotation`);
                    return;
                }
                
                const element = this.findElementByRoute(outputDOM, operation.route);
                const cssClass = operation.visualTreatment.cssClass;
                
                if (element && element.nodeType === Node.ELEMENT_NODE) {
                    element.classList.add(cssClass);
                    logger.d( `Applied semantic modification annotation (${cssClass}) at route [${operation.route.join(',')}]`);
                } else if (element && element.nodeType === Node.TEXT_NODE && element.parentElement) {
                    // For text modifications, wrap in span with semantic class
                    const parent = element.parentElement;
                    const span = document.createElement('span');
                    span.classList.add(cssClass);

                    parent.insertBefore(span, element);
                    span.appendChild(element);

                    logger.d( `Applied semantic text modification annotation (${cssClass}) at route [${operation.route.join(',')}]`);
                } else {
                    logger.d( `Could not find element for modification annotation at route [${operation.route.join(',')}]`);
                }
            }

            handleTextModification(outputDOM, operation, routeElementMap) {
                logger.d( `Processing text modification at route [${operation.route.join(',')}]: "${operation.oldValue}" → "${operation.newValue}"`);

                // GADS Phase 3: Element Lookup - Traverse route to locate target element
                const element = this.findElementByRoute(outputDOM, operation.route);
                if (!element) {
                    const routeDetails = `Route traversal failed: Could not locate element at route [${operation.route.join(',')}] in output DOM. DOM structure may have changed during processing. Output DOM root: ${outputDOM.tagName || 'unknown'}`;
                    logger.e( routeDetails);
                    this.insertSingleErrorMarker(outputDOM, operation);
                    return;
                }

                // Create inline deletion for old value if it exists and differs from new value
                if (operation.oldValue && operation.oldValue !== operation.newValue) {
                    const contentMatches = this.validateElementContent(element, operation.newValue);
                    
                    if (contentMatches) {
                        // Use createDeletionBadge helper for consistent DFK-aware styling
                        const dfkEntry = {
                            kind: '#text',
                            tag: 'span',
                            textContent: operation.oldValue
                        };
                        const dedupeKey = `text-mod-${operation.route.join(',')}-${operation.oldValue}`;
                        const badgeResult = this.createDeletionBadge(dfkEntry, dedupeKey);

                        // Insert before the target element
                        if (element.parentNode) {
                            element.parentNode.insertBefore(badgeResult.element, element);
                        }
                        logger.d( `Applied deletion badge for: "${operation.oldValue}"`);
                    } else {
                        logger.e( `Content mismatch - expected "${operation.newValue}", found "${element.textContent}"`);
                    }
                }

                // Apply insertion styling to new value
                if (operation.newValue) {
                    const insertionSuccess = this.applyInsertionStyling(element, operation.newValue);
                    if (insertionSuccess) {
                        logger.d( `Applied insertion styling to: "${operation.newValue}"`);
                    } else {
                        logger.e( `Failed to apply insertion styling to: "${operation.newValue}"`);
                        this.insertSingleErrorMarker(outputDOM, operation);
                    }
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }


            // GADS Phase 3: Content Validation - Verify element content matches expected value
            validateElementContent(element, expectedContent) {
                if (element.nodeType === Node.TEXT_NODE) {
                    return element.textContent === expectedContent;
                } else if (element.nodeType === Node.ELEMENT_NODE) {
                    return element.textContent === expectedContent;
                } else {
                    return false;
                }
            }


            // GADS Phase 3: Apply insertion styling to new content
            applyInsertionStyling(element, newContent) {
                try {
                    if (element.nodeType === Node.TEXT_NODE) {
                        // For text nodes, wrap in a span with semantic styling
                        const span = document.createElement('span');
                        span.classList.add('gad-inline-addition');
                        span.textContent = newContent;

                        // Replace the text node with our highlighted span
                        if (element.parentNode) {
                            element.parentNode.replaceChild(span, element);
                            return true;
                        }
                    } else if (element.nodeType === Node.ELEMENT_NODE) {
                        // For element nodes, add semantic insertion styling
                        element.classList.add('gad-inline-addition');
                        return true;
                    }
                    return false;
                } catch (error) {
                    logger.e( `Exception during insertion styling: ${error.message}`);
                    return false;
                }
            }

            // GADS Phase 3: Failure Handling - Insert error marker for diagnostic purposes
            insertProcessingErrorMarker(outputDOM, route, errorMessage, operation, detailedError) {
                const errorSpan = document.createElement('span');
                errorSpan.classList.add('gad-fatal-error');
                errorSpan.textContent = '⚠️ DIFF-ERROR';
                
                // Create detailed tooltip with all diagnostic information
                const tooltipContent = [
                    `ERROR: ${errorMessage}`,
                    `ROUTE: [${route.join(',')}]`,
                    `OPERATION: "${operation.oldValue || 'N/A'}" → "${operation.newValue || 'N/A'}"`,
                    detailedError ? `DETAILS: ${detailedError}` : '',
                    `TIMESTAMP: ${new Date().toISOString()}`
                ].filter(Boolean).join(' | ');
                
                errorSpan.title = tooltipContent;

                // Try to insert near the problem location
                try {
                    const approximateElement = this.findApproximateElementByRoute(outputDOM, route);
                    if (approximateElement && approximateElement.parentNode) {
                        approximateElement.parentNode.insertBefore(errorSpan, approximateElement);
                        logger.e( `Inserted error marker near route [${route.join(',')}]`);
                    } else {
                        // Fallback: append to document body or first available container
                        const fallbackContainer = outputDOM.querySelector('body') || outputDOM.querySelector('div') || outputDOM;
                        if (fallbackContainer) {
                            fallbackContainer.appendChild(errorSpan);
                            logger.e( `Inserted error marker in fallback container (${fallbackContainer.tagName || 'unknown'})`);
                        }
                    }
                } catch (fallbackError) {
                    logger.e( `Failed to insert error marker: ${fallbackError.message}`);
                }
            }

            insertSingleErrorMarker(outputDOM, operation) {
                // GADS Error Handling: One-op, one-marker error policy with CSS classes
                const errorSpan = document.createElement('span');
                errorSpan.classList.add('gad-processing-error');
                errorSpan.textContent = '⚠️';
                
                // Create detailed tooltip with diagnostic information
                const tooltipContent = [
                    `ERROR: ${operation.errorReason || 'Processing failed'}`,
                    `ROUTE: [${operation.route.join(',')}]`,
                    `OPERATION: "${operation.oldValue || ''}" → "${operation.newValue || ''}"`,
                    `TIMESTAMP: ${new Date().toISOString()}`
                ].filter(Boolean).join(' | ');
                
                errorSpan.title = tooltipContent;
                
                // Insert as sibling/overlay, not as nested child that alters order
                try {
                    const insertionPoint = this.findSemanticAnchor(outputDOM, operation.route);
                    if (insertionPoint && insertionPoint.parentNode) {
                        insertionPoint.parentNode.insertBefore(errorSpan, insertionPoint.nextSibling);
                        logger.e( `Inserted single error marker for route [${operation.route.join(',')}]`);
                    } else {
                        // Fallback: append to root without nesting
                        outputDOM.appendChild(errorSpan);
                    }
                } catch (e) {
                    logger.e( `Failed to insert error marker: ${e.message}`);
                }
            }
            
            findSemanticAnchor(dom, route) {
                // Find nearest stable block/id/href in the target tree for error marker placement
                let element = dom;
                let lastValidElement = element;
                
                for (let i = 0; i < route.length; i++) {
                    const index = route[i];
                    if (element.childNodes && element.childNodes[index]) {
                        element = element.childNodes[index];
                        // Prefer elements with stable identifiers
                        if (element.nodeType === Node.ELEMENT_NODE && 
                            (element.id || element.href || element.className)) {
                            lastValidElement = element;
                        }
                    } else {
                        break; // Stop at first invalid route segment
                    }
                }
                
                return lastValidElement;
            }

            // Helper: Find approximate element when exact route fails
            findApproximateElementByRoute(dom, route) {
                let element = dom;
                // Try to traverse as far as possible through the route
                for (let i = 0; i < route.length && element; i++) {
                    if (element.childNodes && element.childNodes[route[i]]) {
                        element = element.childNodes[route[i]];
                    } else {
                        // Return the deepest element we could reach
                        break;
                    }
                }
                return element;
            }

            // Helper: Get route array for an element (reverse of findElementByRoute)
            getElementRoute(element) {
                const route = [];
                let current = element;
                while (current && current.parentNode) {
                    const parent = current.parentNode;
                    for (let i = 0; i < parent.childNodes.length; i++) {
                        if (parent.childNodes[i] === current) {
                            route.unshift(i);
                            break;
                        }
                    }
                    current = parent;
                }
                return route;
            }

            generateDeletionInline(outputDOM, operation) {
                // Fix: Legacy method disabled - all deletions routed through semantic anchor placement
                logger.d( `Legacy generateDeletionInline disabled for ${operation.action} at route [${operation.route.join(',')}]`);
                // No-op - deletions now handled in Phase-6 via applied operations list
            }
            
            generateDeletionInlineLegacy(outputDOM, operation) {
                // DISABLED: Legacy method bypassed - all deletions routed through createDeletionBadge helper
                logger.d( `Legacy generateDeletionInlineLegacy disabled for ${operation.action} at route [${operation.route.join(',')}]`);
                return; // No-op - all deletion styling now flows through createDeletionBadge helper

                // REMOVED CODE: Find insertion point in the DOM
                /*
                const insertPoint = this.findInlineDeletionInsertionPoint(outputDOM, operation.route);
                if (!insertPoint) {
                    logger.d( `Could not find insertion point for route [${operation.route.join(',')}]`);
                    return;
                }

                // Create inline deletion element based on captured content
                if (operation.capturedContent) {
                    let deletionElement;
                    
                    if (operation.capturedType === 'element') {
                        // Check if the deleted element was a link
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = operation.capturedContent;
                        const linkElement = tempDiv.querySelector('a');
                        
                        if (linkElement) {
                            // Keep as link but strike through the text content using GADS semantic class
                            deletionElement = document.createElement('a');
                            deletionElement.href = linkElement.href;
                            deletionElement.className = 'gad-inline-removal';
                            deletionElement.textContent = linkElement.textContent;
                        } else {
                            // Non-link element - extract text and create span using GADS semantic class
                            deletionElement = document.createElement('span');
                            deletionElement.className = 'gad-inline-removal';
                            deletionElement.textContent = this.extractTextFromHtml(operation.capturedContent);
                        }
                    } else {
                        // Text deletion - create span using GADS semantic class
                        deletionElement = document.createElement('span');
                        deletionElement.className = 'gad-inline-removal';
                        deletionElement.textContent = operation.capturedContent;
                    }

                    // Insert the deletion element
                    if (insertPoint.container && deletionElement) {
                        if (insertPoint.insertBefore) {
                            insertPoint.container.insertBefore(deletionElement, insertPoint.insertBefore);
                        } else {
                            insertPoint.container.appendChild(deletionElement);
                        }
                        logger.d( `Inserted inline deletion: "${deletionElement.textContent}"`);
                    }
                }
                */
            }

            findInlineDeletionInsertionPoint(outputDOM, route) {
                logger.d( `Finding inline insertion point for route [${route.join(',')}]`);

                if (route.length === 0) {
                    logger.d( 'Empty route, using output DOM start');
                    return { container: outputDOM, insertBefore: outputDOM.firstChild };
                }

                // Traverse route to find the approximate location
                let element = outputDOM;
                let parentElement = outputDOM;
                let targetIndex = 0;

                for (let i = 0; i < route.length; i++) {
                    if (element.childNodes && element.childNodes[route[i]]) {
                        parentElement = element;
                        targetIndex = route[i];
                        element = element.childNodes[route[i]];
                    } else {
                        // Route traversal failed, use last valid parent
                        break;
                    }
                }

                // Find the best inline insertion point
                if (parentElement && parentElement.childNodes) {
                    const insertBefore = parentElement.childNodes[targetIndex] || null;
                    return { container: parentElement, insertBefore: insertBefore };
                }

                return { container: outputDOM, insertBefore: null };
            }


            createRouteElementMap(dom) {
                logger.d( 'Building route-to-element mapping for deletion capture');
                const routeMap = {};

                const mapElement = (element, route) => {
                    if (!element) return;

                    const routeKey = route.join(',');
                    routeMap[routeKey] = {
                        element: element,
                        nodeType: element.nodeType,
                        outerHTML: element.nodeType === Node.ELEMENT_NODE ? element.outerHTML : null,
                        textContent: element.textContent || '',
                        nodeName: element.nodeName || ''
                    };

                    // Recursively map child nodes
                    if (element.childNodes) {
                        for (let i = 0; i < element.childNodes.length; i++) {
                            const childRoute = [...route, i];
                            mapElement(element.childNodes[i], childRoute);
                        }
                    }
                };

                // Start mapping from root with empty route
                mapElement(dom, []);

                logger.d( `Created mapping for ${Object.keys(routeMap).length} DOM nodes`);
                return routeMap;
            }

            enhanceOperationsWithCapturedContent(diffOperations, routeElementMap) {
                logger.d( `Enhancing ${diffOperations.length} operations with pre-captured content`);

                let deletionsFound = 0;
                let deletionsEnhanced = 0;

                for (const op of diffOperations) {
                    if (op.action === 'removeElement' || op.action === 'removeTextElement') {
                        deletionsFound++;
                        const routeKey = op.route.join(',');
                        logger.d( `Enhancing deletion ${deletionsFound}: ${op.action} at route [${routeKey}]`);

                        const mappedElement = routeElementMap[routeKey];
                        if (mappedElement) {
                            if (mappedElement.nodeType === Node.TEXT_NODE) {
                                op.capturedContent = mappedElement.textContent;
                                op.capturedType = 'text';
                                logger.d( `Enhanced with captured text: "${mappedElement.textContent}"`);
                            } else if (mappedElement.nodeType === Node.ELEMENT_NODE) {
                                op.capturedContent = mappedElement.outerHTML;
                                op.capturedType = 'element';
                                const preview = mappedElement.outerHTML.substring(0, 100);
                                logger.d( `Enhanced with captured element: ${preview}${mappedElement.outerHTML.length > 100 ? '...' : ''}`);
                            } else {
                                op.capturedContent = mappedElement.textContent || `Unknown node: ${mappedElement.nodeName}`;
                                op.capturedType = 'unknown';
                                logger.d( `Enhanced with captured unknown node: ${op.capturedContent}`);
                            }
                            deletionsEnhanced++;
                        } else {
                            logger.d( `No mapping found for deletion route [${routeKey}]`);
                            // Fallback to operation text if available
                            if (op.text) {
                                op.capturedContent = op.text;
                                op.capturedType = 'fallback-text';
                                deletionsEnhanced++;
                                logger.d( `Enhanced with fallback text: "${op.text}"`);
                            }
                        }
                    }
                }

                logger.d( `Operation enhancement complete: ${deletionsEnhanced}/${deletionsFound} deletions enhanced`);
            }

            // ===== 8-PHASE HELPER METHODS =====

            // Phase 2: Create Detached Working DOM with Semantic Anchors
            createDetachedWorkingDOM(immutableToDOM) {
                logger.d( 'Creating independent processing environment');
                const detachedDOM = document.createElement('div');
                this.deepCloneElement(immutableToDOM, detachedDOM);
                logger.d( 'Detached Working DOM created from immutable input');
                return detachedDOM;
            }

            establishSemanticAnchors(detachedWorkingDOM) {
                logger.d( 'Establishing fixed reference points for route resolution');
                const anchors = {};
                const walker = document.createTreeWalker(
                    detachedWorkingDOM,
                    NodeFilter.SHOW_ELEMENT,
                    null,
                    false
                );
                
                let node;
                let anchorIndex = 0;
                while (node = walker.nextNode()) {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const route = this.getElementRoute(node);
                        const anchorId = `anchor_${anchorIndex++}`;
                        anchors[anchorId] = {
                            element: node,
                            route: route,
                            tagName: node.tagName,
                            textContent: node.textContent.substring(0, 50) // Preview for debugging
                        };
                    }
                }
                
                logger.d( `Established ${Object.keys(anchors).length} semantic anchors`);
                return anchors;
            }

            // Phase 3: Create Deletion Fact Table (DFK mapping)
            async createDeletionFactTable(immutableFromDOM) {
                logger.d( 'Creating GADS-compliant 4-field DFK mapping for stable fragment preservation');
                const deletionFactTable = {};
                
                // GADS Canonical DFK Schema: 4-field canonicalization
                const factDedupeMap = new Map();
                let beforeDedupeCount = 0;
                let dedupeDropCount = 0;
                let collisionCount = 0;
                
                const mapElementForDeletion = async (element, route) => {
                    if (!element) return;
                    
                    beforeDedupeCount++;
                    
                    // Field 1: Route (absolute route in "from" DOM at capture time)
                    const routeStr = route.length === 0 ? "root" : route.join(',');
                    
                    // Field 2: Kind (node kind)
                    const kind = element.nodeType === Node.ELEMENT_NODE ? '#element' :
                                element.nodeType === Node.TEXT_NODE ? '#text' :
                                element.nodeType === Node.COMMENT_NODE ? '#comment' :
                                `#nodeType${element.nodeType}`;
                    
                    // Field 3: Tag (uppercased tag name for elements, #text for text nodes)
                    const tag = element.nodeType === Node.ELEMENT_NODE ? element.tagName.toUpperCase() :
                               element.nodeType === Node.TEXT_NODE ? '#text' :
                               element.nodeName?.toUpperCase() || '#unknown';
                    
                    // Field 4: Payload hash (SHA-256 of normalized payload)
                    const normalizedPayload = this.normalizePayload(element);
                    const payloadHash = await this.strongHash(normalizedPayload);
                    
                    // GADS Canonical Key Format: dfk:<route>|<kind>|<tag>|sha256:<hex>
                    const canonicalKey = `dfk:${routeStr}|${kind}|${tag}|${payloadHash}`;
                    
                    // Development assertion: Verify canonical key format compliance
                    if (!/^dfk:.*\|sha256:[a-f0-9]{64}$/.test(canonicalKey)) {
                        logger.e( `DFK-FORMAT-ERROR: Malformed key "${canonicalKey}" - expected sha256:<64-hex> suffix`);
                        throw new Error(`Invalid DFK key format: ${canonicalKey}`);
                    }
                    
                    // GADS Fact-level Dedupe Policy: Only drop when ALL four fields match
                    const dedupeKey = `${routeStr}|${kind}|${tag}|${payloadHash}`;
                    if (factDedupeMap.has(dedupeKey)) {
                        dedupeDropCount++;
                        logger.d( `Dropped duplicate fact: ${canonicalKey}`);
                        return;
                    }
                    
                    // GADS Collision Handling: If same hash but different payload, suffix with :v2, :v3
                    let finalKey = canonicalKey;
                    let version = 1;
                    while (deletionFactTable[finalKey] && 
                           deletionFactTable[finalKey].normalizedPayload !== normalizedPayload) {
                        version++;
                        finalKey = `${canonicalKey}:v${version}`;
                        collisionCount++;
                        logger.d( `Hash collision detected, using version ${version}`);
                    }
                    
                    factDedupeMap.set(dedupeKey, true);
                    
                    // Store with enhanced metadata for GADS compliance
                    deletionFactTable[finalKey] = {
                        route: [...route],
                        kind: kind,
                        tag: tag,
                        payloadHash: payloadHash,
                        normalizedPayload: normalizedPayload,
                        nodeType: element.nodeType,
                        outerHTML: element.nodeType === Node.ELEMENT_NODE ? element.outerHTML : null,
                        textContent: element.textContent || '',
                        routeStr: routeStr
                    };
                    
                    // Recursively map child nodes
                    if (element.childNodes) {
                        for (let i = 0; i < element.childNodes.length; i++) {
                            const childRoute = [...route, i];
                            await mapElementForDeletion(element.childNodes[i], childRoute);
                        }
                    }
                };
                
                // Start mapping from immutable "from" DOM
                await mapElementForDeletion(immutableFromDOM, []);
                
                // Enhanced DFK fact capture telemetry
                const factsRecorded = Object.keys(deletionFactTable).length;
                logger.d( `DFK FACT CAPTURE COMPLETED: ${factsRecorded} canonical facts recorded (${beforeDedupeCount} nodes processed, ${dedupeDropCount} duplicates deduped, ${collisionCount} hash collisions resolved)`);
                console.log(`[DFK-CAPTURE-TELEMETRY] facts_captured=${factsRecorded}, nodes_processed=${beforeDedupeCount}, duplicates_dropped=${dedupeDropCount}, collisions_resolved=${collisionCount}, deduplication_rate=${((dedupeDropCount / beforeDedupeCount) * 100).toFixed(1)}%`);
                
                // Sample DFK keys for validation
                const sampleKeys = Object.keys(deletionFactTable).slice(0, 3);
                if (sampleKeys.length > 0) {
                    logger.d( `DFK FORMAT VALIDATION - Sample keys:`);
                    sampleKeys.forEach(key => {
                        logger.d( `  ${key}`);
                    });
                }
                
                return deletionFactTable;
            }

            
            // GADS DFK Helper: Normalize payload for consistent hashing
            //
            // Normalization Rules:
            // 1. Element nodes: Serialize as outerHTML with sorted attributes and normalized whitespace
            // 2. Text nodes: Trim and collapse whitespace sequences to single spaces
            // 3. Other nodes: Use textContent only
            // 4. Attribute ordering: Alphabetical by attribute name for deterministic output
            // 5. Whitespace normalization: Trim leading/trailing, collapse internal sequences
            //
            // This ensures identical payloads produce identical hashes regardless of DOM position
            normalizePayload(element) {
                if (element.nodeType === Node.ELEMENT_NODE) {
                    // For elements: serialized outerHTML with normalized attribute order
                    const attributes = Array.from(element.attributes || [])
                        .sort((a, b) => a.name.localeCompare(b.name))
                        .map(attr => `${attr.name}="${attr.value}"`)
                        .join(' ');
                    
                    const tagName = element.tagName.toLowerCase();
                    const innerHTML = element.innerHTML.trim()
                        .replace(/\s+/g, ' '); // Normalize insignificant whitespace
                    
                    return attributes ? 
                        `<${tagName} ${attributes}>${innerHTML}</${tagName}>` :
                        `<${tagName}>${innerHTML}</${tagName}>`;
                        
                } else if (element.nodeType === Node.TEXT_NODE) {
                    // For text nodes: normalized whitespace (no leading/trailing collapse beyond HTML rules)
                    return element.textContent?.trim().replace(/\s+/g, ' ') || '';
                } else {
                    // For other node types: just the text content
                    return element.textContent || '';
                }
            }
            
            // GADS DFK Helper: SHA-256 hash function (Web Crypto API)
            async strongHash(str) {
                // Use Web Crypto API for proper SHA-256 hashing as required by GADS specification
                // This provides cryptographically strong, deterministic DFK payload hashing
                const encoder = new TextEncoder();
                const data = encoder.encode(str);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = new Uint8Array(hashBuffer);
                const hexHash = Array.from(hashArray)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                
                // Return canonical format with sha256: prefix
                return `sha256:${hexHash}`;
            }

            // Utility: Clamp value to range for route index safety
            clamp(value, min, max) {
                return Math.min(Math.max(value, min), max);
            }

            // Utility: Inline element detection for anchor refinement
            isInlineElement(element) {
                if (!element || element.nodeType !== Node.ELEMENT_NODE) return false;
                
                // Tag whitelist for common inline elements
                const inlineTags = new Set(['a', 'span', 'em', 'strong', 'code', 'kbd', 'sup', 'sub', 
                                          'small', 'b', 'i', 'u', 'mark', 'abbr', 'time', 'var', 's', 'q']);
                
                if (inlineTags.has(element.tagName.toLowerCase())) {
                    return true;
                }
                
                // Secondary check via computed style
                try {
                    const computedStyle = getComputedStyle(element);
                    return computedStyle.display === 'inline';
                } catch (e) {
                    return false;
                }
            }

            // Phase 4.5: Semantic Classification - Classify operations into semantic change types
            classifySemanticChanges(diffOperations, immutableFromDOM, immutableToDOM) {
                logger.d( 'Starting semantic change classification for precise styling');
                
                const classifiedOperations = diffOperations.map(op => {
                    // Create a copy of the operation with semantic metadata
                    const classifiedOp = { ...op };
                    
                    // Classify operations into semantic change types
                    classifiedOp.semanticType = this.determineSemanticType(op, immutableFromDOM, immutableToDOM);
                    classifiedOp.visualTreatment = this.getVisualTreatment(classifiedOp.semanticType);
                    
                    logger.d( `Operation at route [${op.route?.join(',') || 'unknown'}]: ${op.action} → ${classifiedOp.semanticType}`);
                    
                    return classifiedOp;
                });
                
                // Group related operations by proximity and timing
                this.groupRelatedOperations(classifiedOperations);
                
                logger.d( `Semantic classification completed for ${classifiedOperations.length} operations`);
                return classifiedOperations;
            }
            
            // Helper: Determine semantic change type for an operation
            determineSemanticType(operation, fromDOM, toDOM) {
                const { action, route } = operation;
                
                switch (action) {
                    case 'addElement':
                    case 'addTextElement':
                        return this.isBlockLevelAddition(operation, toDOM) ? 
                            'BLOCK_ADDITION' : 'INLINE_ADDITION';
                    
                    case 'removeElement':
                    case 'removeTextElement':
                        // Removals are handled by DFK placement, classify for reference
                        return this.isBlockLevelRemoval(operation, fromDOM) ? 
                            'BLOCK_REMOVAL' : 'INLINE_REMOVAL';
                    
                    case 'relocateNode':
                        return 'STRUCTURAL_CHANGE';
                    
                    case 'modifyTextElement':
                    case 'modifyValue':
                    case 'modifyAttribute':
                        return 'INLINE_MODIFICATION';
                    
                    default:
                        logger.d( `Unknown operation action: ${action}`);
                        return 'INLINE_MODIFICATION';
                }
            }
            
            // Helper: Check if addition creates block-level structure
            isBlockLevelAddition(operation, toDOM) {
                if (operation.action !== 'addElement') return false;
                
                const blockElements = ['P', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 
                                     'LI', 'TD', 'TH', 'BLOCKQUOTE', 'PRE', 'SECTION', 
                                     'ARTICLE', 'HEADER', 'FOOTER', 'NAV', 'ASIDE', 'MAIN'];
                
                // Primary check: Element tag type
                const elementTag = operation.element?.tagName;
                if (blockElements.includes(elementTag)) {
                    logger.d( `BLOCK-LEVEL-ADDITION: ${elementTag} detected as block element`);
                    return true;
                }
                
                // Enhanced check: Element structure analysis
                if (operation.element) {
                    // Check if element contains block-level children
                    const hasBlockChildren = Array.from(operation.element.children || [])
                        .some(child => blockElements.includes(child.tagName));
                    
                    // Check if element has significant text content (paragraph-like)
                    const textContent = operation.element.textContent || '';
                    const hasSignificantContent = textContent.length > 50 || textContent.includes('\n');
                    
                    // Check parent context - if being added to inline context, prefer inline treatment
                    const targetElement = this.findElementByRoute(toDOM, operation.route.slice(0, -1));
                    const inlineParents = ['SPAN', 'A', 'EM', 'STRONG', 'B', 'I', 'CODE'];
                    const hasInlineParent = targetElement && inlineParents.includes(targetElement.tagName);
                    
                    if ((hasBlockChildren || hasSignificantContent) && !hasInlineParent) {
                        logger.d( `BLOCK-LEVEL-ADDITION: ${elementTag} classified as block due to structure (children: ${hasBlockChildren}, content: ${hasSignificantContent})`);
                        return true;
                    }
                }
                
                logger.d( `INLINE-ADDITION: ${elementTag} classified as inline element`);
                return false;
            }
            
            // Helper: Check if removal was block-level element
            isBlockLevelRemoval(operation, fromDOM) {
                if (!operation.dfkMetadata) return false;
                
                const blockElements = ['P', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 
                                     'LI', 'TD', 'TH', 'BLOCKQUOTE', 'PRE', 'SECTION', 
                                     'ARTICLE', 'HEADER', 'FOOTER', 'NAV', 'ASIDE', 'MAIN'];
                
                return blockElements.includes(operation.dfkMetadata.tag);
            }
            
            // Helper: Get visual treatment for semantic type
            getVisualTreatment(semanticType) {
                const treatments = {
                    'INLINE_ADDITION': {
                        cssClass: 'gad-inline-addition',
                        description: 'Inline highlighting with background color, no container styling'
                    },
                    'BLOCK_ADDITION': {
                        cssClass: 'gad-block-addition', 
                        description: 'Block-level highlighting with border and background'
                    },
                    'INLINE_MODIFICATION': {
                        cssClass: 'gad-inline-modification',
                        description: 'Subtle highlighting for specific changed text only'
                    },
                    'STRUCTURAL_CHANGE': {
                        cssClass: 'gad-structural-change',
                        description: 'Move indicators and positional annotations'
                    },
                    'BLOCK_REMOVAL': {
                        cssClass: 'gad-block-removal',
                        description: 'Block-level deletion styling (handled by DFK placement)'
                    },
                    'INLINE_REMOVAL': {
                        cssClass: 'gad-inline-removal', 
                        description: 'Inline deletion styling (handled by DFK placement)'
                    }
                };
                
                return treatments[semanticType] || treatments['INLINE_MODIFICATION'];
            }
            
            // Helper: Generate semantic breakdown statistics for debug output
            generateSemanticBreakdown(classifiedOperations) {
                const breakdown = {};
                for (const op of classifiedOperations) {
                    const type = op.semanticType || 'UNCLASSIFIED';
                    breakdown[type] = (breakdown[type] || 0) + 1;
                }
                return breakdown;
            }
            
            // Helper: Group related operations by proximity and timing
            groupRelatedOperations(classifiedOperations) {
                // Phase 1: Operation Pattern Analysis
                for (let i = 0; i < classifiedOperations.length; i++) {
                    const op = classifiedOperations[i];
                    
                    // Group operations affecting adjacent DOM nodes or same parent
                    const proximateOps = classifiedOperations.filter((otherOp, j) => {
                        if (i === j) return false;
                        return this.areOperationsRelated(op, otherOp);
                    });
                    
                    if (proximateOps.length > 0) {
                        op.relatedOperations = proximateOps.map(relOp => relOp.route?.join(',') || 'unknown');
                        logger.d( `Operation at [${op.route?.join(',') || 'unknown'}] has ${proximateOps.length} related operations`);
                    }
                }
            }
            
            // Helper: Check if operations are related by proximity
            areOperationsRelated(op1, op2) {
                if (!op1.route || !op2.route) return false;
                
                // Same parent if routes differ only in last index
                if (op1.route.length === op2.route.length && op1.route.length > 0) {
                    const parent1 = op1.route.slice(0, -1);
                    const parent2 = op2.route.slice(0, -1);
                    return parent1.join(',') === parent2.join(',');
                }
                
                // Adjacent siblings if routes are consecutive
                if (op1.route.length === op2.route.length) {
                    const lastIndex1 = op1.route[op1.route.length - 1];
                    const lastIndex2 = op2.route[op2.route.length - 1];
                    return Math.abs(lastIndex1 - lastIndex2) === 1;
                }
                
                return false;
            }

            // Phase 4: Enhance operations with DFK
            enhanceOperationsWithDFK(diffOperations, deletionFactTable) {
                logger.d( `DFK ENHANCEMENT: Processing ${diffOperations.length} operations with GADS DFK mappings`);
                
                // Enhancement telemetry counters
                let deletionOpsFound = 0;
                let dfkEnhancements = 0;
                let unresolvedOps = 0;
                
                for (const op of diffOperations) {
                    if (op.action === 'removeElement' || op.action === 'removeTextElement') {
                        deletionOpsFound++;
                        
                        // GADS Primary Match: op.route → DFK.route exact string equality
                        const opRouteStr = op.route.length === 0 ? "root" : op.route.join(',');
                        
                        // Find DFK entry with matching route
                        let matchedDfkKey = null;
                        let matchedEntry = null;
                        
                        for (const [dfkKey, dfkEntry] of Object.entries(deletionFactTable)) {
                            if (dfkEntry.routeStr === opRouteStr) {
                                matchedDfkKey = dfkKey;
                                matchedEntry = dfkEntry;
                                break;
                            }
                        }
                        
                        if (matchedEntry) {
                            // Attach DFK ID to operation for Phase 6 placement
                            op.dfkId = matchedDfkKey;
                            op.capturedContent = matchedEntry.outerHTML || matchedEntry.textContent;
                            op.capturedType = matchedEntry.nodeType === Node.ELEMENT_NODE ? 'element' : 'text';
                            op.dfkMetadata = {
                                route: matchedEntry.route,
                                kind: matchedEntry.kind,
                                tag: matchedEntry.tag,
                                payloadHash: matchedEntry.payloadHash
                            };
                            dfkEnhancements++;
                            logger.d( `DFK-ENHANCED: ${matchedDfkKey.substring(0, 60)}... attached to ${op.action} operation`);
                        } else {
                            unresolvedOps++;
                            logger.d( `DFK-UNRESOLVED: No DFK match for route [${opRouteStr}] - operation flagged as unresolved`);
                        }
                    }
                }
                
                // Report enhancement metrics
                logger.d( `DFK ENHANCEMENT COMPLETED: deletion_ops=${deletionOpsFound}, enhanced=${dfkEnhancements}, unresolved=${unresolvedOps}, enhancement_rate=${((dfkEnhancements / deletionOpsFound) * 100).toFixed(1)}%`);
                console.log(`[DFK-ENHANCEMENT-TELEMETRY] deletion_operations=${deletionOpsFound}, dfk_enhanced=${dfkEnhancements}, unresolved=${unresolvedOps}, enhancement_success_rate=${((dfkEnhancements / deletionOpsFound) * 100).toFixed(1)}%`);
            }

            // PRIORITY FIX #1: Drop unresolved ops before apply
            dropUnresolvedOperations(workingDOM, operations) {
                logger.d( 'Testing route resolution for all operations');
                const readOnlyDOM = workingDOM.cloneNode(true);
                const resolvedOps = [];
                let droppedCount = 0;
                
                for (const op of operations) {
                    const targetElement = this.findElementByRoute(readOnlyDOM, op.route);
                    if (targetElement) {
                        resolvedOps.push(op);
                    } else {
                        droppedCount++;
                        logger.d( `Dropped unresolved operation: ${op.action} at route [${op.route.join(',')}]`);
                    }
                }
                
                logger.d( `Pre-apply filtering complete: ${droppedCount} unresolved ops dropped`);
                return resolvedOps;
            }

            // PRIORITY FIX #2: Canonicalize & deduplicate ops pre-apply  
            canonicalizeAndDeduplicateOperations(operations) {
                logger.d( 'Deduplicating operations by (route, action) with element-first precedence');
                const canonicalOps = [];
                const seenKeys = new Set();
                let duplicateCount = 0;
                
                // PRIORITY FIX #3: Stop dual deletions for anchors - process in element-first order
                const sortedOps = [...operations].sort((a, b) => {
                    // Element operations come before text operations for same route
                    const routeCompare = a.route.join(',').localeCompare(b.route.join(','));
                    if (routeCompare !== 0) return routeCompare;
                    
                    // For same route: removeElement before removeTextElement
                    if (a.action === 'removeElement' && b.action === 'removeTextElement') return -1;
                    if (a.action === 'removeTextElement' && b.action === 'removeElement') return 1;
                    
                    return a.action.localeCompare(b.action);
                });
                
                for (const op of sortedOps) {
                    const canonicalKey = `${op.route.join(',')}_${op.action}`;
                    
                    if (!seenKeys.has(canonicalKey)) {
                        seenKeys.add(canonicalKey);
                        canonicalOps.push(op);
                    } else {
                        duplicateCount++;
                        logger.d( `Deduplicated: ${op.action} at route [${op.route.join(',')}]`);
                    }
                }
                
                logger.d( `Canonicalization complete: ${duplicateCount} duplicates removed, ${canonicalOps.length} operations remain`);
                return canonicalOps;
            }

            // Phase 5: Assemble Annotated DOM
            assembleAnnotatedDOM(detachedWorkingDOM, diffOperations, semanticAnchors, fromCommit, toCommit) {
                logger.d( 'Processing diff operations using true two-phase approach');
                
                // PRIORITY FIX #1: Drop unresolved ops before apply
                logger.d( 'Filtering out unresolved operations before apply phase');
                const preFilteredOps = this.dropUnresolvedOperations(detachedWorkingDOM, diffOperations);
                logger.d( `Dropped ${diffOperations.length - preFilteredOps.length} unresolved operations`);
                
                // PRIORITY FIX #2: Canonicalize & deduplicate ops pre-apply
                const canonicalOps = this.canonicalizeAndDeduplicateOperations(preFilteredOps);
                logger.d( `Deduplicated ${preFilteredOps.length - canonicalOps.length} operations`);
                
                // Phase A: Resolve all diff-op routes to stable references (ZERO DOM mutation)
                logger.d( `Resolving routes for ${canonicalOps.length} operations - READ ONLY`);
                const resolvedOperations = [];
                const preResolutionSnapshot = []; // Fix: Debug snapshot for route resolution
                
                // Fix: Create pristine read-only DOM for route resolution
                const readOnlyDOM = detachedWorkingDOM.cloneNode(true);
                
                for (const op of canonicalOps) {
                    const resolvedOp = { ...op }; // Shallow copy operation
                    // Fix: Use read-only DOM, never mutate during resolution
                    const targetElement = this.findElementByRoute(readOnlyDOM, op.route);
                    
                    // Fix: Record pre-resolution state
                    preResolutionSnapshot.push({
                        action: op.action,
                        route: [...op.route],
                        routeString: op.route.join(','),
                        resolved: !!targetElement,
                        targetNodeType: targetElement ? targetElement.nodeType : null,
                        targetTag: targetElement && targetElement.tagName ? targetElement.tagName : null
                    });
                    
                    if (targetElement) {
                        // Fix: Store stable reference info, not mutable DOM element
                        resolvedOp.resolvedNodeType = targetElement.nodeType;
                        resolvedOp.resolvedTagName = targetElement.tagName;
                        resolvedOp.resolvedTextContent = targetElement.textContent;
                        resolvedOp.resolved = true;
                        resolvedOperations.push(resolvedOp);
                    } else {
                        // This should not happen due to pre-filtering, but log if it does
                        logger.e( `Unexpected unresolved route after pre-filtering: [${op.route.join(',')}] for ${op.action}`);
                    }
                }
                
                // Fix: Emit phase5_routes_resolved debug snapshot
                const routesResolvedPayload = {
                    originalOperations: diffOperations.length,
                    afterUnresolvedDropped: preFilteredOps.length,
                    afterDeduplication: canonicalOps.length,
                    totalOperations: canonicalOps.length,
                    resolvedCount: preResolutionSnapshot.filter(op => op.resolved).length,
                    failedCount: preResolutionSnapshot.filter(op => !op.resolved).length,
                    operations: preResolutionSnapshot
                };
                const timestamp = new Date().toISOString().replace(/[:.]/g, '').slice(0, -4);
                wsTraceHandler.sendDebugOutput('phase5_routes_resolved', JSON.stringify(routesResolvedPayload, null, 2), fromCommit, toCommit, []);
                
                // Phase B: Apply annotations using resolved references only (separate output DOM)
                logger.d( `Applying annotations for ${resolvedOperations.filter(op => op.resolved).length} resolved operations`);
                // Fix: Create fresh output DOM for Phase B, never modify the original
                const applyResult = this.applyAnnotationsFromResolved(detachedWorkingDOM, resolvedOperations);
                const assembledDOM = applyResult.outputDOM;
                
                // Fix: Emit phase5_apply_report debug snapshot
                const applyReportPayload = {
                    totalOperations: resolvedOperations.length,
                    appliedCount: applyResult.appliedCount,
                    skippedCount: applyResult.skippedCount,
                    errorCount: applyResult.errorCount,
                    appliedOperations: applyResult.appliedOperations,
                    skippedOperations: applyResult.skippedOperations,
                    errorOperations: applyResult.errorOperations
                };
                wsTraceHandler.sendDebugOutput('phase5_apply_report', JSON.stringify(applyReportPayload, null, 2), fromCommit, toCommit, []);
                
                logger.d( 'Two-phase semantic annotation assembly completed');
                return {
                    outputDOM: assembledDOM,
                    appliedOperations: applyResult.appliedOperations
                };
            }
            
            applyAnnotationsFromResolved(workingDOM, resolvedOperations) {
                logger.d( 'Applying annotations using pre-resolved node references');
                
                // Clone working DOM to avoid mutation during application
                const outputDOM = workingDOM.cloneNode(true);
                
                let insertions = 0, deletions = 0, moves = 0, modifications = 0, errors = 0;
                const processedDeletions = new Set();
                const appliedOperations = [];
                const skippedOperations = [];
                const errorOperations = [];
                
                // Process resolved operations in reverse order
                for (let i = resolvedOperations.length - 1; i >= 0; i--) {
                    const op = resolvedOperations[i];
                    
                    if (!op.resolved) {
                        // Insert single, non-intrusive error marker
                        this.insertSingleErrorMarker(outputDOM, op);
                        errorOperations.push({
                            action: op.action,
                            route: op.route.join(','),
                            reason: op.errorReason
                        });
                        errors++;
                        continue;
                    }
                    
                    // Apply annotation using resolved element reference
                    let applied = false;
                    switch (op.action) {
                        case 'addElement':
                        case 'addTextElement':
                            this.applyInsertionAnnotation(outputDOM, op);
                            insertions++;
                            applied = true;
                            break;
                        case 'removeElement':
                        case 'removeTextElement':
                            const routeKey = op.route.join(',');
                            if (!processedDeletions.has(routeKey)) {
                                // NOTE: Deletion placement now handled in Phase-6 only - legacy path disabled
                                logger.d( `Legacy deletion placement bypassed for ${op.action} at route [${op.route.join(',')}]`);
                                processedDeletions.add(routeKey);
                                deletions++;
                                applied = true;
                            } else {
                                skippedOperations.push({
                                    action: op.action,
                                    route: routeKey,
                                    reason: 'Duplicate deletion'
                                });
                            }
                            break;
                        case 'relocateNode':
                            this.applyMoveAnnotation(outputDOM, op);
                            moves++;
                            applied = true;
                            break;
                        case 'modifyTextElement':
                            this.handleTextModification(outputDOM, op, {});
                            modifications++;
                            applied = true;
                            break;
                        case 'modifyAttribute':
                            this.applyModificationAnnotation(outputDOM, op);
                            modifications++;
                            applied = true;
                            break;
                    }
                    
                    if (applied) {
                        appliedOperations.push({
                            action: op.action,
                            route: op.route.join(','),
                            type: op.action.startsWith('add') ? 'insertion' : 
                                  op.action.startsWith('remove') ? 'deletion' :
                                  op.action.startsWith('relocate') ? 'move' : 'modification'
                        });
                    }
                }
                
                logger.d( `Applied: ${insertions} insertions, ${deletions} deletions, ${moves} moves, ${modifications} modifications, ${errors} errors`);
                
                return {
                    outputDOM,
                    appliedCount: insertions + deletions + moves + modifications,
                    skippedCount: skippedOperations.length,
                    errorCount: errors,
                    appliedOperations,
                    skippedOperations,
                    errorOperations
                };
            }

            // Phase 6: Place Deletion Blocks - SURGICAL REPAIR: Drive from applied ops only
            placeDeletionBlocks(assembledDOM, appliedOperations, deletionFactTable, semanticAnchors) {
                logger.d( 'DFK-DRIVEN PLACEMENT: Positioning deletion blocks using DFK mappings');
                
                // Clone the assembled DOM to avoid modifying input
                const deletionPlacedDOM = assembledDOM.cloneNode(true);
                
                // Filter to deletion operations from Phase-5 applied list
                const appliedDeletions = appliedOperations.filter(op => 
                    op.type === 'deletion' || (op.action && op.action.startsWith('remove'))
                );
                
                // Single-insert invariant: dedupe by (route + action)
                const placedKeys = new Set();
                
                // Enhanced DFK telemetry counters
                let createdBadges = 0;
                let connectedBadges = 0;
                let dfkMatchesfound = 0;
                let dfkMismatches = 0;
                let anchorResolutions = 0;
                let anchorFailures = 0;
                let dfkFallbackAttempts = 0;
                let dfkFallbackSuccess = 0;
                let exactHashMatches = 0;
                let tieBrokenByRoute = 0;
                let unplacedNoHash = 0;
                let dfkFallbackFailed = 0;
                let inlineRemovalsCreated = 0;
                let blockRemovalsCreated = 0;
                
                // Report DFK table status
                const dfkCount = Object.keys(deletionFactTable).length;
                logger.d( `DFK TABLE: ${dfkCount} facts available for placement lookup`);
                logger.d( `APPLIED DELETIONS: Processing ${appliedDeletions.length} deletion operations`);
                
                for (const appliedOp of appliedDeletions) {
                    // Parse route from string format back to array
                    const route = appliedOp.route.split(',').map(Number);
                    const dedupeKey = appliedOp.route + '_' + appliedOp.action;
                    
                    // Skip if already processed this (route + action) combination
                    if (placedKeys.has(dedupeKey)) {
                        logger.d( `Skipped duplicate: ${dedupeKey}`);
                        continue;
                    }
                    
                    // Find DFK entry for content using correct property name
                    const routeKey = appliedOp.route;
                    const dfkKey = Object.keys(deletionFactTable).find(key => 
                        deletionFactTable[key].routeStr === routeKey
                    );
                    
                    if (!dfkKey || !deletionFactTable[dfkKey]) {
                        dfkMismatches++;
                        logger.d( `DFK-MISMATCH: No DFK entry for route [${routeKey}] - attempting semantic-anchor fallback`);
                        
                        // Semantic-anchor bounded fallback for shifted routes with strict payload identity matching
                        dfkFallbackAttempts++;
                        const fallbackResult = await this.findDFKWithinAnchor(deletionPlacedDOM, route, appliedOp, deletionFactTable);
                        
                        if (fallbackResult && fallbackResult.type === 'exact_match') {
                            dfkFallbackSuccess++;
                            exactHashMatches++;
                            logger.d( `DFK-FALLBACK-SUCCESS: Exact hash match ${fallbackResult.dfkKey.substring(0, 60)}... for route [${routeKey}]`);
                            dfkKey = fallbackResult.dfkKey;
                        } else if (fallbackResult && fallbackResult.type === 'tie_broken') {
                            dfkFallbackSuccess++;
                            tieBrokenByRoute++;
                            logger.d( `DFK-FALLBACK-SUCCESS: Tie-broken by route distance ${fallbackResult.distance} for route [${routeKey}]`);
                            dfkKey = fallbackResult.dfkKey;
                        } else if (fallbackResult && fallbackResult.type === 'unplaced') {
                            unplacedNoHash++;
                            logger.d( `DFK-FALLBACK-UNPLACED: No payload hash match for route [${routeKey}] - creating unplaced marker`);
                            
                            // Create unplaced deletion badge at anchor root
                            if (this.createUnplacedDeletionBadge(appliedOp, fallbackResult.anchor)) {
                                createdBadges++;
                                logger.d( `Created unplaced deletion badge for route [${routeKey}]`);
                            }
                            continue;
                        } else {
                            dfkFallbackFailed++;
                            logger.d( `DFK-FALLBACK-FAILED: No semantic anchor found for route [${routeKey}] - operation cannot be placed`);
                            continue;
                        }
                    }
                    
                    dfkMatchesfound++;
                    const dfkEntry = deletionFactTable[dfkKey];
                    logger.d( `DFK-MATCH: Found ${dfkKey.substring(0, 60)}... for route [${routeKey}]`);
                    
                    // Compute anchor using enhanced logic
                    const anchor = this.findStableSemanticAnchor(deletionPlacedDOM, route);
                    if (!anchor) {
                        anchorFailures++;
                        logger.d( `ANCHOR-FAIL: No semantic anchor found for route [${routeKey}]`);
                        continue;
                    }
                    
                    anchorResolutions++;
                    logger.d( `ANCHOR-SUCCESS: Resolved semantic anchor for route [${routeKey}]`);
                    
                    // Check if badge already placed at this location (guard)
                    const existingBadge = deletionPlacedDOM.querySelector(`[data-gad-key="${dedupeKey}"]`);
                    if (existingBadge) {
                        logger.d( `Badge already exists for key: ${dedupeKey}`);
                        continue;
                    }
                    
                    // Create deletion badge
                    const badgeResult = this.createDeletionBadge(dfkEntry, dedupeKey);
                    const deletionBlock = badgeResult.element;
                    createdBadges++;
                    
                    // Track inline vs block removal creation
                    if (badgeResult.isInline) {
                        inlineRemovalsCreated++;
                    } else {
                        blockRemovalsCreated++;
                    }
                    
                    // Smart insertion based on anchor type
                    if (this.insertDeletionBadge(anchor, deletionBlock)) {
                        connectedBadges++;
                        placedKeys.add(dedupeKey);
                        logger.d( `Placed badge for ${dedupeKey}`);
                    }
                }
                
                // Enhanced DFK Pipeline Telemetry
                const mismatch = appliedDeletions.length !== connectedBadges;
                logger.d( `DFK PIPELINE COMPLETED: applied_deletions=${appliedDeletions.length}, dfk_matches=${dfkMatchesfound}, dfk_mismatches=${dfkMismatches}, fallback_attempts=${dfkFallbackAttempts}, fallback_success=${dfkFallbackSuccess}, exact_hash_matches=${exactHashMatches}, tie_broken_by_route=${tieBrokenByRoute}, unplaced_no_hash=${unplacedNoHash}, fallback_failed=${dfkFallbackFailed}, anchor_resolutions=${anchorResolutions}, anchor_failures=${anchorFailures}, created_badges=${createdBadges}, inline_removals=${inlineRemovalsCreated}, block_removals=${blockRemovalsCreated}, connected_badges=${connectedBadges}${mismatch ? ' PLACEMENT MISMATCH!' : ''}`);
                
                // Console telemetry for DFK pipeline effectiveness with strict payload identity tracking
                console.log(`[DFK-TELEMETRY] facts_available=${dfkCount}, operations_processed=${appliedDeletions.length}, dfk_matches=${dfkMatchesfound}, dfk_mismatches=${dfkMismatches}, fallback_attempts=${dfkFallbackAttempts}, fallback_success=${dfkFallbackSuccess}, exact_hash_matches=${exactHashMatches}, tie_broken_by_route=${tieBrokenByRoute}, unplaced_no_hash=${unplacedNoHash}, fallback_failed=${dfkFallbackFailed}, anchor_resolutions=${anchorResolutions}, anchor_failures=${anchorFailures}, badges_placed=${connectedBadges}, inline_removals=${inlineRemovalsCreated}, block_removals=${blockRemovalsCreated}, placement_success_rate=${((connectedBadges / appliedDeletions.length) * 100).toFixed(1)}%`);
                
                // Update status ribbon with enhanced data
                this.updateDeletionTelemetry(appliedDeletions.length, createdBadges, connectedBadges, mismatch);
                
                // Generate phase6_fallback_report for detailed fallback analysis
                if (dfkFallbackAttempts > 0) {
                    const fallbackReport = {
                        summary: {
                            total_deletions: appliedDeletions.length,
                            exact_matches: dfkMatchesfound - dfkFallbackSuccess,
                            fallback_attempts: dfkFallbackAttempts,
                            fallback_success: dfkFallbackSuccess,
                            fallback_failed: dfkFallbackFailed,
                            success_rate: `${((dfkFallbackSuccess / dfkFallbackAttempts) * 100).toFixed(1)}%`
                        },
                        unresolved_operations: appliedDeletions.filter(op => {
                            const routeKey = op.route;
                            const dfkKey = Object.keys(deletionFactTable).find(key => 
                                deletionFactTable[key].routeStr === routeKey
                            );
                            return !dfkKey && !placedKeys.has(routeKey + '_' + op.action);
                        }).map(op => ({
                            route: op.route,
                            action: op.action,
                            kind: op.kind,
                            tag: op.tag
                        }))
                    };
                    
                    // Send fallback report via WebSocket for factory analysis
                    if (typeof wsTraceHandler !== 'undefined' && wsTraceHandler.sendDebugOutput) {
                        wsTraceHandler.sendDebugOutput('phase6_fallback_report', JSON.stringify(fallbackReport, null, 2));
                    }
                    
                    logger.d( `FALLBACK REPORT: Generated detailed report with ${fallbackReport.unresolved_operations.length} unresolved operations`);
                }
                
                return deletionPlacedDOM;
            }

            // Helper: Create deletion badge with guard attributes
            createDeletionBadge(dfkEntry, dedupeKey) {
                const deletionBlock = document.createElement('span');
                
                // Inline tags set for proper semantic styling distinction
                const inlineTags = new Set([
                    'A', 'ABBR', 'ACRONYM', 'B', 'BDI', 'BDO', 'BIG', 'BUTTON', 'CITE', 'CODE',
                    'DFN', 'EM', 'I', 'INPUT', 'KBD', 'LABEL', 'MAP', 'MARK', 'METER', 'NOSCRIPT',
                    'OBJECT', 'OUTPUT', 'PROGRESS', 'Q', 'RUBY', 'S', 'SAMP', 'SCRIPT', 'SELECT',
                    'SMALL', 'SPAN', 'STRONG', 'SUB', 'SUP', 'TEXTAREA', 'TIME', 'TT', 'U', 'VAR'
                ]);
                
                // Conditional styling based on DFK metadata (kind and tag)
                const isInline = dfkEntry.kind === '#text' || inlineTags.has(dfkEntry.tag);
                if (isInline) {
                    deletionBlock.classList.add('gad-inline-removal');
                } else {
                    deletionBlock.classList.add('gad-block-removal');
                }
                
                // Guard attributes for single-insert invariant
                deletionBlock.setAttribute('data-gad-placed', '1');
                deletionBlock.setAttribute('data-gad-key', dedupeKey);
                
                // Content truncation: 80 chars, strip DELETED prefix (already applied in earlier fix)
                const DELETION_CONTENT_LIMIT = 80;
                const rawContent = dfkEntry.textContent || 'content';
                const displayContent = rawContent.length > DELETION_CONTENT_LIMIT 
                    ? rawContent.substring(0, DELETION_CONTENT_LIMIT) + '\u2026'
                    : rawContent;
                deletionBlock.textContent = displayContent;
                
                // Return both element and type for telemetry tracking
                return { element: deletionBlock, isInline: isInline };
            }

            // Helper: Insert deletion badge based on anchor policy
            insertDeletionBadge(anchor, deletionBlock) {
                try {
                    if (anchor.nodeType === Node.TEXT_NODE || this.isInlineElement(anchor)) {
                        // Inline element or text node: insert after to keep in flow
                        if (anchor.parentNode) {
                            anchor.parentNode.insertBefore(deletionBlock, anchor.nextSibling);
                            return true;
                        }
                    } else {
                        // Block fallback: insert as firstChild inside block, never as nextSibling
                        if (anchor.firstChild) {
                            anchor.insertBefore(deletionBlock, anchor.firstChild);
                        } else {
                            anchor.appendChild(deletionBlock);
                        }
                        return true;
                    }
                } catch (error) {
                    logger.e( `Failed to insert badge: ${error.message}`);
                }
                return false;
            }

            // Helper: Create unplaced deletion badge for content without payload hash matches
            // Policy: Unplaced deletions get neutral badge at anchor root with clear visual marker
            createUnplacedDeletionBadge(appliedOp, anchor) {
                const unplacedBadge = document.createElement('span');
                unplacedBadge.className = 'gad-unplaced-deletion';
                unplacedBadge.style.cssText = 'background: #ffdddd; border: 1px dashed #cc0000; padding: 2px 4px; margin: 0 2px; font-style: italic;';
                
                // Use captured content if available, otherwise indicate unknown deletion
                const content = appliedOp.capturedContent || '[Unknown deletion]';
                const displayContent = content.length > 40 
                    ? content.substring(0, 40) + '\u2026'
                    : content;
                    
                unplacedBadge.textContent = `⚠ ${displayContent}`;
                unplacedBadge.title = `Unplaced deletion: No payload hash match found. Original: ${content}`;
                
                // Insert at anchor root to maintain document flow
                try {
                    if (anchor.firstChild) {
                        anchor.insertBefore(unplacedBadge, anchor.firstChild);
                    } else {
                        anchor.appendChild(unplacedBadge);
                    }
                    return true;
                } catch (error) {
                    logger.e( `Failed to insert unplaced deletion badge: ${error.message}`);
                    return false;
                }
            }

            // Helper: Update deletion telemetry in status ribbon and console
            updateDeletionTelemetry(appliedDeletions, createdBadges, connectedBadges, hasMismatch) {
                // Console telemetry
                console.log(`[DELETION-TELEMETRY] applied_deletions=${appliedDeletions}, created_badges=${createdBadges}, connected_badges=${connectedBadges}`);
                
                // Status ribbon update
                const statusSection = document.getElementById('statusSection');
                if (statusSection && hasMismatch) {
                    statusSection.style.display = 'block';
                    statusSection.innerHTML = `
                        <strong>Deletion Telemetry:</strong> 
                        Applied: ${appliedDeletions}, Created: ${createdBadges}, Connected: ${connectedBadges}
                        ${hasMismatch ? '<span style="color: red;">[MISMATCH DETECTED]</span>' : ''}
                    `;
                } else if (statusSection) {
                    // Clear status if no mismatch
                    statusSection.style.display = 'none';
                }
            }
            
            // Helper: Initialize coalescing telemetry counters
            initializeCoalescingTelemetry() {
                this.coalescingTelemetry = {
                    anchor_wrapper_needed: 0,
                    interactive_wrapper_needed: 0,
                    nested_interactive_wrapper_needed: 0,
                    elements_merged: 0,
                    coalescing_skipped: 0,
                    anchor_merge_prevented: 0,
                    elements_processed: 0
                };
            }
            
            // Helper: Update coalescing telemetry counters
            updateCoalescingTelemetry(metric, count = 1) {
                if (!this.coalescingTelemetry) {
                    this.initializeCoalescingTelemetry();
                }
                this.coalescingTelemetry[metric] += count;
                this.coalescingTelemetry.elements_processed += count;
            }
            
            // Helper: Report final coalescing telemetry
            reportCoalescingTelemetry(totalRuns) {
                if (!this.coalescingTelemetry) return;
                
                const t = this.coalescingTelemetry;
                console.log(`[COALESCING-TELEMETRY] total_runs=${totalRuns}, elements_processed=${t.elements_processed}, elements_merged=${t.elements_merged}, anchor_wrapper_needed=${t.anchor_wrapper_needed}, interactive_wrapper_needed=${t.interactive_wrapper_needed}, nested_interactive_wrapper_needed=${t.nested_interactive_wrapper_needed}, coalescing_skipped=${t.coalescing_skipped}, anchor_merge_prevented=${t.anchor_merge_prevented}`);
                
                // Log key metrics for anchor protection
                if (t.anchor_wrapper_needed > 0 || t.anchor_merge_prevented > 0) {
                    logger.i(`ANCHOR-PROTECTION: ${t.anchor_wrapper_needed} anchor groups processed with wrapper-only approach, ${t.anchor_merge_prevented} anchor merge attempts prevented`);
                }
            }
            
            findStableSemanticAnchor(toDOM, route) {
                // Find the best available block anchor
                let blockAnchor = toDOM;
                const maxRouteDepth = Math.min(route.length, 4);
                
                for (let depth = maxRouteDepth; depth >= 0; depth--) {
                    const partialRoute = route.slice(0, depth);
                    const candidate = this.findElementByRoute(toDOM, partialRoute);
                    if (candidate && candidate.nodeType === Node.ELEMENT_NODE) {
                        blockAnchor = candidate;
                        break;
                    }
                }
                
                // Route-guided inline refinement: use last valid route segment as inline child index bias
                const lastRouteIndex = route.length > 0 ? route[route.length - 1] : 0;
                
                // Try to refine to inline child within the block anchor
                if (blockAnchor.childNodes && blockAnchor.childNodes.length > 0) {
                    // Look for inline children, biased by route index
                    const inlineChildren = Array.from(blockAnchor.childNodes).filter(child => 
                        child.nodeType === Node.TEXT_NODE || 
                        (child.nodeType === Node.ELEMENT_NODE && this.isInlineElement(child))
                    );
                    
                    if (inlineChildren.length > 0) {
                        // Route index safety: clamp to valid range
                        const targetIndex = this.clamp(lastRouteIndex, 0, inlineChildren.length - 1);
                        return inlineChildren[targetIndex];
                    }
                }
                
                // Fallback to block element
                return blockAnchor;
            }
            
            // Semantic-anchor bounded DFK fallback for shifted routes with strict payload identity matching
            //
            // Policy: Prevent deletion mis-association by requiring payload hash equality before proximity-based selection
            // 
            // Matching Strategy:
            // 1. Filter by kind and tag (existing behavior)
            // 2. STRICT PAYLOAD IDENTITY: Require exact payload hash match
            // 3. Use route distance only as tiebreaker among hash-matched candidates
            // 4. Create unplaced deletion marker when no hash match exists
            //
            // Unplaced Deletion Policy:
            // - When no payload hash matches exist within semantic anchor
            // - Place neutral warning badge at anchor root with clear visual marker
            // - Prevents cross-anchor fallback and content mis-association
            // - Maintains document integrity while indicating missing content
            async findDFKWithinAnchor(toDOM, route, appliedOp, deletionFactTable) {
                logger.d( `DFK-FALLBACK: Searching for semantic-bounded match for route [${route.join(',')}]`);
                
                // Find the semantic anchor that should contain this deletion
                const anchor = this.findStableSemanticAnchor(toDOM, route);
                if (!anchor) {
                    logger.d( `DFK-FALLBACK: No semantic anchor found for route [${route.join(',')}]`);
                    return null;
                }
                
                logger.d( `DFK-FALLBACK: Using semantic anchor ${anchor.tagName || '#text'} for bounded search`);
                
                // Extract matching criteria from the applied operation
                const targetKind = appliedOp.kind || '#element';
                const targetTag = appliedOp.tag || 'UNKNOWN';
                
                // Compute target payload hash for strict identity matching
                let targetPayloadHash = null;
                if (appliedOp.capturedContent) {
                    // Create a temporary element to normalize the captured content
                    if (appliedOp.capturedType === 'element') {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = appliedOp.capturedContent;
                        const tempElement = tempDiv.firstElementChild;
                        if (tempElement) {
                            const normalizedPayload = this.normalizePayload(tempElement);
                            targetPayloadHash = await this.strongHash(normalizedPayload);
                        }
                    } else {
                        // Text content - create text node for normalization
                        const tempTextNode = document.createTextNode(appliedOp.capturedContent);
                        const normalizedPayload = this.normalizePayload(tempTextNode);
                        targetPayloadHash = await this.strongHash(normalizedPayload);
                    }
                }
                
                // Search within the anchor's subtree for matching (kind, tag, payloadHash)
                const candidateKeys = Object.keys(deletionFactTable).filter(dfkKey => {
                    const dfkEntry = deletionFactTable[dfkKey];
                    
                    // Must match kind and tag exactly
                    if (dfkEntry.kind !== targetKind || dfkEntry.tag !== targetTag) {
                        return false;
                    }
                    
                    // STRICT PAYLOAD IDENTITY: Must match payload hash exactly
                    if (targetPayloadHash) {
                        const dfkPayloadHash = dfkKey.split('|').pop(); // Extract hash from dfk key
                        if (dfkPayloadHash !== targetPayloadHash) {
                            return false;
                        }
                    }
                    
                    // Verify the DFK route would place element within this anchor's subtree
                    const dfkRoute = dfkEntry.route;
                    const dfkAnchor = this.findStableSemanticAnchor(toDOM, dfkRoute);
                    
                    // Must resolve to the same semantic anchor (bounded containment)
                    return dfkAnchor === anchor;
                });
                
                if (candidateKeys.length === 0) {
                    logger.d( `DFK-FALLBACK: No payload hash matches found within semantic anchor`);
                    return { type: 'unplaced', reason: 'no_hash_match', anchor: anchor };
                }
                
                if (candidateKeys.length === 1) {
                    logger.d( `DFK-FALLBACK: Found exact hash match within semantic anchor: ${candidateKeys[0].substring(0, 60)}...`);
                    return { type: 'exact_match', dfkKey: candidateKeys[0] };
                }
                
                // Multiple hash-matched candidates - use route proximity as tiebreaker
                logger.d( `DFK-FALLBACK: Found ${candidateKeys.length} hash-matched candidates, using route proximity tiebreaker`);
                
                let bestKey = candidateKeys[0];
                let bestDistance = Infinity;
                
                for (const candidateKey of candidateKeys) {
                    const candidateRoute = deletionFactTable[candidateKey].route;
                    const distance = this.calculateRouteDistance(route, candidateRoute);
                    
                    if (distance < bestDistance) {
                        bestDistance = distance;
                        bestKey = candidateKey;
                    }
                }
                
                logger.d( `DFK-FALLBACK: Tie-broken by route distance ${bestDistance}: ${bestKey.substring(0, 60)}...`);
                return { type: 'tie_broken', dfkKey: bestKey, distance: bestDistance };
            }
            
            // Helper: Calculate route distance for fallback proximity heuristic
            calculateRouteDistance(route1, route2) {
                const maxLength = Math.max(route1.length, route2.length);
                let distance = Math.abs(route1.length - route2.length);
                
                for (let i = 0; i < Math.min(route1.length, route2.length); i++) {
                    if (route1[i] !== route2[i]) {
                        distance += Math.abs(route1[i] - route2[i]);
                    }
                }
                
                return distance;
            }
            
            // REMOVED: placeSingleDeletionBlock - replaced by createDeletionBadge + insertDeletionBadge

            // Phase 8: Serialize Final Output
            serializeFinalOutput(coalescedDOM) {
                logger.d( 'Generating final styled diff HTML ready for display');
                
                // Final validation and cleanup
                const finalHTML = coalescedDOM.innerHTML;
                
                // Validate output integrity
                const parser = new DOMParser();
                const testDoc = parser.parseFromString(finalHTML, 'text/html');
                if (testDoc.querySelector('parsererror')) {
                    logger.e( 'Final HTML contains parser errors');
                } else {
                    logger.d( 'Final HTML validated successfully');
                }
                
                return finalHTML;
            }




            showStatusMessage(message) {
                this.elements.statusSection.textContent = message;
                this.elements.statusSection.style.display = 'block';
            }

            hideStatusMessage() {
                this.elements.statusSection.style.display = 'none';
            }

            showCommitPopover(event, railRow) {
                const value = railRow.dataset.value;
                const commit = this.resolveCommit(value);
                if (!commit) return;

                // Position popover in upper-left of render pane (GADS compliant)
                this.positionPopoverInRenderPane();

                // Update popover content
                this.updateCommitPopoverContent(value, commit);

                // Show the popover
                this.elements.commitPopover.style.display = 'block';
            }

            updateCommitPopoverContent(value, commit) {
                // Determine status for GADMRC memo compliance
                const isHead = value === 'H';
                const isUnchanged = commit && this.manifest.commits.length > 1 &&
                    this.manifest.commits.some((c, i) => 
                        i > 0 && c.hash === commit.hash && 
                        c.html_sha256 === this.manifest.commits[i-1].html_sha256
                    );
                
                const status = isHead ? "HEAD" : (isUnchanged ? "No substantive change" : "Changed");

                this.elements.commitPopoverContent.innerHTML = `
                    <div class="popover-field">
                        <div class="popover-label">Position:</div>
                        <div class="popover-value">${value}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Hash:</div>
                        <div class="popover-value">${commit.hash}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Date:</div>
                        <div class="popover-value">${new Date(commit.timestamp ? 
                            commit.timestamp.replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, '$1-$2-$3T$4:$5:$6Z')
                            : commit.date || 'Unknown').toLocaleString()}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Message:</div>
                        <div class="popover-value">${commit.message}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">html_sha256:</div>
                        <div class="popover-value">${commit.html_sha256}</div>
                    </div>
                    <div class="popover-field">
                        <div class="popover-label">Status:</div>
                        <div class="popover-value">${status}</div>
                    </div>
                `;
            }

            hideCommitPopover() {
                this.elements.commitPopover.style.display = 'none';
            }

            positionPopoverInRenderPane() {
                // Position in upper-left of render pane as per GADS specification
                const renderPaneRect = this.elements.renderedPane.getBoundingClientRect();
                const popover = this.elements.commitPopover;

                popover.style.left = (renderPaneRect.left + 20) + 'px';
                popover.style.top = (renderPaneRect.top + 20) + 'px';
            }


        }

        // Initialize inspector when DOM and diff-dom are ready (GADS compliant initialization)
        let domReady = false;
        let diffDomReady = false;

        function checkInitialization() {
            if (domReady && diffDomReady) {
                console.log('[DEBUG] DOM and diff-dom ready, initializing inspector');
                console.log('[DEBUG]', `diff-dom available: ${typeof window.diffDom !== 'undefined'}`);
                if (typeof window.diffDom !== 'undefined') {
                    console.log('[DEBUG] diff-dom ESM loaded successfully');
                }
                window.gadInspector = new GadInspector();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log('[DEBUG] DOM loaded, waiting for diff-dom ESM');
            domReady = true;
            checkInitialization();
        });

        window.addEventListener('diff-dom-ready', () => {
            console.log('[DEBUG] diff-dom ESM ready');
            diffDomReady = true;
            checkInitialization();
        });
    </script>
</body>
</html>
