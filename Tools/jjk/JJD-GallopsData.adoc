= Job Jockey Gallops Data Model
:doctype: book

// tag::mapping-section[]
//
// Category declarations:
// jjdt_:  Types (scalar value types with validation rules)
// jjdgr_: Gallops record
// jjdgm_: Gallops members
// jjdhr_: Heat record
// jjdhm_: Heat members
// jjdhe_: Heat enum values (status)
// jjdpr_: Pace record
// jjdpm_: Pace members
// jjdkr_: Tack record
// jjdkm_: Tack members
// jjdpe_: Tack state enum values
// jjdo_:  Operations
// jjds_:  Section headers (operation documentation structure)
// jjdz_:  Serialization concerns
//
// Variant patterns:
//   _s: plural form
//   _p: possessive form
//

// Types
:jjdt_coronet:    <<jjdt_coronet,Coronet>>
:jjdt_coronet_p:  <<jjdt_coronet,Coronet's>>
:jjdt_coronet_s:  <<jjdt_coronet,Coronets>>
:jjdt_firemark:   <<jjdt_firemark,Firemark>>
:jjdt_firemark_p: <<jjdt_firemark,Firemark's>>
:jjdt_firemark_s: <<jjdt_firemark,Firemarks>>
:jjdt_silks:      <<jjdt_silks,Silks>>

// Gallops record and members
:jjdgm_seed:        <<jjdgm_seed,next_heat_seed>>
:jjdgr_gallops:     <<jjdgr_gallops,Gallops>>
:jjdgr_gallops_p:   <<jjdgr_gallops,Gallops'>>

// Heat record and members
:jjdhe_current:   <<jjdhe_current,current>>
:jjdhe_retired:   <<jjdhe_retired,retired>>
:jjdhm_created:   <<jjdhm_created,creation_time>>
:jjdhm_firemark:  <<jjdhm_firemark,firemark>>
:jjdhm_order:     <<jjdhm_order,order>>
:jjdhm_paddock:   <<jjdhm_paddock,paddock_file>>
:jjdhm_seed:      <<jjdhm_seed,next_pace_seed>>
:jjdhm_silks:     <<jjdhm_silks,silks>>
:jjdhm_status:    <<jjdhm_status,status>>
:jjdhr_heat:      <<jjdhr_heat,Heat>>
:jjdhr_heat_p:    <<jjdhr_heat,Heat's>>
:jjdhr_heat_s:    <<jjdhr_heat,Heats>>

// Pace record and members
:jjdpm_coronet:   <<jjdpm_coronet,coronet>>
:jjdpm_silks:     <<jjdpm_silks,silks>>
:jjdpr_pace:      <<jjdpr_pace,Pace>>
:jjdpr_pace_p:    <<jjdpr_pace,Pace's>>
:jjdpr_pace_s:    <<jjdpr_pace,Paces>>

// Pace/Tack state enum values (used in Tack)
:jjdpe_abandoned: <<jjdpe_abandoned,abandoned>>
:jjdpe_complete:  <<jjdpe_complete,complete>>
:jjdpe_bridled:   <<jjdpe_bridled,bridled>>
:jjdpe_rough:     <<jjdpe_rough,rough>>

// Tack record and members
:jjdkm_direction: <<jjdkm_direction,direction>>
:jjdkm_refined:   <<jjdkm_refined,ts>>
:jjdkm_state:     <<jjdkm_state,state>>
:jjdkm_text:      <<jjdkm_text,text>>
:jjdkr_tack:      <<jjdkr_tack,Tack>>
:jjdkr_tack_p:    <<jjdkr_tack,Tack's>>
:jjdkr_tack_s:    <<jjdkr_tack,Tacks>>

// Arguments
:jjda_after:          <<jjda_after,--after>>
:jjda_before:         <<jjda_before,--before>>
:jjda_created:        <<jjda_created,--created>>
:jjda_direction:      <<jjda_direction,--direction>>
:jjda_file:           <<jjda_file,--file>>
:jjda_first:          <<jjda_first,--first>>
:jjda_last:           <<jjda_last,--last>>
:jjda_move:           <<jjda_move,--move>>
:jjda_pace:           <<jjda_pace,--pace>>
:jjda_silks:          <<jjda_silks,--silks>>
:jjda_state:          <<jjda_state,--state>>
:jjda_status:         <<jjda_status,--status>>
:jjda_to:             <<jjda_to,--to>>

// CLI executor
:jjdx_vvx:   <<jjdx_vvx,vvx>>
:jjdx_cli:   <<jjdx_cli,jjx>>

// Operations
:jjdo_canter:         <<jjdo_canter,jjx_canter>>
:jjdo_chalk:          <<jjdo_chalk,jjx_chalk>>
:jjdo_draft:          <<jjdo_draft,jjx_draft>>
:jjdo_muster:         <<jjdo_muster,jjx_muster>>
:jjdo_nominate:       <<jjdo_nominate,jjx_nominate>>
:jjdo_notch:          <<jjdo_notch,jjx_notch>>
:jjdo_rail:           <<jjdo_rail,jjx_rail>>
:jjdo_rein:           <<jjdo_rein,jjx_rein>>
:jjdo_retire:         <<jjdo_retire,jjx_retire>>
:jjdo_saddle:         <<jjdo_saddle,jjx_saddle>>
:jjdo_slate:          <<jjdo_slate,jjx_slate>>
:jjdo_tally:          <<jjdo_tally,jjx_tally>>
:jjdo_validate:       <<jjdo_validate,jjx_validate>>

// Section headers
:jjds_arguments:        <<jjds_arguments,Arguments:>>
:jjds_behavior:         <<jjds_behavior,Behavior:>>
:jjds_exit_enumerated:  <<jjds_exit_enumerated,Exit Status:>>
:jjds_exit_uniform:     <<jjds_exit_uniform,Exit Status:>>
:jjds_stdout:           <<jjds_stdout,Stdout:>>

// Serialization
:jjdz_charset:  <<jjdz_charset,Charset>>
:jjdz_encoding: <<jjdz_encoding,Identity Encoding>>

// end::mapping-section[]

== Overview

The
{jjdgr_gallops}
is the persistent data store for Job Jockey.
It tracks
{jjdhr_heat_s}
(bounded initiatives) and their constituent
{jjdpr_pace_s}
(discrete actions).
Each
{jjdpr_pace}
maintains a history of
{jjdkr_tack_s}
(plan refinements).

== Design Principles

=== Exclusive JSON Ownership

All access to the
{jjdgr_gallops}
goes through {jjdx_cli}, the Job Jockey subcommand of the Voce Viva executor.
No jq or direct JSON manipulation ever touches this data.
This is an absolute architectural constraint, not a preference.

The rationale: writing reliable bash with jq pipelines requires fighting LLM training data.
The internet is full of bad bash.
Rust replaces fragile jq invocations with compiler-enforced correctness.
The compiler is tireless; humans are not.

=== Git as Journal

The
{jjdgr_gallops}
remains JSON specifically so git can serve as the journalling layer.
Every mutation creates a diffable commit.
Git owns the complete history; we need not implement our own audit trail.

The
{jjdkr_tack}
history within each
{jjdpr_pace}
exists for convenient postmortem analysis.
Git has the full history, but
{jjdkr_tack_s}
let us see plan evolution without spelunking commits.

=== Diff-Friendly Mutations

New
{jjdkr_tack_s}
prepend to position 0 rather than append.
This produces cleaner git diffs: prepending adds a line with trailing comma, while appending would modify the previous last line to add a comma.
Small discipline, large cumulative benefit.

The
{jjdhm_order}
array contains full
{jjdt_coronet_s}.
Each
{jjdt_coronet}
embeds its parent
{jjdt_firemark}
(redundant within a single
{jjdhr_heat}).
This redundancy is cheap and enables grep, copy-paste, and self-documenting JSON.

=== Crash-Safe Architecture

Bash handles locking via `git update-ref`.
{jjdx_cli} owns all
{jjdgr_gallops}
file access - reading, transforming, and writing.
{jjdx_cli} implements atomic writes internally (write to temp file, then rename).
If {jjdx_cli} crashes mid-transform, no partial writes occur.

The pattern:
[source,bash]
----
lock_acquire
vvx jjx gallops nominate --file gallops.json "my-heat" "260111" || { lock_release; die; }
lock_release
----

This keeps bash simple (just locking and invocation) while {jjdx_cli} owns all JSON file operations.

=== Deterministic Serialization

Implementations MUST serialize JSON object keys in deterministic order to minimize diff churn.
For `heats` and `paces` objects, use sorted key order (e.g., Rust `BTreeMap` instead of `HashMap`).
This ensures that reordering paces via
{jjdo_rail}
produces minimal diffs — only the `order` array changes, not the entire `paces` object.

=== Identity Encoding

{jjdt_firemark}
(`₣` prefix) and
{jjdt_coronet}
(`₢` prefix) are the canonical identities used in JSON keys, CLI arguments, and display.
The base64 encoding provides compact, URL-safe, shell-safe strings.
Internally, Rust may decode to integers for arithmetic, but the string form is authoritative.

=== Horse Racing Vocabulary

Job Jockey uses horse racing metaphors throughout.
This is intentional: vivid domain vocabulary helps humans hold complex systems in working memory.

* {jjdhr_heat} - a bounded initiative (like a race)
* {jjdpr_pace} - a discrete action (the rhythm of the race)
* {jjdkr_tack} - plan refinement (equipment; also "tacking" = adjusting course)
* {jjdt_firemark} - heat identity, `₣`-prefixed (hot-iron brand marking ownership)
* {jjdt_coronet} - pace identity, `₢`-prefixed (marking at the hoof line)
* {jjdt_silks} - display name (jockey's colors)
* {jjdgr_gallops} - the training grounds (where real work happens before race day)

== Types

[[jjdt_firemark]]
// ⟦axl_voices axt_string⟧
{jjdt_firemark}::
The identity of a
{jjdhr_heat}.
Format: `₣` + 2 base64 characters (e.g., `₣AB`).
The 2 base64 characters encode an integer 0-4095 (2^12).
Used as JSON keys and in CLI arguments.
Input may omit the `₣` prefix; output always includes it.

[[jjdt_coronet]]
// ⟦axl_voices axt_string⟧
{jjdt_coronet}::
The identity of a
{jjdpr_pace}.
Format: `₢` + 5 base64 characters (e.g., `₢ABCDE`).
Globally unique: the first 2 base64 characters are the parent
{jjdhr_heat_p}
encoded identity; the remaining 3 encode the pace index (0-262143, 2^18).
Used as JSON keys and in CLI arguments.
Input may omit the `₢` prefix; output always includes it.
+
*Reassignment:* When a
{jjdpr_pace}
is moved between
{jjdhr_heat_s}
via
{jjdo_draft},
the old
{jjdt_coronet}
becomes invalid and a new one is assigned using the destination
{jjdhr_heat_p}
{jjdhm_seed}.
The new
{jjdt_coronet}
embeds the destination
{jjdt_firemark}.
{jjdkr_tack}
history is preserved, with a note recording the original
{jjdt_coronet}.

[[jjdt_silks]]
// ⟦axl_voices axt_string⟧
{jjdt_silks}::
A kebab-case display name.
Used for human-readable identification of
{jjdhr_heat_s}
and
{jjdpr_pace_s}.
Pattern: `[a-z0-9]+(-[a-z0-9]+)*`

== Records

=== {jjdgr_gallops}

[[jjdgr_gallops]]
// ⟦axl_voices axr_record_json⟧
{jjdgr_gallops}::
The root JSON structure containing all Job Jockey data.
Singleton record persisted at `.claude/jjm/jjg_gallops.json`.

==== Members

* [[jjdgm_seed]]
// ⟦axl_voices axr_member axd_required⟧
{jjdgm_seed}
is the next
{jjdt_firemark}
to allocate, stored as 2 base64 characters.
Incremented by
{jjdo_nominate}.

=== {jjdhr_heat}

[[jjdhr_heat]]
// ⟦axl_voices axr_record_json⟧
{jjdhr_heat}::
A bounded initiative with coherent goals.
Contains zero or more
{jjdpr_pace_s}
representing discrete actions.
Keyed in JSON by
{jjdt_firemark}.

==== Members

* [[jjdhm_firemark]]
// ⟦axl_voices axr_member axd_required⟧
{jjdhm_firemark}
is the
{jjdhr_heat_p}
primary key.
Type:
{jjdt_firemark}.
Implicit from JSON key; not stored as separate field.

* [[jjdhm_silks]]
// ⟦axl_voices axr_member axd_required⟧
{jjdhm_silks}
is the
{jjdhr_heat_p}
display name.
Type:
{jjdt_silks}.

* [[jjdhm_created]]
// ⟦axl_voices axr_member axd_required⟧
{jjdhm_created}
records when the
{jjdhr_heat}
was nominated.
Format: YYMMDD.

* [[jjdhm_status]]
// ⟦axl_voices axr_member axd_required⟧
{jjdhm_status}
indicates the
{jjdhr_heat_p}
lifecycle state.
Values:
{jjdhe_current}
or
{jjdhe_retired}.

* [[jjdhm_order]]
// ⟦axl_voices axr_member axd_required axd_repeated⟧
{jjdhm_order}
lists
{jjdt_coronet_s}
in execution sequence.
May be reordered via
{jjdo_rail}.

* [[jjdhm_seed]]
// ⟦axl_voices axr_member axd_required⟧
{jjdhm_seed}
is the next
{jjdt_coronet}
index to allocate, stored as 3 base64 characters.
Incremented by
{jjdo_slate}.

* [[jjdhm_paddock]]
// ⟦axl_voices axr_member axd_required⟧
{jjdhm_paddock}
is the path to the paddock file containing
{jjdhr_heat}
context and background.
Format: `.claude/jjm/jjp_XX.md` where XX is the base64-encoded
{jjdt_firemark}
(without `₣` prefix).
Created by
{jjdo_nominate}.

==== Status Values

[[jjdhe_current]]
// ⟦axl_voices axt_enum_value⟧
{jjdhe_current}::
The
{jjdhr_heat}
is active and accepting work.

[[jjdhe_retired]]
// ⟦axl_voices axt_enum_value⟧
{jjdhe_retired}::
The
{jjdhr_heat}
is complete and archived.

=== {jjdpr_pace}

[[jjdpr_pace]]
// ⟦axl_voices axr_record_json⟧
{jjdpr_pace}::
A discrete action within a
{jjdhr_heat}.
Contains one or more
{jjdkr_tack_s}
representing state snapshots and plan refinements.
Current state is derived from `tacks[0].state`.
Keyed in JSON by
{jjdt_coronet}.

==== Members

* [[jjdpm_coronet]]
// ⟦axl_voices axr_member axd_required⟧
{jjdpm_coronet}
is the
{jjdpr_pace_p}
globally unique identity.
Type:
{jjdt_coronet}.
Implicit from JSON key; not stored as separate field.

* [[jjdpm_silks]]
// ⟦axl_voices axr_member axd_required⟧
{jjdpm_silks}
is the
{jjdpr_pace_p}
display name.
Type:
{jjdt_silks}.

=== {jjdkr_tack}

[[jjdkr_tack]]
// ⟦axl_voices axr_record_json⟧
{jjdkr_tack}::
A snapshot of
{jjdpr_pace}
state and plan at a point in time.
{jjdkr_tack_s}
form an append-only history capturing both plan refinements and state transitions.
Position 0 is the most recent; older
{jjdkr_tack_s}
follow.
New
{jjdkr_tack_s}
are prepended for cleaner git diffs.
The current
{jjdpr_pace}
state is always
`tacks[0].state`.

==== Members

* [[jjdkm_refined]]
// ⟦axl_voices axr_member axd_required⟧
{jjdkm_refined}
records when this
{jjdkr_tack}
was added.
Format: YYMMDD-HHMM.

* [[jjdkm_state]]
// ⟦axl_voices axr_member axd_required⟧
{jjdkm_state}
indicates the
{jjdpr_pace_p}
progress at this snapshot.
Values:
{jjdpe_rough},
{jjdpe_bridled},
{jjdpe_complete},
or
{jjdpe_abandoned}.

* [[jjdkm_text]]
// ⟦axl_voices axr_member axd_required⟧
{jjdkm_text}
contains the plan specification.
Non-empty string describing what the
{jjdpr_pace}
should accomplish.

* [[jjdkm_direction]]
// ⟦axl_voices axr_member axd_conditional⟧
{jjdkm_direction}
contains execution guidance for autonomous operation.
Required when
{jjdkm_state}
is
{jjdpe_bridled};
forbidden otherwise.
Describes which agent to dispatch, parallelism strategy, or other execution parameters.

==== State Values

[[jjdpe_rough]]
// ⟦axl_voices axt_enum_value⟧
{jjdpe_rough}::
The
{jjdpr_pace}
needs clarification before work can proceed.
When context is assembled for a
{jjdpe_rough}
pace, the model is guided to refine the specification rather than begin execution.

[[jjdpe_bridled]]
// ⟦axl_voices axt_enum_value⟧
{jjdpe_bridled}::
The
{jjdpr_pace}
is ready for autonomous execution.
The
{jjdkm_direction}
field contains explicit guidance for the executing agent.
When context is assembled for a
{jjdpe_bridled}
pace, the model proceeds without human confirmation.

[[jjdpe_complete]]
// ⟦axl_voices axt_enum_value⟧
{jjdpe_complete}::
The
{jjdpr_pace}
has been successfully finished.

[[jjdpe_abandoned]]
// ⟦axl_voices axt_enum_value⟧
{jjdpe_abandoned}::
The
{jjdpr_pace}
was stopped without completion.

== Serialization

[[jjdz_charset]]
{jjdz_charset}::
The 64-character alphabet for identity encoding.
Uses URL-safe base64 (RFC 4648 §5):
`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_`
Position in charset determines numeric value (A=0, B=1, ..., `-`=62, `_`=63).
This alphabet is safe for JSON keys, URLs, shell, git refs, and filenames.
Matches Rust `base64::engine::general_purpose::URL_SAFE_NO_PAD`.

[[jjdz_encoding]]
{jjdz_encoding}::
The algorithm for encoding
{jjdt_firemark}
and
{jjdt_coronet}
values.
+
*{jjdt_firemark} (Heat identity):*
+
. Format: `₣` + 2 base64 characters
. Given integer H (0-4095): encode as `₣` + `charset[H/64]` + `charset[H%64]`
. To decode `₣XY`: H = pos(X) * 64 + pos(Y)
+
*{jjdt_coronet} (Pace identity):*
+
. Format: `₢` + 5 base64 characters
. First 2 characters encode the parent Heat (same as {jjdt_firemark} without prefix)
. Last 3 characters encode the pace index P (0-262143)
. Given Heat H and pace index P: encode as `₢` + `charset[H/64]` + `charset[H%64]` + `charset[P/4096]` + `charset[(P/64)%64]` + `charset[P%64]`
. To decode `₢XYZAB`: H from XY, P = pos(Z) * 4096 + pos(A) * 64 + pos(B)
+
*Input flexibility:*
+
CLI commands accept identities with or without prefix.
Length determines type: 2 base64 chars = {jjdt_firemark}, 5 base64 chars = {jjdt_coronet}.
Output always includes the prefix (`₣` or `₢`).

== Arguments

*Note:* {jjda_file} appears as the first argument on all operations.
It is annotated `// ⟦axd_optional axd_defaulted⟧` and uses the default value when not explicitly provided.

[[jjda_file]]
// ⟦axl_voices axa_cli_option⟧
{jjda_file}::
Path to the
{jjdgr_gallops}
JSON file.
Long: `--file`.
Short: none.
Default: `.claude/jjm/jjg_gallops.json`.

[[jjda_silks]]
// ⟦axl_voices axa_cli_option⟧
{jjda_silks}::
Kebab-case display name for the target entity.
Long: `--silks`.
Short: `-s`.

[[jjda_state]]
// ⟦axl_voices axa_cli_option⟧
{jjda_state}::
Target state for the
{jjdkr_tack}.
Long: `--state`.
Short: none.
Values:
{jjdpe_rough},
{jjdpe_bridled},
{jjdpe_complete},
{jjdpe_abandoned}.

[[jjda_direction]]
// ⟦axl_voices axa_cli_option⟧
{jjda_direction}::
Execution guidance for autonomous operation.
Long: `--direction`.
Short: `-d`.
Required when
{jjda_state}
is
{jjdpe_bridled};
forbidden otherwise.

[[jjda_pace]]
// ⟦axl_voices axa_cli_option⟧
{jjda_pace}::
Pace silks for context in commit messages.
Long: `--pace`.
Short: `-p`.

[[jjda_created]]
// ⟦axl_voices axa_cli_option⟧
{jjda_created}::
Creation date in YYMMDD format.
Long: `--created`.
Short: `-c`.

[[jjda_before]]
// ⟦axl_voices axa_cli_option⟧
{jjda_before}::
{jjdt_coronet}
to insert before.
Long: `--before`.
Short: none.
Mutually exclusive with
{jjda_after}
and
{jjda_first}.

[[jjda_after]]
// ⟦axl_voices axa_cli_option⟧
{jjda_after}::
{jjdt_coronet}
to insert after.
Long: `--after`.
Short: none.
Mutually exclusive with
{jjda_before}
and
{jjda_first}.

[[jjda_first]]
// ⟦axl_voices axa_cli_flag⟧
{jjda_first}::
Position at beginning of
{jjdhm_order}.
Long: `--first`.
Short: none.
Boolean flag, no value.
Mutually exclusive with
{jjda_before}
and
{jjda_after}.

[[jjda_last]]
// ⟦axl_voices axa_cli_flag⟧
{jjda_last}::
Move to end of
{jjdhm_order}.
Long: `--last`.
Short: none.
Boolean flag, no value.
Used only by
{jjdo_rail}
move mode.
Mutually exclusive with
{jjda_before},
{jjda_after},
and
{jjda_first}.

[[jjda_move]]
// ⟦axl_voices axa_cli_option⟧
{jjda_move}::
{jjdt_coronet}
to relocate within
{jjdhm_order}.
Long: `--move`.
Short: `-m`.
Triggers move mode in
{jjdo_rail}.
Requires exactly one positioning flag:
{jjda_before},
{jjda_after},
{jjda_first},
or
{jjda_last}.

[[jjda_status]]
// ⟦axl_voices axa_cli_option⟧
{jjda_status}::
Filter by
{jjdhr_heat}
status.
Long: `--status`.
Short: none.
Values:
{jjdhe_current},
{jjdhe_retired}.

[[jjda_to]]
// ⟦axl_voices axa_cli_option⟧
{jjda_to}::
Destination
{jjdt_firemark}
for
{jjdo_draft}.
Long: `--to`.
Short: none.

== Section Headers

[[jjds_arguments]]
// ⟦axl_voices axa_argument_list⟧
{jjds_arguments}::
Section header introducing operation arguments.

[[jjds_stdout]]
{jjds_stdout}::
Section header introducing operation standard output.

[[jjds_exit_uniform]]
// ⟦axl_voices axa_exit_uniform⟧
{jjds_exit_uniform}::
Section header for operations with standard exit semantics.

[[jjds_exit_enumerated]]
// ⟦axl_voices axa_exit_enumerated⟧
{jjds_exit_enumerated}::
Section header for operations with distinct exit codes.

[[jjds_behavior]]
{jjds_behavior}::
Section header introducing operation behavior steps.

== CLI

[[jjdx_vvx]]
// ⟦axl_voices axi_cli_program⟧
{jjdx_vvx}::
The Voce Viva executor.
Local reference to the VVK-defined CLI program that hosts Job Jockey.

[[jjdx_cli]]
// ⟦axl_voices axi_cli_command_group⟧
{jjdx_cli}::
The Job Jockey command group within
{jjdx_vvx}.
Invoked as `vvx jjx`.
All operations are subcommands of
{jjdx_cli}.
Inherits Unix CLI semantics: stdout for results, stderr for errors, exit 0 for success, non-zero for failure.

== Commit Message Architecture

All JJ commits include an action code that serves multiple purposes:
- **Parsing steeplechase history**: Distinguishes between different operation types
- **Semantic clarity**: Indicates the nature and context of each commit
- **Consistency**: Applies uniformly across pace-level and heat-level operations

== Operations

Operations are implemented as {jjdx_cli} subcommands.
{jjdx_cli} owns all
{jjdgr_gallops}
file access (read, transform, atomic write).
Bash handles locking via `git update-ref` and invokes {jjdx_cli} with
{jjda_file}.

=== Write Operations

[[jjdo_nominate]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_nominate}

Create a new
{jjdhr_heat}
with empty
{jjdpr_pace}
structure.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjda_silks}

// ⟦axd_required⟧
* {jjda_created}

{jjds_stdout} New
{jjdt_firemark}

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. If
{jjdgr_gallops}
file does not exist:
.. Create parent directory `.claude/jjm/` if needed
.. Initialize new
{jjdgr_gallops}
with
{jjdgm_seed}
`AA` and empty `heats`
. Read
{jjdgr_gallops}
from file (or use newly created)
. Read current
{jjdgm_seed}
as
{jjdt_firemark}
. Compute paddock path: `.claude/jjm/jjp_XX.md` where XX is the 2 base64 chars
. Create paddock file with template:
+
----
# Paddock: {silks}

## Context

(Describe the initiative's background and goals)

## References

(List relevant files, docs, or prior work)
----
. Create new
{jjdhr_heat}
with:
.. Key: `₣` + encoded
{jjdt_firemark}
.. {jjdhm_silks}:
from argument
.. {jjdhm_created}:
from argument
.. {jjdhm_status}:
{jjdhe_current}
.. {jjdhm_order}:
empty array
.. {jjdhm_seed}:
`AAA` (index 0)
.. {jjdhm_paddock}:
computed paddock path
.. `paces`: empty object
. Increment
{jjdgm_seed}
(base64 arithmetic with carry)
. Write transformed
{jjdgr_gallops}
to file (atomic)
. Output new
{jjdt_firemark}
to stdout

[[jjdo_slate]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_slate}

Add a new
{jjdpr_pace}
to a
{jjdhr_heat}.
The initial
{jjdkr_tack}
is created with state
{jjdpe_rough}.

By default, the new
{jjdpr_pace}
is appended to the end of
{jjdhm_order}.
Use positioning flags to insert at a specific location.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjdt_firemark}
(positional) — target
{jjdhr_heat}

// ⟦axd_required⟧
* {jjda_silks}

// ⟦axd_required⟧
* stdin —
{jjdkm_text}
content for the initial
{jjdkr_tack}

// ⟦axd_optional⟧
* {jjda_before}
— insert before specified
{jjdt_coronet}

// ⟦axd_optional⟧
* {jjda_after}
— insert after specified
{jjdt_coronet}

// ⟦axd_optional⟧
* {jjda_first}
— insert at beginning of
{jjdhm_order}

*Positioning:* Only one of
{jjda_before},
{jjda_after},
or
{jjda_first}
may be specified.
If none provided, append to end (default).
Note:
{jjdo_rail}
reorders existing
{jjdpr_pace_s};
{jjdo_slate}
positioning inserts a new
{jjdpr_pace}
at a specific location.

{jjds_stdout} New
{jjdt_coronet}

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Read
{jjdgr_gallops}
from file
. Verify
{jjdhr_heat}
exists with given
{jjdt_firemark}
. If
{jjda_before}
or
{jjda_after}
provided, verify target
{jjdt_coronet}
exists in
{jjdhr_heat}
. Read
{jjdhm_seed}
from target
{jjdhr_heat}
. Construct
{jjdt_coronet}:
`₢` + encoded
{jjdt_firemark}
(2 chars) +
{jjdhm_seed}
(3 chars)
. Create new
{jjdpr_pace}
with:
.. Key: constructed
{jjdt_coronet}
.. {jjdpm_silks}:
from argument
.. `tacks`: array with single
{jjdkr_tack}:
... {jjdkm_refined}:
current timestamp (YYMMDD-HHMM)
... {jjdkm_state}:
{jjdpe_rough}
... {jjdkm_text}:
from stdin
. Insert
{jjdt_coronet}
into
{jjdhm_order}
at determined position:
.. If
{jjda_first}:
prepend to beginning
.. If
{jjda_before}:
insert immediately before target
{jjdt_coronet}
.. If
{jjda_after}:
insert immediately after target
{jjdt_coronet}
.. Otherwise: append to end
. Increment
{jjdhm_seed}
(base64 arithmetic with carry)
. Write transformed
{jjdgr_gallops}
to file (atomic)
. Output new
{jjdt_coronet}
to stdout

[[jjdo_rail]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_rail}

Reorder
{jjdpr_pace_s}
within a
{jjdhr_heat}
by updating
{jjdhm_order}.
Supports two modes: *order mode* replaces the entire sequence; *move mode* relocates a single
{jjdpr_pace}.

*Order mode* (full replacement):
----
vvx jjx_rail <FIREMARK> <CORONET>...
----

*Move mode* (single relocation):
----
vvx jjx_rail <FIREMARK> --move <CORONET> [--before <TARGET> | --after <TARGET> | --first | --last]
----

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjdt_firemark}
(positional) — target
{jjdhr_heat}

*Order mode arguments:*

// ⟦axd_required⟧
* order — array of
{jjdt_coronet_s}
in desired sequence (space-separated positional arguments)

*Move mode arguments:*

// ⟦axd_required⟧
* {jjda_move}
— {jjdt_coronet}
to relocate

// ⟦axd_required⟧
* Exactly one positioning flag:
{jjda_before},
{jjda_after},
{jjda_first},
or
{jjda_last}

*Mode detection:* If
{jjda_move}
is present, move mode; otherwise order mode.

{jjds_stdout} Updated
{jjdhm_order}
array, one
{jjdt_coronet}
per line, in new sequence.

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

*Common steps:*

. Read
{jjdgr_gallops}
from file
. Verify
{jjdhr_heat}
exists with given
{jjdt_firemark}

*Order mode:*

. Parse positional arguments into array of
{jjdt_coronet_s}
. Validate order array:
.. Count must match current
{jjdhm_order}
length
.. No duplicate
{jjdt_coronet_s}
.. All
{jjdt_coronet_s}
must exist in
{jjdhr_heat_p}
`paces` object
.. All
{jjdt_coronet_s}
must embed correct parent
{jjdt_firemark}
. Replace
{jjdhm_order}
with new order array
. Write transformed
{jjdgr_gallops}
to file (atomic)
. Output new
{jjdhm_order},
one
{jjdt_coronet}
per line

*Move mode:*

. Validate
{jjda_move}
{jjdt_coronet}
exists in
{jjdhr_heat}
. Validate exactly one positioning flag provided
. If
{jjda_before}
or
{jjda_after}:
validate target
{jjdt_coronet}
exists and differs from
{jjda_move}
{jjdt_coronet}
. Remove
{jjda_move}
{jjdt_coronet}
from current position in
{jjdhm_order}
. Insert at new position:
.. If
{jjda_first}:
prepend to beginning
.. If
{jjda_last}:
append to end
.. If
{jjda_before}:
insert immediately before target
{jjdt_coronet}
.. If
{jjda_after}:
insert immediately after target
{jjdt_coronet}
. Write transformed
{jjdgr_gallops}
to file (atomic)
. Output new
{jjdhm_order},
one
{jjdt_coronet}
per line

*Validation errors:*

[cols="2,3"]
|===
| Condition | Error

| {jjda_move} with positional coronets
| "Cannot combine --move with positional coronets"

| {jjda_move} {jjdt_coronet} not found
| "Pace {coronet} not found in heat {firemark}"

| No positioning flag provided
| "Move mode requires exactly one positioning flag"

| Multiple positioning flags
| "Conflicting positioning flags: {flags}"

| Target same as move
| "Cannot position pace relative to itself"

| Target {jjdt_coronet} not found
| "Target pace {coronet} not found in heat {firemark}"
|===

[[jjdo_draft]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_draft}

Move a
{jjdpr_pace}
from one
{jjdhr_heat}
to another.
This is a primitive operation: mechanical transfer with no ceremony.
The
{jjdpr_pace}
receives a new
{jjdt_coronet}
in the destination
{jjdhr_heat};
all
{jjdkr_tack}
history is preserved.

*Important:* "Drafted" is not a
{jjdpr_pace}
state.
{jjdpr_pace}
states remain:
{jjdpe_rough},
{jjdpe_bridled},
{jjdpe_complete},
{jjdpe_abandoned}.
Draft is an operation that moves
{jjdpr_pace_s}
between
{jjdhr_heat_s};
state is preserved through the move.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjdt_coronet}
(positional) —
{jjdpr_pace}
to move

// ⟦axd_required⟧
* {jjda_to}
— destination
{jjdt_firemark}

// ⟦axd_optional⟧
* {jjda_before}
— insert before specified
{jjdt_coronet}
in destination

// ⟦axd_optional⟧
* {jjda_after}
— insert after specified
{jjdt_coronet}
in destination

// ⟦axd_optional⟧
* {jjda_first}
— insert at beginning of destination
{jjdhm_order}

*Positioning:* Only one of
{jjda_before},
{jjda_after},
or
{jjda_first}
may be specified.
If none provided, append to end of destination
{jjdhm_order}
(default).

{jjds_stdout} New
{jjdt_coronet}
in destination
{jjdhr_heat}

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Read
{jjdgr_gallops}
from file
. Extract source
{jjdt_firemark}
from
{jjdt_coronet}
(first 2 base64 chars after prefix)
. Verify source
{jjdhr_heat}
exists
. Verify
{jjdpr_pace}
exists in source
{jjdhr_heat}
. Verify destination
{jjdhr_heat}
exists with given
{jjdt_firemark}
. If
{jjda_before}
or
{jjda_after}
provided, verify target
{jjdt_coronet}
exists in destination
{jjdhr_heat}
. Read destination
{jjdhm_seed}
. Construct new
{jjdt_coronet}:
`₢` + destination
{jjdt_firemark}
(2 chars) + destination
{jjdhm_seed}
(3 chars)
. Copy
{jjdpr_pace}
data to destination with new
{jjdt_coronet}:
.. Preserve
{jjdpm_silks}
.. Prepend new
{jjdkr_tack}
recording the draft:
... {jjdkm_refined}:
current timestamp (YYMMDD-HHMM)
... {jjdkm_state}:
inherited from previous `tacks[0].state`
... {jjdkm_text}:
`Drafted from {old_coronet} in {source_firemark}.\n\n` + previous `tacks[0].text`
.. Preserve remaining
{jjdkr_tack}
history
. Insert new
{jjdt_coronet}
into destination
{jjdhm_order}
at determined position
. Increment destination
{jjdhm_seed}
. Remove
{jjdpr_pace}
from source
{jjdhr_heat}:
.. Remove from source `paces` object
.. Remove from source
{jjdhm_order}
. Write transformed
{jjdgr_gallops}
to file (atomic)
. Output new
{jjdt_coronet}
to stdout

*Validation errors:*

[cols="2,3"]
|===
| Condition | Error

| Source and destination same
| "Cannot draft pace to same heat"

| Source {jjdpr_pace} not found
| "Pace {coronet} not found in heat {firemark}"

| Destination {jjdhr_heat} not found
| "Heat {firemark} not found"

| Target {jjdt_coronet} not found in destination
| "Target pace {coronet} not found in heat {firemark}"
|===

[[jjdo_tally]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_tally}

Add a new
{jjdkr_tack}
to a
{jjdpr_pace}.
This is the unified operation for all
{jjdkr_tack}
creation: state transitions, plan refinements, or both.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjdt_coronet}
(positional)

// ⟦axd_optional⟧
* {jjda_state}
— if absent, inherits from previous
{jjdkr_tack}

// ⟦axd_conditional⟧
* {jjda_direction}
— required if
{jjda_state}
is
{jjdpe_bridled};
forbidden if
{jjda_state}
is provided and not
{jjdpe_bridled};
ignored if
{jjda_state}
is absent (inherits with state)

// ⟦axd_optional⟧
* stdin —
{jjdkm_text}
content; if absent, inherits from previous
{jjdkr_tack}

{jjds_stdout} None

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Read
{jjdgr_gallops}
from file
. Extract parent
{jjdt_firemark}
from
{jjdt_coronet}
(first 2 base64 chars after prefix)
. Verify
{jjdhr_heat}
exists
. Verify
{jjdpr_pace}
exists with given
{jjdt_coronet}
. Read current
{jjdkr_tack}
from `tacks[0]`
. Determine new state:
.. If
{jjda_state}
provided: use that value
.. Otherwise: inherit from previous
{jjdkr_tack}
. Determine new direction:
.. If
{jjda_state}
is
{jjdpe_bridled}:
use
{jjda_direction}
argument (required)
.. If
{jjda_state}
is absent and previous state is
{jjdpe_bridled}:
inherit from previous
{jjdkr_tack}
.. Otherwise: omit
{jjdkm_direction}
. Determine new text:
.. If stdin provided: use stdin content
.. Otherwise: inherit from previous
{jjdkr_tack}
. Create new
{jjdkr_tack}
with:
.. {jjdkm_refined}:
current timestamp (YYMMDD-HHMM)
.. {jjdkm_state}:
determined above
.. {jjdkm_text}:
determined above
.. {jjdkm_direction}:
determined above (if applicable)
. Prepend new
{jjdkr_tack}
to `tacks` array (position 0)
. Write transformed
{jjdgr_gallops}
to file (atomic)

[[jjdo_retire]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_retire}

Archive a
{jjdhr_heat}
by writing a trophy file, removing the heat from
{jjdgr_gallops},
deleting the paddock file, and committing.
This is a destructive operation that permanently removes the heat from active tracking.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjdt_firemark}
(positional) — target
{jjdhr_heat}

// ⟦axd_optional⟧
* `--execute` — perform the retire operation.
Without this flag, outputs trophy markdown to stdout as a dry-run preview.

{jjds_stdout}
Without `--execute`: trophy markdown content (dry-run preview).
With `--execute`: path to the written trophy file.

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

Without `--execute` (dry-run):

. Read
{jjdgr_gallops}
from file
. Verify
{jjdhr_heat}
exists with given
{jjdt_firemark}
. Read paddock file contents from
{jjdhm_paddock}
. Call
{jjdo_rein}
internally to get steeplechase entries
. Build trophy markdown (see format below)
. Output trophy markdown to stdout

With `--execute`:

. Acquire lock (`refs/vvg/locks/vvx`)
. Read
{jjdgr_gallops}
from file
. Verify
{jjdhr_heat}
exists with given
{jjdt_firemark}
. Extract
{jjdhr_heat}
metadata:
{jjdhm_silks},
{jjdhm_created}
. Read paddock file contents from
{jjdhm_paddock}
. Call
{jjdo_rein}
internally to get steeplechase entries
. Build trophy markdown:
+
----
# Heat Trophy: {silks}

**Firemark:** {firemark}
**Created:** {created}
**Retired:** {today}
**Status:** retired

## Paddock

{full paddock content}

## Paces

{for each pace in order:}

### {pace_silks} ({coronet}) [{final_state}]

{for each tack, newest first:}
**[{ts}] {state}**

{tack text}

{if tack has direction:}
*Direction:* {direction}

## Steeplechase

{for each steeplechase entry from rein, newest first:}

### {date} - {pace_silks or "Heat"} - {marker or "commit"}

{subject/description}

----
. Compute trophy filename: `.claude/jjm/retired/jjh_b{created}-r{today}-{silks}.md`
where `{today}` is current date in YYMMDD format
. Create `.claude/jjm/retired/` directory if it does not exist
. Write trophy markdown to trophy file
. Remove
{jjdhr_heat}
entry from
{jjdgr_gallops}
`heats` object
. Write transformed
{jjdgr_gallops}
to file (atomic)
. Delete paddock file at
{jjdhm_paddock}
. Stage exactly three paths: trophy file, gallops.json, paddock file (as deletion)
. Run size guard with 200KB limit (trophy files can be large for big heats)
. Commit with message per steeplechase conventions (format TBD by unify-commit-format)
. Release lock
. Output trophy file path to stdout

=== Read Operations

[[jjdo_validate]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_validate}

Check that
{jjdgr_gallops}
JSON conforms to schema.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

{jjds_stdout} None

{jjds_exit_uniform} 0 success, non-zero error.

*Validation Rules:*

. Root must be JSON object with
{jjdgm_seed}
(2 URL-safe base64 characters matching `[A-Za-z0-9_-]{2}`)
. Root must have `heats` object
. Each
{jjdhr_heat}
key must match `₣[A-Za-z0-9_-]{2}`
. Each
{jjdhr_heat}
must have:
{jjdhm_silks}
(non-empty kebab-case),
{jjdhm_created}
(YYMMDD),
{jjdhm_status}
({jjdhe_current}
or
{jjdhe_retired}),
{jjdhm_order}
(array),
{jjdhm_seed}
(3 URL-safe base64 characters matching `[A-Za-z0-9_-]{3}`),
`paces` (object)
. {jjdhm_order}
array and `paces` object must have identical key sets
. Each
{jjdpr_pace}
key must match `₢[A-Za-z0-9_-]{5}` and embed parent
{jjdhr_heat}
identity (first 2 base64 chars after prefix)
. Each
{jjdpr_pace}
must have:
{jjdpm_silks}
(non-empty kebab-case),
`tacks` (non-empty array)
. Each
{jjdkr_tack}
must have:
{jjdkm_refined}
(YYMMDD-HHMM),
{jjdkm_state}
({jjdpe_rough},
{jjdpe_bridled},
{jjdpe_complete},
or
{jjdpe_abandoned}),
{jjdkm_text}
(non-empty string)
. If
{jjdkm_state}
is
{jjdpe_bridled},
{jjdkm_direction}
must be present (non-empty string); otherwise
{jjdkm_direction}
must be absent

[[jjdo_muster]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_muster}

List all
{jjdhr_heat_s}
with summary information.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_optional⟧
* {jjda_status}
— filter to show only
{jjdhr_heat_s}
with this status; if absent, show all

{jjds_stdout} Tab-separated values, one line per
{jjdhr_heat}:
`{jjdt_firemark}<TAB>{jjdt_silks}<TAB>{jjdhm_status}<TAB><pace_count>`

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Read
{jjdgr_gallops}
from file
. Iterate over `heats` object entries
. If
{jjda_status}
provided, skip
{jjdhr_heat_s}
not matching filter
. For each included
{jjdhr_heat},
output TSV line:
{jjdt_firemark},
{jjdhm_silks},
{jjdhm_status},
count of
{jjdpr_pace_s}
in `paces` object
. Output lines in arbitrary order (JSON object iteration order)

[[jjdo_saddle]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_saddle}

Return context needed to saddle up on a
{jjdhr_heat}:
the current
{jjdpr_pace}
(first in
{jjdhm_order}
whose state is
{jjdpe_rough}
or
{jjdpe_bridled})
and its
{jjdkr_tack}
details.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjdt_firemark}
(positional) — target
{jjdhr_heat}

{jjds_stdout} JSON object with structure:
[source,json]
----
{
  "heat_silks": "...",
  "paddock_file": ".claude/jjm/jjp_XX.md",
  "paddock_content": "...",
  "pace_coronet": "₢XXXXX",
  "pace_silks": "...",
  "pace_state": "rough|bridled",
  "tack_text": "...",
  "tack_direction": "..."
}
----
Fields `pace_coronet` through `tack_direction` are absent if no actionable pace exists.
Field `tack_direction` is present only when `pace_state` is
{jjdpe_bridled}.
Field `paddock_content` contains the full text of the paddock file.

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Read
{jjdgr_gallops}
from file
. Verify
{jjdhr_heat}
exists with given
{jjdt_firemark}
. Output `heat_silks` from
{jjdhr_heat}
. Output `paddock_file` from
{jjdhm_paddock}
. Read paddock file contents, output as `paddock_content`
. Walk
{jjdhm_order}
array in sequence
. For each
{jjdt_coronet},
check `paces[coronet].tacks[0].state`
. If state is
{jjdpe_rough}
or
{jjdpe_bridled}:
.. Output `pace_coronet`,
`pace_silks`,
`pace_state`
.. Output `tack_text` from `tacks[0].text`
.. If state is
{jjdpe_bridled},
output `tack_direction` from `tacks[0].direction`
.. Stop walking (first match wins)
. If no actionable pace found, output only `heat_silks`, `paddock_file`, and `paddock_content`

[[jjdo_parade]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_parade}

Display
{jjdhr_heat}
status in human-readable text format.
Output varies by format mode.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjdt_firemark}
(positional) — target
{jjdhr_heat}

// ⟦axd_optional axd_defaulted⟧
* `--format <mode>` — output format mode (default: `full`)

// ⟦axd_optional⟧
* `--pace <coronet>` — target
{jjdt_coronet}
(required with `--format detail`)

// ⟦axd_optional⟧
* `--remaining` — show only remaining paces (exclude
{jjdpe_complete}
and
{jjdpe_abandoned})

*Format Modes*

[cols="1,2,3"]
|===
| Mode | Purpose | Output

| `overview`
| Quick status
| One line per pace: `[state] silks (₢coronet)`

| `order`
| Dependency check
| Numbered: `N. [state] silks (₢coronet)`

| `detail`
| Inspect one pace
| Full tack text for specified pace (requires `--pace`)

| `full`
| Planning context
| Paddock content + all paces with tack text
|===

{jjds_stdout} Human-readable text (not JSON).

*Example output — overview:*
----
[abandoned] vvw-workbench-tabtarget (₢AAAAC)
[complete] install-arch-decision (₢AAAAI)
[rough] vvx-push-rename (₢AAAAJ)
----

*Example output — order:*
----
1. [abandoned] vvw-workbench-tabtarget (₢AAAAC)
2. [complete] install-arch-decision (₢AAAAI)
3. [rough] vvx-push-rename (₢AAAAJ)
----

*Example output — detail:*
----
Pace: vvx-push-rename (₢AAAAJ)
State: rough
Heat: ₣AA

[full tack text...]
----

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Validate arguments (if `--format detail`, require `--pace`)
. Read
{jjdgr_gallops}
from file
. Verify
{jjdhr_heat}
exists with given
{jjdt_firemark}
. Match on format mode:
.. *overview*: For each pace in
{jjdhm_order},
print `[state] silks (coronet)`
.. *order*: Same as overview with line numbers
.. *detail*: Find specified pace, print header and full tack text
.. *full*: Print heat header, paddock content, then each pace with tack text

=== Steeplechase Operations

The steeplechase is Job Jockey's session history, stored in git commits rather than the
{jjdgr_gallops}
JSON.
Commit messages follow patterns that
{jjdo_rein}
can parse to reconstruct session history.

==== Commit Message Patterns

All JJ commits use the format: `jjb:BRAND:IDENTITY[:ACTION]: message`

* `jjb` — JJ brand prefix (literal)
* `BRAND` — repository identifier baked into arcanum at install time (e.g., "RBM")
* `IDENTITY` — ₢CORONET for pace-level, ₣FIREMARK for heat-level
* `ACTION` — single-letter code (required for all commits)

*Standard notch* (created by {jjdo_notch}):
----
jjb:BRAND:₢XXXXX:n: commit message

Co-Authored-By: ...
----

Standard notch commits use `n` to denote routine progress tracking.

*Pace-level chalk* (created by {jjdo_chalk}):
----
jjb:BRAND:₢XXXXX:A: description

Co-Authored-By: ...
----

Pace-level action codes:

* `n` — Notch: standard commit
* `A` — APPROACH: proposed approach before work begins
* `W` — WRAP: pace completion summary
* `F` — FLY: autonomous execution began (bridled pace)
* `d` — discussion: significant decision (lowercase, can also be heat-level)

*Heat-level operations*:
----
jjb:BRAND:₣XX:N: heat-silks
jjb:BRAND:₣XX:S: pace-silks
jjb:BRAND:₣XX:r: reordered
jjb:BRAND:₣XX:T: pace-silks
jjb:BRAND:₣XX:D: old-coronet → new-coronet
jjb:BRAND:₣XX:R: heat-silks
----

Heat-level action codes:

* `N` — Nominate: create new heat
* `S` — Slate: add new pace
* `r` — rail: reorder paces (lowercase)
* `T` — Tally: add tack to pace
* `D` — Draft: move pace between heats (uppercase, rare)
* `R` — Retire: archive heat (uppercase)

[[jjdo_rein]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_rein}

Parse git history for steeplechase entries belonging to a
{jjdhr_heat}.

{jjds_arguments}

// ⟦axd_required⟧
* {jjdt_firemark}
(positional) — target
{jjdhr_heat}

// ⟦axd_optional⟧
* `--limit` — maximum entries to return (default: 50)

{jjds_stdout} JSON array of steeplechase entries:
[source,json]
----
[
  {
    "timestamp": "YYYY-MM-DD HH:MM",
    "coronet": "₢XXXXX",
    "action": "n",
    "subject": "commit message"
  },
  {
    "timestamp": "YYYY-MM-DD HH:MM",
    "coronet": "₢XXXXX",
    "action": "A",
    "subject": "description"
  },
  {
    "timestamp": "YYYY-MM-DD HH:MM",
    "action": "N",
    "subject": "heat-silks"
  }
]
----
Field `coronet` is present for pace-level entries, absent for heat-level operations.
Field `action` is present for all commits, including standard notch commits (`n`).
Entries ordered newest first.

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Run `git log --all --extended-regexp --grep="^jjb:[^:]+:(₣XX|₢XX)" --format="%ai%x09%s"`
  (matches any brand; filtering is by identity, not brand)
. Parse each line: extract timestamp, identity, action (if present), and message
. For pace-level (₢CORONET): verify coronet belongs to target heat
. For heat-level (₣FIREMARK): verify firemark matches target heat
. Build JSON array, limit to requested count
. Output JSON

[[jjdo_notch]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_notch}

Create a JJ-aware git commit with heat/pace context prefix.

{jjds_arguments}

// ⟦axd_required⟧
* {jjdt_coronet}
(positional) — active pace identity (embeds parent heat)

// ⟦axd_optional⟧
* `--size-limit` — size limit in bytes for the commit guard (default: 50KB).
Use when the pace spec justifies legitimate large commits.

{jjds_stdout} Commit hash

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Acquire lock (`refs/vvg/locks/vvx`)
. Stage changes (`git add -u`)
. Run size guard check (uses `--size-limit` if provided, otherwise 50KB default)
. Run `claude --print "Generate commit message for this diff: $(git diff --cached)"`
. Format full message: `jjb:BRAND:₢XXXXX:n: message\n\nCo-Authored-By: ...`
. Run `git commit -m "..."`
. Release lock
. Output commit hash

[[jjdo_chalk]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_chalk}

Create an empty commit marking a steeplechase event.

{jjds_arguments}

// ⟦axd_required⟧
* identity (positional) — {jjdt_coronet} for pace-level, {jjdt_firemark} for heat-level discussion

// ⟦axd_required⟧
* `--marker` — marker type: `A`, `W`, `F`, or `d` (single letter codes)

// ⟦axd_required⟧
* `--description` — marker description text

{jjds_stdout} Commit hash

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Acquire lock (`refs/vvg/locks/vvx`)
. Detect identity type by length (5 chars = coronet, 2 chars = firemark)
. Validate: `A`/`W`/`F` require coronet; `d` accepts either
. Format message:
.. If coronet: `jjb:BRAND:₢XXXXX:X: description\n\nCo-Authored-By: ...`
.. If firemark (discussion only): `jjb:BRAND:₣XX:d: description\n\nCo-Authored-By: ...`
. Run `git commit --allow-empty -m "..."`
. Release lock
. Output commit hash
