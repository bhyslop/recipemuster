= Job Jockey Gallops Data Model
:doctype: book

// tag::mapping-section[]
//
// Category declarations:
// jjdt_:  Types (scalar value types with validation rules)
// jjdgr_: Gallops record
// jjdgm_: Gallops members
// jjdhr_: Heat record
// jjdhm_: Heat members
// jjdhe_: Heat enum values (status)
// jjdpr_: Pace record
// jjdpm_: Pace members
// jjdkr_: Tack record
// jjdkm_: Tack members
// jjdpe_: Tack state enum values
// jjdo_:  Operations
// jjds_:  Section headers (operation documentation structure)
// jjdz_:  Serialization concerns
//
// Variant patterns:
//   _s: plural form
//   _p: possessive form
//

// Types
:jjdt_coronet:    <<jjdt_coronet,Coronet>>
:jjdt_coronet_p:  <<jjdt_coronet,Coronet's>>
:jjdt_coronet_s:  <<jjdt_coronet,Coronets>>
:jjdt_firemark:   <<jjdt_firemark,Firemark>>
:jjdt_firemark_p: <<jjdt_firemark,Firemark's>>
:jjdt_firemark_s: <<jjdt_firemark,Firemarks>>
:jjdt_silks:      <<jjdt_silks,Silks>>

// Gallops record and members
:jjdgm_seed:        <<jjdgm_seed,next_heat_seed>>
:jjdgr_gallops:     <<jjdgr_gallops,Gallops>>
:jjdgr_gallops_p:   <<jjdgr_gallops,Gallops'>>

// Heat record and members
:jjdhe_current:   <<jjdhe_current,current>>
:jjdhe_retired:   <<jjdhe_retired,retired>>
:jjdhm_created:   <<jjdhm_created,creation_time>>
:jjdhm_firemark:  <<jjdhm_firemark,firemark>>
:jjdhm_order:     <<jjdhm_order,order>>
:jjdhm_seed:      <<jjdhm_seed,next_pace_seed>>
:jjdhm_silks:     <<jjdhm_silks,silks>>
:jjdhm_status:    <<jjdhm_status,status>>
:jjdhr_heat:      <<jjdhr_heat,Heat>>
:jjdhr_heat_p:    <<jjdhr_heat,Heat's>>
:jjdhr_heat_s:    <<jjdhr_heat,Heats>>

// Pace record and members
:jjdpm_coronet:   <<jjdpm_coronet,coronet>>
:jjdpm_silks:     <<jjdpm_silks,silks>>
:jjdpr_pace:      <<jjdpr_pace,Pace>>
:jjdpr_pace_p:    <<jjdpr_pace,Pace's>>
:jjdpr_pace_s:    <<jjdpr_pace,Paces>>

// Pace/Tack state enum values (used in Tack)
:jjdpe_abandoned: <<jjdpe_abandoned,abandoned>>
:jjdpe_complete:  <<jjdpe_complete,complete>>
:jjdpe_primed:    <<jjdpe_primed,primed>>
:jjdpe_rough:     <<jjdpe_rough,rough>>

// Tack record and members
:jjdkm_direction: <<jjdkm_direction,direction>>
:jjdkm_refined:   <<jjdkm_refined,ts>>
:jjdkm_state:     <<jjdkm_state,state>>
:jjdkm_text:      <<jjdkm_text,text>>
:jjdkr_tack:      <<jjdkr_tack,Tack>>
:jjdkr_tack_p:    <<jjdkr_tack,Tack's>>
:jjdkr_tack_s:    <<jjdkr_tack,Tacks>>

// Arguments
:jjda_created:        <<jjda_created,--created>>
:jjda_direction:      <<jjda_direction,--direction>>
:jjda_file:           <<jjda_file,--file>>
:jjda_silks:          <<jjda_silks,--silks>>
:jjda_state:          <<jjda_state,--state>>

// CLI executor
:jjdx_vvx:   <<jjdx_vvx,vvx>>
:jjdx_cli:   <<jjdx_cli,jjx>>

// Operations
:jjdo_current_pace:   <<jjdo_current_pace,jjx_current_pace>>
:jjdo_current_tack:   <<jjdo_current_tack,jjx_current_tack>>
:jjdo_heat_exists:    <<jjdo_heat_exists,jjx_heat_exists>>
:jjdo_muster:         <<jjdo_muster,jjx_muster>>
:jjdo_nominate:       <<jjdo_nominate,jjx_nominate>>
:jjdo_rail:           <<jjdo_rail,jjx_rail>>
:jjdo_retire_extract: <<jjdo_retire_extract,jjx_retire_extract>>
:jjdo_slate:          <<jjdo_slate,jjx_slate>>
:jjdo_tally:          <<jjdo_tally,jjx_tally>>
:jjdo_validate:       <<jjdo_validate,jjx_validate>>

// Section headers
:jjds_arguments:        <<jjds_arguments,Arguments:>>
:jjds_behavior:         <<jjds_behavior,Behavior:>>
:jjds_exit_enumerated:  <<jjds_exit_enumerated,Exit Status:>>
:jjds_exit_uniform:     <<jjds_exit_uniform,Exit Status:>>
:jjds_stdout:           <<jjds_stdout,Stdout:>>

// Serialization
:jjdz_charset:  <<jjdz_charset,Charset>>
:jjdz_encoding: <<jjdz_encoding,Identity Encoding>>

// end::mapping-section[]

== Overview

The
{jjdgr_gallops}
is the persistent data store for Job Jockey.
It tracks
{jjdhr_heat_s}
(bounded initiatives) and their constituent
{jjdpr_pace_s}
(discrete actions).
Each
{jjdpr_pace}
maintains a history of
{jjdkr_tack_s}
(plan refinements).

== Design Principles

=== Exclusive JSON Ownership

All access to the
{jjdgr_gallops}
goes through {jjdx_cli}, the Job Jockey subcommand of the Voce Viva executor.
No jq or direct JSON manipulation ever touches this data.
This is an absolute architectural constraint, not a preference.

The rationale: writing reliable bash with jq pipelines requires fighting LLM training data.
The internet is full of bad bash.
Rust replaces fragile jq invocations with compiler-enforced correctness.
The compiler is tireless; humans are not.

=== Git as Journal

The
{jjdgr_gallops}
remains JSON specifically so git can serve as the journalling layer.
Every mutation creates a diffable commit.
Git owns the complete history; we need not implement our own audit trail.

The
{jjdkr_tack}
history within each
{jjdpr_pace}
exists for convenient postmortem analysis.
Git has the full history, but
{jjdkr_tack_s}
let us see plan evolution without spelunking commits.

=== Diff-Friendly Mutations

New
{jjdkr_tack_s}
prepend to position 0 rather than append.
This produces cleaner git diffs: prepending adds a line with trailing comma, while appending would modify the previous last line to add a comma.
Small discipline, large cumulative benefit.

The
{jjdhm_order}
array contains full
{jjdt_coronet_s}.
Each
{jjdt_coronet}
embeds its parent
{jjdt_firemark}
(redundant within a single
{jjdhr_heat}).
This redundancy is cheap and enables grep, copy-paste, and self-documenting JSON.

=== Crash-Safe Architecture

Bash handles locking via `git update-ref`.
{jjdx_cli} owns all
{jjdgr_gallops}
file access - reading, transforming, and writing.
{jjdx_cli} implements atomic writes internally (write to temp file, then rename).
If {jjdx_cli} crashes mid-transform, no partial writes occur.

The pattern:
[source,bash]
----
lock_acquire
vvx jjx gallops nominate --file gallops.json "my-heat" "260111" || { lock_release; die; }
lock_release
----

This keeps bash simple (just locking and invocation) while {jjdx_cli} owns all JSON file operations.

=== Identity Encoding

{jjdt_firemark}
(`₣` prefix) and
{jjdt_coronet}
(`₢` prefix) are the canonical identities used in JSON keys, CLI arguments, and display.
The base64 encoding provides compact, URL-safe, shell-safe strings.
Internally, Rust may decode to integers for arithmetic, but the string form is authoritative.

=== Horse Racing Vocabulary

Job Jockey uses horse racing metaphors throughout.
This is intentional: vivid domain vocabulary helps humans hold complex systems in working memory.

* {jjdhr_heat} - a bounded initiative (like a race)
* {jjdpr_pace} - a discrete action (the rhythm of the race)
* {jjdkr_tack} - plan refinement (equipment; also "tacking" = adjusting course)
* {jjdt_firemark} - heat identity, `₣`-prefixed (hot-iron brand marking ownership)
* {jjdt_coronet} - pace identity, `₢`-prefixed (marking at the hoof line)
* {jjdt_silks} - display name (jockey's colors)
* {jjdgr_gallops} - the training grounds (where real work happens before race day)

== Types

[[jjdt_firemark]]
// ⟦axl_voices axt_string⟧
{jjdt_firemark}::
The identity of a
{jjdhr_heat}.
Format: `₣` + 2 base64 characters (e.g., `₣AB`).
The 2 base64 characters encode an integer 0-4095 (2^12).
Used as JSON keys and in CLI arguments.
Input may omit the `₣` prefix; output always includes it.

[[jjdt_coronet]]
// ⟦axl_voices axt_string⟧
{jjdt_coronet}::
The identity of a
{jjdpr_pace}.
Format: `₢` + 5 base64 characters (e.g., `₢ABCDE`).
Globally unique: the first 2 base64 characters are the parent
{jjdhr_heat_p}
encoded identity; the remaining 3 encode the pace index (0-262143, 2^18).
Used as JSON keys and in CLI arguments.
Input may omit the `₢` prefix; output always includes it.

[[jjdt_silks]]
// ⟦axl_voices axt_string⟧
{jjdt_silks}::
A kebab-case display name.
Used for human-readable identification of
{jjdhr_heat_s}
and
{jjdpr_pace_s}.
Pattern: `[a-z0-9]+(-[a-z0-9]+)*`

== Records

=== {jjdgr_gallops}

[[jjdgr_gallops]]
// ⟦axl_voices axr_record_json⟧
{jjdgr_gallops}::
The root JSON structure containing all Job Jockey data.
Singleton record persisted at `.claude/jjm/jjg_gallops.json`.

==== Members

* [[jjdgm_seed]]
// ⟦axl_voices axr_member axd_required⟧
{jjdgm_seed}
is the next
{jjdt_firemark}
to allocate, stored as 2 base64 characters.
Incremented by
{jjdo_nominate}.

=== {jjdhr_heat}

[[jjdhr_heat]]
// ⟦axl_voices axr_record_json⟧
{jjdhr_heat}::
A bounded initiative with coherent goals.
Contains zero or more
{jjdpr_pace_s}
representing discrete actions.
Keyed in JSON by
{jjdt_firemark}.

==== Members

* [[jjdhm_firemark]]
// ⟦axl_voices axr_member axd_required⟧
{jjdhm_firemark}
is the
{jjdhr_heat_p}
primary key.
Type:
{jjdt_firemark}.
Implicit from JSON key; not stored as separate field.

* [[jjdhm_silks]]
// ⟦axl_voices axr_member axd_required⟧
{jjdhm_silks}
is the
{jjdhr_heat_p}
display name.
Type:
{jjdt_silks}.

* [[jjdhm_created]]
// ⟦axl_voices axr_member axd_required⟧
{jjdhm_created}
records when the
{jjdhr_heat}
was nominated.
Format: YYMMDD.

* [[jjdhm_status]]
// ⟦axl_voices axr_member axd_required⟧
{jjdhm_status}
indicates the
{jjdhr_heat_p}
lifecycle state.
Values:
{jjdhe_current}
or
{jjdhe_retired}.

* [[jjdhm_order]]
// ⟦axl_voices axr_member axd_required axd_repeated⟧
{jjdhm_order}
lists
{jjdt_coronet_s}
in execution sequence.
May be reordered via
{jjdo_rail}.

* [[jjdhm_seed]]
// ⟦axl_voices axr_member axd_required⟧
{jjdhm_seed}
is the next
{jjdt_coronet}
index to allocate, stored as 3 base64 characters.
Incremented by
{jjdo_slate}.

==== Status Values

[[jjdhe_current]]
// ⟦axl_voices axt_enum_value⟧
{jjdhe_current}::
The
{jjdhr_heat}
is active and accepting work.

[[jjdhe_retired]]
// ⟦axl_voices axt_enum_value⟧
{jjdhe_retired}::
The
{jjdhr_heat}
is complete and archived.

=== {jjdpr_pace}

[[jjdpr_pace]]
// ⟦axl_voices axr_record_json⟧
{jjdpr_pace}::
A discrete action within a
{jjdhr_heat}.
Contains one or more
{jjdkr_tack_s}
representing state snapshots and plan refinements.
Current state is derived from `tacks[0].state`.
Keyed in JSON by
{jjdt_coronet}.

==== Members

* [[jjdpm_coronet]]
// ⟦axl_voices axr_member axd_required⟧
{jjdpm_coronet}
is the
{jjdpr_pace_p}
globally unique identity.
Type:
{jjdt_coronet}.
Implicit from JSON key; not stored as separate field.

* [[jjdpm_silks]]
// ⟦axl_voices axr_member axd_required⟧
{jjdpm_silks}
is the
{jjdpr_pace_p}
display name.
Type:
{jjdt_silks}.

=== {jjdkr_tack}

[[jjdkr_tack]]
// ⟦axl_voices axr_record_json⟧
{jjdkr_tack}::
A snapshot of
{jjdpr_pace}
state and plan at a point in time.
{jjdkr_tack_s}
form an append-only history capturing both plan refinements and state transitions.
Position 0 is the most recent; older
{jjdkr_tack_s}
follow.
New
{jjdkr_tack_s}
are prepended for cleaner git diffs.
The current
{jjdpr_pace}
state is always
`tacks[0].state`.

==== Members

* [[jjdkm_refined]]
// ⟦axl_voices axr_member axd_required⟧
{jjdkm_refined}
records when this
{jjdkr_tack}
was added.
Format: YYMMDD-HHMM.

* [[jjdkm_state]]
// ⟦axl_voices axr_member axd_required⟧
{jjdkm_state}
indicates the
{jjdpr_pace_p}
progress at this snapshot.
Values:
{jjdpe_rough},
{jjdpe_primed},
{jjdpe_complete},
or
{jjdpe_abandoned}.

* [[jjdkm_text]]
// ⟦axl_voices axr_member axd_required⟧
{jjdkm_text}
contains the plan specification.
Non-empty string describing what the
{jjdpr_pace}
should accomplish.

* [[jjdkm_direction]]
// ⟦axl_voices axr_member axd_conditional⟧
{jjdkm_direction}
contains execution guidance for autonomous operation.
Required when
{jjdkm_state}
is
{jjdpe_primed};
forbidden otherwise.
Describes which agent to dispatch, parallelism strategy, or other execution parameters.

==== State Values

[[jjdpe_rough]]
// ⟦axl_voices axt_enum_value⟧
{jjdpe_rough}::
The
{jjdpr_pace}
needs clarification before work can proceed.
When context is assembled for a
{jjdpe_rough}
pace, the model is guided to refine the specification rather than begin execution.

[[jjdpe_primed]]
// ⟦axl_voices axt_enum_value⟧
{jjdpe_primed}::
The
{jjdpr_pace}
is ready for autonomous execution.
The
{jjdkm_direction}
field contains explicit guidance for the executing agent.
When context is assembled for a
{jjdpe_primed}
pace, the model proceeds without human confirmation.

[[jjdpe_complete]]
// ⟦axl_voices axt_enum_value⟧
{jjdpe_complete}::
The
{jjdpr_pace}
has been successfully finished.

[[jjdpe_abandoned]]
// ⟦axl_voices axt_enum_value⟧
{jjdpe_abandoned}::
The
{jjdpr_pace}
was stopped without completion.

== Serialization

[[jjdz_charset]]
{jjdz_charset}::
The 64-character alphabet for identity encoding.
Uses URL-safe base64 (RFC 4648 §5):
`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_`
Position in charset determines numeric value (A=0, B=1, ..., `-`=62, `_`=63).
This alphabet is safe for JSON keys, URLs, shell, git refs, and filenames.
Matches Rust `base64::engine::general_purpose::URL_SAFE_NO_PAD`.

[[jjdz_encoding]]
{jjdz_encoding}::
The algorithm for encoding
{jjdt_firemark}
and
{jjdt_coronet}
values.
+
*{jjdt_firemark} (Heat identity):*
+
. Format: `₣` + 2 base64 characters
. Given integer H (0-4095): encode as `₣` + `charset[H/64]` + `charset[H%64]`
. To decode `₣XY`: H = pos(X) * 64 + pos(Y)
+
*{jjdt_coronet} (Pace identity):*
+
. Format: `₢` + 5 base64 characters
. First 2 characters encode the parent Heat (same as {jjdt_firemark} without prefix)
. Last 3 characters encode the pace index P (0-262143)
. Given Heat H and pace index P: encode as `₢` + `charset[H/64]` + `charset[H%64]` + `charset[P/4096]` + `charset[(P/64)%64]` + `charset[P%64]`
. To decode `₢XYZAB`: H from XY, P = pos(Z) * 4096 + pos(A) * 64 + pos(B)
+
*Input flexibility:*
+
CLI commands accept identities with or without prefix.
Length determines type: 2 base64 chars = {jjdt_firemark}, 5 base64 chars = {jjdt_coronet}.
Output always includes the prefix (`₣` or `₢`).

== Arguments

*Note:* {jjda_file} appears as the first argument on all operations.
It is annotated `// ⟦axd_optional axd_defaulted⟧` and uses the default value when not explicitly provided.

[[jjda_file]]
// ⟦axl_voices axa_cli_option⟧
{jjda_file}::
Path to the
{jjdgr_gallops}
JSON file.
Long: `--file`.
Short: none.
Default: `.claude/jjm/jjg_gallops.json`.

[[jjda_silks]]
// ⟦axl_voices axa_cli_option⟧
{jjda_silks}::
Kebab-case display name for the target entity.
Long: `--silks`.
Short: `-s`.

[[jjda_state]]
// ⟦axl_voices axa_cli_option⟧
{jjda_state}::
Target state for the
{jjdkr_tack}.
Long: `--state`.
Short: none.
Values:
{jjdpe_rough},
{jjdpe_primed},
{jjdpe_complete},
{jjdpe_abandoned}.

[[jjda_direction]]
// ⟦axl_voices axa_cli_option⟧
{jjda_direction}::
Execution guidance for autonomous operation.
Long: `--direction`.
Short: `-d`.
Required when
{jjda_state}
is
{jjdpe_primed};
forbidden otherwise.

[[jjda_created]]
// ⟦axl_voices axa_cli_option⟧
{jjda_created}::
Creation date in YYMMDD format.
Long: `--created`.
Short: `-c`.

== Section Headers

[[jjds_arguments]]
// ⟦axl_voices axa_argument_list⟧
{jjds_arguments}::
Section header introducing operation arguments.

[[jjds_stdout]]
{jjds_stdout}::
Section header introducing operation standard output.

[[jjds_exit_uniform]]
// ⟦axl_voices axa_exit_uniform⟧
{jjds_exit_uniform}::
Section header for operations with standard exit semantics.

[[jjds_exit_enumerated]]
// ⟦axl_voices axa_exit_enumerated⟧
{jjds_exit_enumerated}::
Section header for operations with distinct exit codes.

[[jjds_behavior]]
{jjds_behavior}::
Section header introducing operation behavior steps.

== CLI

[[jjdx_vvx]]
// ⟦axl_voices axi_cli_program⟧
{jjdx_vvx}::
The Voce Viva executor.
Local reference to the VVK-defined CLI program that hosts Job Jockey.

[[jjdx_cli]]
// ⟦axl_voices axi_cli_command_group⟧
{jjdx_cli}::
The Job Jockey command group within
{jjdx_vvx}.
Invoked as `vvx jjx`.
All operations are subcommands of
{jjdx_cli}.
Inherits Unix CLI semantics: stdout for results, stderr for errors, exit 0 for success, non-zero for failure.

== Operations

Operations are implemented as {jjdx_cli} subcommands.
{jjdx_cli} owns all
{jjdgr_gallops}
file access (read, transform, atomic write).
Bash handles locking via `git update-ref` and invokes {jjdx_cli} with
{jjda_file}.

=== Write Operations

[[jjdo_nominate]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_nominate}

Create a new
{jjdhr_heat}
with empty
{jjdpr_pace}
structure.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjda_silks}

// ⟦axd_required⟧
* {jjda_created}

{jjds_stdout} New
{jjdt_firemark}

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Read
{jjdgr_gallops}
from file
. Read current
{jjdgm_seed}
as
{jjdt_firemark}
. Create new
{jjdhr_heat}
with:
.. Key: `₣` + encoded
{jjdt_firemark}
.. {jjdhm_silks}:
from argument
.. {jjdhm_created}:
from argument
.. {jjdhm_status}:
{jjdhe_current}
.. {jjdhm_order}:
empty array
.. {jjdhm_seed}:
`AAA` (index 0)
.. `paces`: empty object
. Increment
{jjdgm_seed}
(base64 arithmetic with carry)
. Write transformed
{jjdgr_gallops}
to file (atomic)
. Output new
{jjdt_firemark}
to stdout

[[jjdo_slate]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_slate}

Add a new
{jjdpr_pace}
to a
{jjdhr_heat}.
The initial
{jjdkr_tack}
is created with state
{jjdpe_rough}.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjdt_firemark}
(positional) — target
{jjdhr_heat}

// ⟦axd_required⟧
* {jjda_silks}

// ⟦axd_required⟧
* stdin —
{jjdkm_text}
content for the initial
{jjdkr_tack}

{jjds_stdout} New
{jjdt_coronet}

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Read
{jjdgr_gallops}
from file
. Verify
{jjdhr_heat}
exists with given
{jjdt_firemark}
. Read
{jjdhm_seed}
from target
{jjdhr_heat}
. Construct
{jjdt_coronet}:
`₢` + encoded
{jjdt_firemark}
(2 chars) +
{jjdhm_seed}
(3 chars)
. Create new
{jjdpr_pace}
with:
.. Key: constructed
{jjdt_coronet}
.. {jjdpm_silks}:
from argument
.. `tacks`: array with single
{jjdkr_tack}:
... {jjdkm_refined}:
current timestamp (YYMMDD-HHMM)
... {jjdkm_state}:
{jjdpe_rough}
... {jjdkm_text}:
from stdin
. Append
{jjdt_coronet}
to
{jjdhm_order}
. Increment
{jjdhm_seed}
(base64 arithmetic with carry)
. Write transformed
{jjdgr_gallops}
to file (atomic)
. Output new
{jjdt_coronet}
to stdout

[[jjdo_rail]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_rail}

Reorder
{jjdpr_pace_s}
within a
{jjdhr_heat}
by updating
{jjdhm_order}.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjdt_firemark}
(positional) — target
{jjdhr_heat}

// ⟦axd_required⟧
* order — array of
{jjdt_coronet_s}
in desired sequence (JSON array or space-separated)

{jjds_stdout} None

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Read
{jjdgr_gallops}
from file
. Verify
{jjdhr_heat}
exists with given
{jjdt_firemark}
. Parse order argument into array of
{jjdt_coronet_s}
. Validate order array:
.. Count must match current
{jjdhm_order}
length
.. No duplicate
{jjdt_coronet_s}
.. All
{jjdt_coronet_s}
must exist in
{jjdhr_heat_p}
`paces` object
.. All
{jjdt_coronet_s}
must embed correct parent
{jjdt_firemark}
. Replace
{jjdhm_order}
with new order array
. Write transformed
{jjdgr_gallops}
to file (atomic)

[[jjdo_tally]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_tally}

Add a new
{jjdkr_tack}
to a
{jjdpr_pace}.
This is the unified operation for all
{jjdkr_tack}
creation: state transitions, plan refinements, or both.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

// ⟦axd_required⟧
* {jjdt_coronet}
(positional)

// ⟦axd_optional⟧
* {jjda_state}
— if absent, inherits from previous
{jjdkr_tack}

// ⟦axd_conditional⟧
* {jjda_direction}
— required if
{jjda_state}
is
{jjdpe_primed};
forbidden if
{jjda_state}
is provided and not
{jjdpe_primed};
ignored if
{jjda_state}
is absent (inherits with state)

// ⟦axd_optional⟧
* stdin —
{jjdkm_text}
content; if absent, inherits from previous
{jjdkr_tack}

{jjds_stdout} None

{jjds_exit_uniform} 0 success, non-zero error.

{jjds_behavior}

. Read
{jjdgr_gallops}
from file
. Extract parent
{jjdt_firemark}
from
{jjdt_coronet}
(first 2 base64 chars after prefix)
. Verify
{jjdhr_heat}
exists
. Verify
{jjdpr_pace}
exists with given
{jjdt_coronet}
. Read current
{jjdkr_tack}
from `tacks[0]`
. Determine new state:
.. If
{jjda_state}
provided: use that value
.. Otherwise: inherit from previous
{jjdkr_tack}
. Determine new direction:
.. If
{jjda_state}
is
{jjdpe_primed}:
use
{jjda_direction}
argument (required)
.. If
{jjda_state}
is absent and previous state is
{jjdpe_primed}:
inherit from previous
{jjdkr_tack}
.. Otherwise: omit
{jjdkm_direction}
. Determine new text:
.. If stdin provided: use stdin content
.. Otherwise: inherit from previous
{jjdkr_tack}
. Create new
{jjdkr_tack}
with:
.. {jjdkm_refined}:
current timestamp (YYMMDD-HHMM)
.. {jjdkm_state}:
determined above
.. {jjdkm_text}:
determined above
.. {jjdkm_direction}:
determined above (if applicable)
. Prepend new
{jjdkr_tack}
to `tacks` array (position 0)
. Write transformed
{jjdgr_gallops}
to file (atomic)

=== Read Operations

[[jjdo_validate]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_validate}

Check that
{jjdgr_gallops}
JSON conforms to schema.

{jjds_arguments}

// ⟦axd_optional axd_defaulted⟧
* {jjda_file}

{jjds_stdout} None

{jjds_exit_uniform} 0 success, non-zero error.

*Validation Rules:*

. Root must be JSON object with
{jjdgm_seed}
(2 URL-safe base64 characters matching `[A-Za-z0-9_-]{2}`)
. Root must have `heats` object
. Each
{jjdhr_heat}
key must match `₣[A-Za-z0-9_-]{2}`
. Each
{jjdhr_heat}
must have:
{jjdhm_silks}
(non-empty kebab-case),
{jjdhm_created}
(YYMMDD),
{jjdhm_status}
({jjdhe_current}
or
{jjdhe_retired}),
{jjdhm_order}
(array),
{jjdhm_seed}
(3 URL-safe base64 characters matching `[A-Za-z0-9_-]{3}`),
`paces` (object)
. {jjdhm_order}
array and `paces` object must have identical key sets
. Each
{jjdpr_pace}
key must match `₢[A-Za-z0-9_-]{5}` and embed parent
{jjdhr_heat}
identity (first 2 base64 chars after prefix)
. Each
{jjdpr_pace}
must have:
{jjdpm_silks}
(non-empty kebab-case),
`tacks` (non-empty array)
. Each
{jjdkr_tack}
must have:
{jjdkm_refined}
(YYMMDD-HHMM),
{jjdkm_state}
({jjdpe_rough},
{jjdpe_primed},
{jjdpe_complete},
or
{jjdpe_abandoned}),
{jjdkm_text}
(non-empty string)
. If
{jjdkm_state}
is
{jjdpe_primed},
{jjdkm_direction}
must be present (non-empty string); otherwise
{jjdkm_direction}
must be absent

[[jjdo_heat_exists]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_heat_exists}

Check whether a
{jjdhr_heat}
with given
{jjdt_firemark}
exists.

{jjds_stdout} `true` or `false`

{jjds_exit_uniform} 0 success, non-zero error.

[[jjdo_muster]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_muster}

List all
{jjdhr_heat_s}
with summary information.

[[jjdo_retire_extract]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_retire_extract}

Extract
{jjdhr_heat}
data for archival trophy.

[[jjdo_current_tack]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_current_tack}

Return the most recent
{jjdkr_tack_p}
{jjdkm_text}
for a given
{jjdpr_pace}.

[[jjdo_current_pace]]
// ⟦axl_voices axi_cli_subcommand⟧
==== {jjdo_current_pace}

Return the first
{jjdpr_pace}
in
{jjdhm_order}
whose current state (from `tacks[0].state`) is
{jjdpe_rough}
or
{jjdpe_primed}.
